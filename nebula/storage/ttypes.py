#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import nebula.common.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ErrorCode', 'PropOwner', 'EngineSignType', 'StatType', 'EntryId', 'PropDef', 'ResultCode', 'EdgeKey', 'Edge', 'IdAndProp', 'EdgeData', 'TagData', 'VertexData', 'VertexIndexData', 'ResponseCommon', 'QueryResponse', 'ExecResponse', 'EdgePropResponse', 'QueryStatsResponse', 'Tag', 'Vertex', 'GetNeighborsRequest', 'VertexPropRequest', 'EdgePropRequest', 'AddVerticesRequest', 'AddEdgesRequest', 'DeleteVerticesRequest', 'DeleteEdgesRequest', 'AdminExecResp', 'AddPartReq', 'RemovePartReq', 'MemberChangeReq', 'TransLeaderReq', 'AddLearnerReq', 'CatchUpDataReq', 'CheckPeersReq', 'GetLeaderReq', 'GetLeaderResp', 'UpdateResponse', 'UpdateItem', 'UpdateVertexRequest', 'UpdateEdgeRequest', 'ScanEdgeRequest', 'ScanEdgeResponse', 'ScanEdge', 'ScanVertexRequest', 'ScanVertex', 'ScanVertexResponse', 'PutRequest', 'RemoveRequest', 'RemoveRangeRequest', 'GetRequest', 'PrefixRequest', 'ScanRequest', 'GeneralResponse', 'GetUUIDReq', 'GetUUIDResp', 'BlockingSignRequest', 'CreateCPRequest', 'DropCPRequest', 'RebuildIndexRequest', 'LookUpIndexRequest', 'LookUpIndexResp']

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAILED_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_LEADER_CHANGED = -11
  E_KEY_HAS_EXISTS = -12
  E_SPACE_NOT_FOUND = -13
  E_PART_NOT_FOUND = -14
  E_KEY_NOT_FOUND = -15
  E_CONSENSUS_ERROR = -16
  E_EDGE_PROP_NOT_FOUND = -21
  E_TAG_PROP_NOT_FOUND = -22
  E_IMPROPER_DATA_TYPE = -23
  E_EDGE_NOT_FOUND = -24
  E_TAG_NOT_FOUND = -25
  E_INDEX_NOT_FOUND = -26
  E_INVALID_FILTER = -31
  E_INVALID_UPDATER = -32
  E_INVALID_STORE = -33
  E_INVALID_PEER = -34
  E_RETRY_EXHAUSTED = -35
  E_TRANSFER_LEADER_FAILED = -36
  E_LOAD_META_FAILED = -41
  E_FAILED_TO_CHECKPOINT = -50
  E_CHECKPOINT_BLOCKED = -51
  E_FILTER_OUT = -60
  E_PARTIAL_RESULT = -99
  E_UNKNOWN = -100

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAILED_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -11: "E_LEADER_CHANGED",
    -12: "E_KEY_HAS_EXISTS",
    -13: "E_SPACE_NOT_FOUND",
    -14: "E_PART_NOT_FOUND",
    -15: "E_KEY_NOT_FOUND",
    -16: "E_CONSENSUS_ERROR",
    -21: "E_EDGE_PROP_NOT_FOUND",
    -22: "E_TAG_PROP_NOT_FOUND",
    -23: "E_IMPROPER_DATA_TYPE",
    -24: "E_EDGE_NOT_FOUND",
    -25: "E_TAG_NOT_FOUND",
    -26: "E_INDEX_NOT_FOUND",
    -31: "E_INVALID_FILTER",
    -32: "E_INVALID_UPDATER",
    -33: "E_INVALID_STORE",
    -34: "E_INVALID_PEER",
    -35: "E_RETRY_EXHAUSTED",
    -36: "E_TRANSFER_LEADER_FAILED",
    -41: "E_LOAD_META_FAILED",
    -50: "E_FAILED_TO_CHECKPOINT",
    -51: "E_CHECKPOINT_BLOCKED",
    -60: "E_FILTER_OUT",
    -99: "E_PARTIAL_RESULT",
    -100: "E_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAILED_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_LEADER_CHANGED": -11,
    "E_KEY_HAS_EXISTS": -12,
    "E_SPACE_NOT_FOUND": -13,
    "E_PART_NOT_FOUND": -14,
    "E_KEY_NOT_FOUND": -15,
    "E_CONSENSUS_ERROR": -16,
    "E_EDGE_PROP_NOT_FOUND": -21,
    "E_TAG_PROP_NOT_FOUND": -22,
    "E_IMPROPER_DATA_TYPE": -23,
    "E_EDGE_NOT_FOUND": -24,
    "E_TAG_NOT_FOUND": -25,
    "E_INDEX_NOT_FOUND": -26,
    "E_INVALID_FILTER": -31,
    "E_INVALID_UPDATER": -32,
    "E_INVALID_STORE": -33,
    "E_INVALID_PEER": -34,
    "E_RETRY_EXHAUSTED": -35,
    "E_TRANSFER_LEADER_FAILED": -36,
    "E_LOAD_META_FAILED": -41,
    "E_FAILED_TO_CHECKPOINT": -50,
    "E_CHECKPOINT_BLOCKED": -51,
    "E_FILTER_OUT": -60,
    "E_PARTIAL_RESULT": -99,
    "E_UNKNOWN": -100,
  }

class PropOwner:
  SOURCE = 1
  DEST = 2
  EDGE = 3

  _VALUES_TO_NAMES = {
    1: "SOURCE",
    2: "DEST",
    3: "EDGE",
  }

  _NAMES_TO_VALUES = {
    "SOURCE": 1,
    "DEST": 2,
    "EDGE": 3,
  }

class EngineSignType:
  BLOCK_ON = 1
  BLOCK_OFF = 2

  _VALUES_TO_NAMES = {
    1: "BLOCK_ON",
    2: "BLOCK_OFF",
  }

  _NAMES_TO_VALUES = {
    "BLOCK_ON": 1,
    "BLOCK_OFF": 2,
  }

class StatType:
  SUM = 1
  COUNT = 2
  AVG = 3

  _VALUES_TO_NAMES = {
    1: "SUM",
    2: "COUNT",
    3: "AVG",
  }

  _NAMES_TO_VALUES = {
    "SUM": 1,
    "COUNT": 2,
    "AVG": 3,
  }

class EntryId(object):
  """
  Attributes:
   - tag_id
   - edge_type
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  TAG_ID = 1
  EDGE_TYPE = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_tag_id(self):
    assert self.field == 1
    return self.value

  def get_edge_type(self):
    assert self.field == 2
    return self.value

  def set_tag_id(self, value):
    self.field = 1
    self.value = value

  def set_edge_type(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tag_id', value)
    if self.field == 2:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('edge_type', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          tag_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_tag_id(tag_id)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          edge_type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_edge_type(edge_type)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('EntryId')
    if self.field == 1:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      tag_id = self.value
      oprot.writeI32(tag_id)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      edge_type = self.value
      oprot.writeI32(edge_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PropDef:
  """
  Attributes:
   - owner
   - id
   - name
   - stat
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.owner = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.id = EntryId()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.stat = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PropDef')
    if self.owner != None:
      oprot.writeFieldBegin('owner', TType.I32, 1)
      oprot.writeI32(self.owner)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 2)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.stat != None:
      oprot.writeFieldBegin('stat', TType.I32, 4)
      oprot.writeI32(self.stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.owner is not None:
      value = pprint.pformat(self.owner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    owner=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.stat is not None:
      value = pprint.pformat(self.stat, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ResultCode:
  """
  Attributes:
   - code
   - part_id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.code == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'code' was not found in serialized data! Struct: ResultCode")

    if self.part_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'part_id' was not found in serialized data! Struct: ResultCode")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ResultCode')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeKey:
  """
  Attributes:
   - src
   - edge_type
   - ranking
   - dst
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.src = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.dst = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeKey')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.I64, 1)
      oprot.writeI64(self.src)
      oprot.writeFieldEnd()
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 3)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.I64, 4)
      oprot.writeI64(self.dst)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Edge:
  """
  Attributes:
   - key
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = EdgeKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.props = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Edge')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRING, 2)
      oprot.writeString(self.props)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IdAndProp:
  """
  Attributes:
   - dst
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.dst = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.props = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IdAndProp')
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.I64, 1)
      oprot.writeI64(self.dst)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRING, 2)
      oprot.writeString(self.props)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeData:
  """
  Attributes:
   - type
   - edges
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edges = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = IdAndProp()
              _elem5.read(iprot)
              self.edges.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = IdAndProp()
              _elem6.read(iprot)
              self.edges.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeData')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.edges != None:
      oprot.writeFieldBegin('edges', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edges))
      for iter7 in self.edges:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.edges is not None:
      value = pprint.pformat(self.edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edges=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TagData:
  """
  Attributes:
   - tag_id
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TagData')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRING, 2)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class VertexData:
  """
  Attributes:
   - vertex_id
   - tag_data
   - edge_data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.vertex_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tag_data = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = TagData()
              _elem13.read(iprot)
              self.tag_data.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = TagData()
              _elem14.read(iprot)
              self.tag_data.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edge_data = []
          (_etype18, _size15) = iprot.readListBegin()
          if _size15 >= 0:
            for _i19 in six.moves.range(_size15):
              _elem20 = EdgeData()
              _elem20.read(iprot)
              self.edge_data.append(_elem20)
          else: 
            while iprot.peekList():
              _elem21 = EdgeData()
              _elem21.read(iprot)
              self.edge_data.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexData')
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.I64, 1)
      oprot.writeI64(self.vertex_id)
      oprot.writeFieldEnd()
    if self.tag_data != None:
      oprot.writeFieldBegin('tag_data', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tag_data))
      for iter22 in self.tag_data:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_data != None:
      oprot.writeFieldBegin('edge_data', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_data))
      for iter23 in self.edge_data:
        iter23.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.tag_data is not None:
      value = pprint.pformat(self.tag_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_data=%s' % (value))
    if self.edge_data is not None:
      value = pprint.pformat(self.edge_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class VertexIndexData:
  """
  Attributes:
   - vertex_id
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.vertex_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.props = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexIndexData')
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.I64, 1)
      oprot.writeI64(self.vertex_id)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRING, 2)
      oprot.writeString(self.props)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ResponseCommon:
  """
  Attributes:
   - failed_codes
   - latency_in_us
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.failed_codes = []
          (_etype27, _size24) = iprot.readListBegin()
          if _size24 >= 0:
            for _i28 in six.moves.range(_size24):
              _elem29 = ResultCode()
              _elem29.read(iprot)
              self.failed_codes.append(_elem29)
          else: 
            while iprot.peekList():
              _elem30 = ResultCode()
              _elem30.read(iprot)
              self.failed_codes.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.latency_in_us = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.failed_codes == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'failed_codes' was not found in serialized data! Struct: ResponseCommon")

    if self.latency_in_us == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'latency_in_us' was not found in serialized data! Struct: ResponseCommon")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ResponseCommon')
    if self.failed_codes != None:
      oprot.writeFieldBegin('failed_codes', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.failed_codes))
      for iter31 in self.failed_codes:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I32, 2)
      oprot.writeI32(self.latency_in_us)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.failed_codes is not None:
      value = pprint.pformat(self.failed_codes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    failed_codes=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class QueryResponse:
  """
  Attributes:
   - result
   - vertex_schema
   - edge_schema
   - vertices
   - total_edges
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.vertex_schema = {}
          (_ktype33, _vtype34, _size32 ) = iprot.readMapBegin() 
          if _size32 >= 0:
            for _i36 in six.moves.range(_size32):
              _key37 = iprot.readI32()
              _val38 = nebula.common.ttypes.Schema()
              _val38.read(iprot)
              self.vertex_schema[_key37] = _val38
          else: 
            while iprot.peekMap():
              _key39 = iprot.readI32()
              _val40 = nebula.common.ttypes.Schema()
              _val40.read(iprot)
              self.vertex_schema[_key39] = _val40
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.edge_schema = {}
          (_ktype42, _vtype43, _size41 ) = iprot.readMapBegin() 
          if _size41 >= 0:
            for _i45 in six.moves.range(_size41):
              _key46 = iprot.readI32()
              _val47 = nebula.common.ttypes.Schema()
              _val47.read(iprot)
              self.edge_schema[_key46] = _val47
          else: 
            while iprot.peekMap():
              _key48 = iprot.readI32()
              _val49 = nebula.common.ttypes.Schema()
              _val49.read(iprot)
              self.edge_schema[_key48] = _val49
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.vertices = []
          (_etype53, _size50) = iprot.readListBegin()
          if _size50 >= 0:
            for _i54 in six.moves.range(_size50):
              _elem55 = VertexData()
              _elem55.read(iprot)
              self.vertices.append(_elem55)
          else: 
            while iprot.peekList():
              _elem56 = VertexData()
              _elem56.read(iprot)
              self.vertices.append(_elem56)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.total_edges = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: QueryResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('QueryResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertex_schema != None:
      oprot.writeFieldBegin('vertex_schema', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.vertex_schema))
      for kiter57,viter58 in self.vertex_schema.items():
        oprot.writeI32(kiter57)
        viter58.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edge_schema != None:
      oprot.writeFieldBegin('edge_schema', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.edge_schema))
      for kiter59,viter60 in self.edge_schema.items():
        oprot.writeI32(kiter59)
        viter60.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.vertices != None:
      oprot.writeFieldBegin('vertices', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.vertices))
      for iter61 in self.vertices:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.total_edges != None:
      oprot.writeFieldBegin('total_edges', TType.I32, 5)
      oprot.writeI32(self.total_edges)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertex_schema is not None:
      value = pprint.pformat(self.vertex_schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_schema=%s' % (value))
    if self.edge_schema is not None:
      value = pprint.pformat(self.edge_schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_schema=%s' % (value))
    if self.vertices is not None:
      value = pprint.pformat(self.vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertices=%s' % (value))
    if self.total_edges is not None:
      value = pprint.pformat(self.total_edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    total_edges=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ExecResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ExecResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgePropResponse:
  """
  Attributes:
   - result
   - schema
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = nebula.common.ttypes.Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: EdgePropResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgePropResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class QueryStatsResponse:
  """
  Attributes:
   - result
   - schema
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = nebula.common.ttypes.Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: QueryStatsResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('QueryStatsResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Tag:
  """
  Attributes:
   - tag_id
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.props = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Tag')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRING, 2)
      oprot.writeString(self.props)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Vertex:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype65, _size62) = iprot.readListBegin()
          if _size62 >= 0:
            for _i66 in six.moves.range(_size62):
              _elem67 = Tag()
              _elem67.read(iprot)
              self.tags.append(_elem67)
          else: 
            while iprot.peekList():
              _elem68 = Tag()
              _elem68.read(iprot)
              self.tags.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Vertex')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter69 in self.tags:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetNeighborsRequest:
  """
  Attributes:
   - space_id
   - parts
   - edge_types
   - filter
   - return_columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin() 
          if _size70 >= 0:
            for _i74 in six.moves.range(_size70):
              _key75 = iprot.readI32()
              _val76 = []
              (_etype80, _size77) = iprot.readListBegin()
              if _size77 >= 0:
                for _i81 in six.moves.range(_size77):
                  _elem82 = iprot.readI64()
                  _val76.append(_elem82)
              else: 
                while iprot.peekList():
                  _elem83 = iprot.readI64()
                  _val76.append(_elem83)
              iprot.readListEnd()
              self.parts[_key75] = _val76
          else: 
            while iprot.peekMap():
              _key84 = iprot.readI32()
              _val85 = []
              (_etype89, _size86) = iprot.readListBegin()
              if _size86 >= 0:
                for _i90 in six.moves.range(_size86):
                  _elem91 = iprot.readI64()
                  _val85.append(_elem91)
              else: 
                while iprot.peekList():
                  _elem92 = iprot.readI64()
                  _val85.append(_elem92)
              iprot.readListEnd()
              self.parts[_key84] = _val85
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edge_types = []
          (_etype96, _size93) = iprot.readListBegin()
          if _size93 >= 0:
            for _i97 in six.moves.range(_size93):
              _elem98 = iprot.readI32()
              self.edge_types.append(_elem98)
          else: 
            while iprot.peekList():
              _elem99 = iprot.readI32()
              self.edge_types.append(_elem99)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype103, _size100) = iprot.readListBegin()
          if _size100 >= 0:
            for _i104 in six.moves.range(_size100):
              _elem105 = PropDef()
              _elem105.read(iprot)
              self.return_columns.append(_elem105)
          else: 
            while iprot.peekList():
              _elem106 = PropDef()
              _elem106.read(iprot)
              self.return_columns.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter107,viter108 in self.parts.items():
        oprot.writeI32(kiter107)
        oprot.writeListBegin(TType.I64, len(viter108))
        for iter109 in viter108:
          oprot.writeI64(iter109)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edge_types != None:
      oprot.writeFieldBegin('edge_types', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.edge_types))
      for iter110 in self.edge_types:
        oprot.writeI32(iter110)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 4)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter111 in self.return_columns:
        iter111.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.edge_types is not None:
      value = pprint.pformat(self.edge_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_types=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class VertexPropRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype113, _vtype114, _size112 ) = iprot.readMapBegin() 
          if _size112 >= 0:
            for _i116 in six.moves.range(_size112):
              _key117 = iprot.readI32()
              _val118 = []
              (_etype122, _size119) = iprot.readListBegin()
              if _size119 >= 0:
                for _i123 in six.moves.range(_size119):
                  _elem124 = iprot.readI64()
                  _val118.append(_elem124)
              else: 
                while iprot.peekList():
                  _elem125 = iprot.readI64()
                  _val118.append(_elem125)
              iprot.readListEnd()
              self.parts[_key117] = _val118
          else: 
            while iprot.peekMap():
              _key126 = iprot.readI32()
              _val127 = []
              (_etype131, _size128) = iprot.readListBegin()
              if _size128 >= 0:
                for _i132 in six.moves.range(_size128):
                  _elem133 = iprot.readI64()
                  _val127.append(_elem133)
              else: 
                while iprot.peekList():
                  _elem134 = iprot.readI64()
                  _val127.append(_elem134)
              iprot.readListEnd()
              self.parts[_key126] = _val127
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype138, _size135) = iprot.readListBegin()
          if _size135 >= 0:
            for _i139 in six.moves.range(_size135):
              _elem140 = PropDef()
              _elem140.read(iprot)
              self.return_columns.append(_elem140)
          else: 
            while iprot.peekList():
              _elem141 = PropDef()
              _elem141.read(iprot)
              self.return_columns.append(_elem141)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexPropRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter142,viter143 in self.parts.items():
        oprot.writeI32(kiter142)
        oprot.writeListBegin(TType.I64, len(viter143))
        for iter144 in viter143:
          oprot.writeI64(iter144)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter145 in self.return_columns:
        iter145.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgePropRequest:
  """
  Attributes:
   - space_id
   - parts
   - edge_type
   - filter
   - return_columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype147, _vtype148, _size146 ) = iprot.readMapBegin() 
          if _size146 >= 0:
            for _i150 in six.moves.range(_size146):
              _key151 = iprot.readI32()
              _val152 = []
              (_etype156, _size153) = iprot.readListBegin()
              if _size153 >= 0:
                for _i157 in six.moves.range(_size153):
                  _elem158 = EdgeKey()
                  _elem158.read(iprot)
                  _val152.append(_elem158)
              else: 
                while iprot.peekList():
                  _elem159 = EdgeKey()
                  _elem159.read(iprot)
                  _val152.append(_elem159)
              iprot.readListEnd()
              self.parts[_key151] = _val152
          else: 
            while iprot.peekMap():
              _key160 = iprot.readI32()
              _val161 = []
              (_etype165, _size162) = iprot.readListBegin()
              if _size162 >= 0:
                for _i166 in six.moves.range(_size162):
                  _elem167 = EdgeKey()
                  _elem167.read(iprot)
                  _val161.append(_elem167)
              else: 
                while iprot.peekList():
                  _elem168 = EdgeKey()
                  _elem168.read(iprot)
                  _val161.append(_elem168)
              iprot.readListEnd()
              self.parts[_key160] = _val161
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype172, _size169) = iprot.readListBegin()
          if _size169 >= 0:
            for _i173 in six.moves.range(_size169):
              _elem174 = PropDef()
              _elem174.read(iprot)
              self.return_columns.append(_elem174)
          else: 
            while iprot.peekList():
              _elem175 = PropDef()
              _elem175.read(iprot)
              self.return_columns.append(_elem175)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgePropRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter176,viter177 in self.parts.items():
        oprot.writeI32(kiter176)
        oprot.writeListBegin(TType.STRUCT, len(viter177))
        for iter178 in viter177:
          iter178.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 3)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 4)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter179 in self.return_columns:
        iter179.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - overwritable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype181, _vtype182, _size180 ) = iprot.readMapBegin() 
          if _size180 >= 0:
            for _i184 in six.moves.range(_size180):
              _key185 = iprot.readI32()
              _val186 = []
              (_etype190, _size187) = iprot.readListBegin()
              if _size187 >= 0:
                for _i191 in six.moves.range(_size187):
                  _elem192 = Vertex()
                  _elem192.read(iprot)
                  _val186.append(_elem192)
              else: 
                while iprot.peekList():
                  _elem193 = Vertex()
                  _elem193.read(iprot)
                  _val186.append(_elem193)
              iprot.readListEnd()
              self.parts[_key185] = _val186
          else: 
            while iprot.peekMap():
              _key194 = iprot.readI32()
              _val195 = []
              (_etype199, _size196) = iprot.readListBegin()
              if _size196 >= 0:
                for _i200 in six.moves.range(_size196):
                  _elem201 = Vertex()
                  _elem201.read(iprot)
                  _val195.append(_elem201)
              else: 
                while iprot.peekList():
                  _elem202 = Vertex()
                  _elem202.read(iprot)
                  _val195.append(_elem202)
              iprot.readListEnd()
              self.parts[_key194] = _val195
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.overwritable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter203,viter204 in self.parts.items():
        oprot.writeI32(kiter203)
        oprot.writeListBegin(TType.STRUCT, len(viter204))
        for iter205 in viter204:
          iter205.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.overwritable != None:
      oprot.writeFieldBegin('overwritable', TType.BOOL, 3)
      oprot.writeBool(self.overwritable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.overwritable is not None:
      value = pprint.pformat(self.overwritable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    overwritable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - overwritable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype207, _vtype208, _size206 ) = iprot.readMapBegin() 
          if _size206 >= 0:
            for _i210 in six.moves.range(_size206):
              _key211 = iprot.readI32()
              _val212 = []
              (_etype216, _size213) = iprot.readListBegin()
              if _size213 >= 0:
                for _i217 in six.moves.range(_size213):
                  _elem218 = Edge()
                  _elem218.read(iprot)
                  _val212.append(_elem218)
              else: 
                while iprot.peekList():
                  _elem219 = Edge()
                  _elem219.read(iprot)
                  _val212.append(_elem219)
              iprot.readListEnd()
              self.parts[_key211] = _val212
          else: 
            while iprot.peekMap():
              _key220 = iprot.readI32()
              _val221 = []
              (_etype225, _size222) = iprot.readListBegin()
              if _size222 >= 0:
                for _i226 in six.moves.range(_size222):
                  _elem227 = Edge()
                  _elem227.read(iprot)
                  _val221.append(_elem227)
              else: 
                while iprot.peekList():
                  _elem228 = Edge()
                  _elem228.read(iprot)
                  _val221.append(_elem228)
              iprot.readListEnd()
              self.parts[_key220] = _val221
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.overwritable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter229,viter230 in self.parts.items():
        oprot.writeI32(kiter229)
        oprot.writeListBegin(TType.STRUCT, len(viter230))
        for iter231 in viter230:
          iter231.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.overwritable != None:
      oprot.writeFieldBegin('overwritable', TType.BOOL, 3)
      oprot.writeBool(self.overwritable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.overwritable is not None:
      value = pprint.pformat(self.overwritable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    overwritable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DeleteVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype233, _vtype234, _size232 ) = iprot.readMapBegin() 
          if _size232 >= 0:
            for _i236 in six.moves.range(_size232):
              _key237 = iprot.readI32()
              _val238 = []
              (_etype242, _size239) = iprot.readListBegin()
              if _size239 >= 0:
                for _i243 in six.moves.range(_size239):
                  _elem244 = iprot.readI64()
                  _val238.append(_elem244)
              else: 
                while iprot.peekList():
                  _elem245 = iprot.readI64()
                  _val238.append(_elem245)
              iprot.readListEnd()
              self.parts[_key237] = _val238
          else: 
            while iprot.peekMap():
              _key246 = iprot.readI32()
              _val247 = []
              (_etype251, _size248) = iprot.readListBegin()
              if _size248 >= 0:
                for _i252 in six.moves.range(_size248):
                  _elem253 = iprot.readI64()
                  _val247.append(_elem253)
              else: 
                while iprot.peekList():
                  _elem254 = iprot.readI64()
                  _val247.append(_elem254)
              iprot.readListEnd()
              self.parts[_key246] = _val247
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter255,viter256 in self.parts.items():
        oprot.writeI32(kiter255)
        oprot.writeListBegin(TType.I64, len(viter256))
        for iter257 in viter256:
          oprot.writeI64(iter257)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DeleteEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype259, _vtype260, _size258 ) = iprot.readMapBegin() 
          if _size258 >= 0:
            for _i262 in six.moves.range(_size258):
              _key263 = iprot.readI32()
              _val264 = []
              (_etype268, _size265) = iprot.readListBegin()
              if _size265 >= 0:
                for _i269 in six.moves.range(_size265):
                  _elem270 = EdgeKey()
                  _elem270.read(iprot)
                  _val264.append(_elem270)
              else: 
                while iprot.peekList():
                  _elem271 = EdgeKey()
                  _elem271.read(iprot)
                  _val264.append(_elem271)
              iprot.readListEnd()
              self.parts[_key263] = _val264
          else: 
            while iprot.peekMap():
              _key272 = iprot.readI32()
              _val273 = []
              (_etype277, _size274) = iprot.readListBegin()
              if _size274 >= 0:
                for _i278 in six.moves.range(_size274):
                  _elem279 = EdgeKey()
                  _elem279.read(iprot)
                  _val273.append(_elem279)
              else: 
                while iprot.peekList():
                  _elem280 = EdgeKey()
                  _elem280.read(iprot)
                  _val273.append(_elem280)
              iprot.readListEnd()
              self.parts[_key272] = _val273
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter281,viter282 in self.parts.items():
        oprot.writeI32(kiter281)
        oprot.writeListBegin(TType.STRUCT, len(viter282))
        for iter283 in viter282:
          iter283.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdminExecResp:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: AdminExecResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminExecResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddPartReq:
  """
  Attributes:
   - space_id
   - part_id
   - as_learner
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.as_learner = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.peers = []
          (_etype287, _size284) = iprot.readListBegin()
          if _size284 >= 0:
            for _i288 in six.moves.range(_size284):
              _elem289 = nebula.common.ttypes.HostAddr()
              _elem289.read(iprot)
              self.peers.append(_elem289)
          else: 
            while iprot.peekList():
              _elem290 = nebula.common.ttypes.HostAddr()
              _elem290.read(iprot)
              self.peers.append(_elem290)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddPartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.as_learner != None:
      oprot.writeFieldBegin('as_learner', TType.BOOL, 3)
      oprot.writeBool(self.as_learner)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter291 in self.peers:
        iter291.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.as_learner is not None:
      value = pprint.pformat(self.as_learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    as_learner=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemovePartReq:
  """
  Attributes:
   - space_id
   - part_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemovePartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MemberChangeReq:
  """
  Attributes:
   - space_id
   - part_id
   - peer
   - add
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.peer = nebula.common.ttypes.HostAddr()
          self.peer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.add = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MemberChangeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peer != None:
      oprot.writeFieldBegin('peer', TType.STRUCT, 3)
      self.peer.write(oprot)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BOOL, 4)
      oprot.writeBool(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peer is not None:
      value = pprint.pformat(self.peer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peer=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TransLeaderReq:
  """
  Attributes:
   - space_id
   - part_id
   - new_leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_leader = nebula.common.ttypes.HostAddr()
          self.new_leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TransLeaderReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.new_leader != None:
      oprot.writeFieldBegin('new_leader', TType.STRUCT, 3)
      self.new_leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.new_leader is not None:
      value = pprint.pformat(self.new_leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddLearnerReq:
  """
  Attributes:
   - space_id
   - part_id
   - learner
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.learner = nebula.common.ttypes.HostAddr()
          self.learner.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddLearnerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.learner != None:
      oprot.writeFieldBegin('learner', TType.STRUCT, 3)
      self.learner.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.learner is not None:
      value = pprint.pformat(self.learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    learner=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CatchUpDataReq:
  """
  Attributes:
   - space_id
   - part_id
   - target
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.target = nebula.common.ttypes.HostAddr()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CatchUpDataReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.target != None:
      oprot.writeFieldBegin('target', TType.STRUCT, 3)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.target is not None:
      value = pprint.pformat(self.target, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    target=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CheckPeersReq:
  """
  Attributes:
   - space_id
   - part_id
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype295, _size292) = iprot.readListBegin()
          if _size292 >= 0:
            for _i296 in six.moves.range(_size292):
              _elem297 = nebula.common.ttypes.HostAddr()
              _elem297.read(iprot)
              self.peers.append(_elem297)
          else: 
            while iprot.peekList():
              _elem298 = nebula.common.ttypes.HostAddr()
              _elem298.read(iprot)
              self.peers.append(_elem298)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckPeersReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter299 in self.peers:
        iter299.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetLeaderReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetLeaderResp:
  """
  Attributes:
   - result
   - leader_parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype301, _vtype302, _size300 ) = iprot.readMapBegin() 
          if _size300 >= 0:
            for _i304 in six.moves.range(_size300):
              _key305 = iprot.readI32()
              _val306 = []
              (_etype310, _size307) = iprot.readListBegin()
              if _size307 >= 0:
                for _i311 in six.moves.range(_size307):
                  _elem312 = iprot.readI32()
                  _val306.append(_elem312)
              else: 
                while iprot.peekList():
                  _elem313 = iprot.readI32()
                  _val306.append(_elem313)
              iprot.readListEnd()
              self.leader_parts[_key305] = _val306
          else: 
            while iprot.peekMap():
              _key314 = iprot.readI32()
              _val315 = []
              (_etype319, _size316) = iprot.readListBegin()
              if _size316 >= 0:
                for _i320 in six.moves.range(_size316):
                  _elem321 = iprot.readI32()
                  _val315.append(_elem321)
              else: 
                while iprot.peekList():
                  _elem322 = iprot.readI32()
                  _val315.append(_elem322)
              iprot.readListEnd()
              self.leader_parts[_key314] = _val315
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetLeaderResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_parts))
      for kiter323,viter324 in self.leader_parts.items():
        oprot.writeI32(kiter323)
        oprot.writeListBegin(TType.I32, len(viter324))
        for iter325 in viter324:
          oprot.writeI32(iter325)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateResponse:
  """
  Attributes:
   - result
   - schema
   - data
   - upsert
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = nebula.common.ttypes.Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.upsert = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: UpdateResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    if self.upsert != None and self.upsert != self.thrift_spec[4][4]:
      oprot.writeFieldBegin('upsert', TType.BOOL, 4)
      oprot.writeBool(self.upsert)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    if self.upsert is not None:
      value = pprint.pformat(self.upsert, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    upsert=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateItem:
  """
  Attributes:
   - name
   - prop
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.name == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'name' was not found in serialized data! Struct: UpdateItem")

    if self.prop == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'prop' was not found in serialized data! Struct: UpdateItem")

    if self.value == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'value' was not found in serialized data! Struct: UpdateItem")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateItem')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 2)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateVertexRequest:
  """
  Attributes:
   - space_id
   - vertex_id
   - part_id
   - filter
   - update_items
   - return_columns
   - insertable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.vertex_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.update_items = []
          (_etype329, _size326) = iprot.readListBegin()
          if _size326 >= 0:
            for _i330 in six.moves.range(_size326):
              _elem331 = UpdateItem()
              _elem331.read(iprot)
              self.update_items.append(_elem331)
          else: 
            while iprot.peekList():
              _elem332 = UpdateItem()
              _elem332.read(iprot)
              self.update_items.append(_elem332)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype336, _size333) = iprot.readListBegin()
          if _size333 >= 0:
            for _i337 in six.moves.range(_size333):
              _elem338 = iprot.readString()
              self.return_columns.append(_elem338)
          else: 
            while iprot.peekList():
              _elem339 = iprot.readString()
              self.return_columns.append(_elem339)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.I64, 2)
      oprot.writeI64(self.vertex_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 3)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 4)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.update_items != None:
      oprot.writeFieldBegin('update_items', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.update_items))
      for iter340 in self.update_items:
        iter340.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter341 in self.return_columns:
        oprot.writeString(iter341)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None:
      oprot.writeFieldBegin('insertable', TType.BOOL, 7)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.update_items is not None:
      value = pprint.pformat(self.update_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    update_items=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateEdgeRequest:
  """
  Attributes:
   - space_id
   - edge_key
   - part_id
   - filter
   - update_items
   - return_columns
   - insertable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.edge_key = EdgeKey()
          self.edge_key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.update_items = []
          (_etype345, _size342) = iprot.readListBegin()
          if _size342 >= 0:
            for _i346 in six.moves.range(_size342):
              _elem347 = UpdateItem()
              _elem347.read(iprot)
              self.update_items.append(_elem347)
          else: 
            while iprot.peekList():
              _elem348 = UpdateItem()
              _elem348.read(iprot)
              self.update_items.append(_elem348)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype352, _size349) = iprot.readListBegin()
          if _size349 >= 0:
            for _i353 in six.moves.range(_size349):
              _elem354 = iprot.readString()
              self.return_columns.append(_elem354)
          else: 
            while iprot.peekList():
              _elem355 = iprot.readString()
              self.return_columns.append(_elem355)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_key != None:
      oprot.writeFieldBegin('edge_key', TType.STRUCT, 2)
      self.edge_key.write(oprot)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 3)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 4)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.update_items != None:
      oprot.writeFieldBegin('update_items', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.update_items))
      for iter356 in self.update_items:
        iter356.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter357 in self.return_columns:
        oprot.writeString(iter357)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None:
      oprot.writeFieldBegin('insertable', TType.BOOL, 7)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_key is not None:
      value = pprint.pformat(self.edge_key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_key=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.update_items is not None:
      value = pprint.pformat(self.update_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    update_items=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanEdgeRequest:
  """
  Attributes:
   - space_id
   - part_id
   - cursor
   - return_columns
   - all_columns
   - limit
   - start_time
   - end_time
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.return_columns = {}
          (_ktype359, _vtype360, _size358 ) = iprot.readMapBegin() 
          if _size358 >= 0:
            for _i362 in six.moves.range(_size358):
              _key363 = iprot.readI32()
              _val364 = []
              (_etype368, _size365) = iprot.readListBegin()
              if _size365 >= 0:
                for _i369 in six.moves.range(_size365):
                  _elem370 = PropDef()
                  _elem370.read(iprot)
                  _val364.append(_elem370)
              else: 
                while iprot.peekList():
                  _elem371 = PropDef()
                  _elem371.read(iprot)
                  _val364.append(_elem371)
              iprot.readListEnd()
              self.return_columns[_key363] = _val364
          else: 
            while iprot.peekMap():
              _key372 = iprot.readI32()
              _val373 = []
              (_etype377, _size374) = iprot.readListBegin()
              if _size374 >= 0:
                for _i378 in six.moves.range(_size374):
                  _elem379 = PropDef()
                  _elem379.read(iprot)
                  _val373.append(_elem379)
              else: 
                while iprot.peekList():
                  _elem380 = PropDef()
                  _elem380.read(iprot)
                  _val373.append(_elem380)
              iprot.readListEnd()
              self.return_columns[_key372] = _val373
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.all_columns = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.cursor != None:
      oprot.writeFieldBegin('cursor', TType.STRING, 3)
      oprot.writeString(self.cursor)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.return_columns))
      for kiter381,viter382 in self.return_columns.items():
        oprot.writeI32(kiter381)
        oprot.writeListBegin(TType.STRUCT, len(viter382))
        for iter383 in viter382:
          iter383.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.all_columns != None:
      oprot.writeFieldBegin('all_columns', TType.BOOL, 5)
      oprot.writeBool(self.all_columns)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I32, 6)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 7)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 8)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.cursor is not None:
      value = pprint.pformat(self.cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cursor=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.all_columns is not None:
      value = pprint.pformat(self.all_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    all_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanEdgeResponse:
  """
  Attributes:
   - result
   - edge_schema
   - edge_data
   - has_next
   - next_cursor
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.edge_schema = {}
          (_ktype385, _vtype386, _size384 ) = iprot.readMapBegin() 
          if _size384 >= 0:
            for _i388 in six.moves.range(_size384):
              _key389 = iprot.readI32()
              _val390 = nebula.common.ttypes.Schema()
              _val390.read(iprot)
              self.edge_schema[_key389] = _val390
          else: 
            while iprot.peekMap():
              _key391 = iprot.readI32()
              _val392 = nebula.common.ttypes.Schema()
              _val392.read(iprot)
              self.edge_schema[_key391] = _val392
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edge_data = []
          (_etype396, _size393) = iprot.readListBegin()
          if _size393 >= 0:
            for _i397 in six.moves.range(_size393):
              _elem398 = ScanEdge()
              _elem398.read(iprot)
              self.edge_data.append(_elem398)
          else: 
            while iprot.peekList():
              _elem399 = ScanEdge()
              _elem399.read(iprot)
              self.edge_data.append(_elem399)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.has_next = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.next_cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ScanEdgeResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdgeResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.edge_schema != None:
      oprot.writeFieldBegin('edge_schema', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.edge_schema))
      for kiter400,viter401 in self.edge_schema.items():
        oprot.writeI32(kiter400)
        viter401.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edge_data != None:
      oprot.writeFieldBegin('edge_data', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_data))
      for iter402 in self.edge_data:
        iter402.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.has_next != None:
      oprot.writeFieldBegin('has_next', TType.BOOL, 4)
      oprot.writeBool(self.has_next)
      oprot.writeFieldEnd()
    if self.next_cursor != None:
      oprot.writeFieldBegin('next_cursor', TType.STRING, 5)
      oprot.writeString(self.next_cursor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.edge_schema is not None:
      value = pprint.pformat(self.edge_schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_schema=%s' % (value))
    if self.edge_data is not None:
      value = pprint.pformat(self.edge_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_data=%s' % (value))
    if self.has_next is not None:
      value = pprint.pformat(self.has_next, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    has_next=%s' % (value))
    if self.next_cursor is not None:
      value = pprint.pformat(self.next_cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    next_cursor=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanEdge:
  """
  Attributes:
   - src
   - type
   - dst
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.src = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.dst = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdge')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.I64, 1)
      oprot.writeI64(self.src)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.I64, 3)
      oprot.writeI64(self.dst)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 4)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanVertexRequest:
  """
  Attributes:
   - space_id
   - part_id
   - cursor
   - return_columns
   - all_columns
   - limit
   - start_time
   - end_time
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.return_columns = {}
          (_ktype404, _vtype405, _size403 ) = iprot.readMapBegin() 
          if _size403 >= 0:
            for _i407 in six.moves.range(_size403):
              _key408 = iprot.readI32()
              _val409 = []
              (_etype413, _size410) = iprot.readListBegin()
              if _size410 >= 0:
                for _i414 in six.moves.range(_size410):
                  _elem415 = PropDef()
                  _elem415.read(iprot)
                  _val409.append(_elem415)
              else: 
                while iprot.peekList():
                  _elem416 = PropDef()
                  _elem416.read(iprot)
                  _val409.append(_elem416)
              iprot.readListEnd()
              self.return_columns[_key408] = _val409
          else: 
            while iprot.peekMap():
              _key417 = iprot.readI32()
              _val418 = []
              (_etype422, _size419) = iprot.readListBegin()
              if _size419 >= 0:
                for _i423 in six.moves.range(_size419):
                  _elem424 = PropDef()
                  _elem424.read(iprot)
                  _val418.append(_elem424)
              else: 
                while iprot.peekList():
                  _elem425 = PropDef()
                  _elem425.read(iprot)
                  _val418.append(_elem425)
              iprot.readListEnd()
              self.return_columns[_key417] = _val418
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.all_columns = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.cursor != None:
      oprot.writeFieldBegin('cursor', TType.STRING, 3)
      oprot.writeString(self.cursor)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.return_columns))
      for kiter426,viter427 in self.return_columns.items():
        oprot.writeI32(kiter426)
        oprot.writeListBegin(TType.STRUCT, len(viter427))
        for iter428 in viter427:
          iter428.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.all_columns != None:
      oprot.writeFieldBegin('all_columns', TType.BOOL, 5)
      oprot.writeBool(self.all_columns)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I32, 6)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 7)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 8)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.cursor is not None:
      value = pprint.pformat(self.cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cursor=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.all_columns is not None:
      value = pprint.pformat(self.all_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    all_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanVertex:
  """
  Attributes:
   - vertexId
   - tagId
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.vertexId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.tagId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertex')
    if self.vertexId != None:
      oprot.writeFieldBegin('vertexId', TType.I64, 1)
      oprot.writeI64(self.vertexId)
      oprot.writeFieldEnd()
    if self.tagId != None:
      oprot.writeFieldBegin('tagId', TType.I32, 2)
      oprot.writeI32(self.tagId)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.vertexId is not None:
      value = pprint.pformat(self.vertexId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertexId=%s' % (value))
    if self.tagId is not None:
      value = pprint.pformat(self.tagId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tagId=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanVertexResponse:
  """
  Attributes:
   - result
   - vertex_schema
   - vertex_data
   - has_next
   - next_cursor
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.vertex_schema = {}
          (_ktype430, _vtype431, _size429 ) = iprot.readMapBegin() 
          if _size429 >= 0:
            for _i433 in six.moves.range(_size429):
              _key434 = iprot.readI32()
              _val435 = nebula.common.ttypes.Schema()
              _val435.read(iprot)
              self.vertex_schema[_key434] = _val435
          else: 
            while iprot.peekMap():
              _key436 = iprot.readI32()
              _val437 = nebula.common.ttypes.Schema()
              _val437.read(iprot)
              self.vertex_schema[_key436] = _val437
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.vertex_data = []
          (_etype441, _size438) = iprot.readListBegin()
          if _size438 >= 0:
            for _i442 in six.moves.range(_size438):
              _elem443 = ScanVertex()
              _elem443.read(iprot)
              self.vertex_data.append(_elem443)
          else: 
            while iprot.peekList():
              _elem444 = ScanVertex()
              _elem444.read(iprot)
              self.vertex_data.append(_elem444)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.has_next = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.next_cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ScanVertexResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertexResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertex_schema != None:
      oprot.writeFieldBegin('vertex_schema', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.vertex_schema))
      for kiter445,viter446 in self.vertex_schema.items():
        oprot.writeI32(kiter445)
        viter446.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.vertex_data != None:
      oprot.writeFieldBegin('vertex_data', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_data))
      for iter447 in self.vertex_data:
        iter447.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.has_next != None:
      oprot.writeFieldBegin('has_next', TType.BOOL, 4)
      oprot.writeBool(self.has_next)
      oprot.writeFieldEnd()
    if self.next_cursor != None:
      oprot.writeFieldBegin('next_cursor', TType.STRING, 5)
      oprot.writeString(self.next_cursor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertex_schema is not None:
      value = pprint.pformat(self.vertex_schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_schema=%s' % (value))
    if self.vertex_data is not None:
      value = pprint.pformat(self.vertex_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_data=%s' % (value))
    if self.has_next is not None:
      value = pprint.pformat(self.has_next, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    has_next=%s' % (value))
    if self.next_cursor is not None:
      value = pprint.pformat(self.next_cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    next_cursor=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PutRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype449, _vtype450, _size448 ) = iprot.readMapBegin() 
          if _size448 >= 0:
            for _i452 in six.moves.range(_size448):
              _key453 = iprot.readI32()
              _val454 = []
              (_etype458, _size455) = iprot.readListBegin()
              if _size455 >= 0:
                for _i459 in six.moves.range(_size455):
                  _elem460 = nebula.common.ttypes.Pair()
                  _elem460.read(iprot)
                  _val454.append(_elem460)
              else: 
                while iprot.peekList():
                  _elem461 = nebula.common.ttypes.Pair()
                  _elem461.read(iprot)
                  _val454.append(_elem461)
              iprot.readListEnd()
              self.parts[_key453] = _val454
          else: 
            while iprot.peekMap():
              _key462 = iprot.readI32()
              _val463 = []
              (_etype467, _size464) = iprot.readListBegin()
              if _size464 >= 0:
                for _i468 in six.moves.range(_size464):
                  _elem469 = nebula.common.ttypes.Pair()
                  _elem469.read(iprot)
                  _val463.append(_elem469)
              else: 
                while iprot.peekList():
                  _elem470 = nebula.common.ttypes.Pair()
                  _elem470.read(iprot)
                  _val463.append(_elem470)
              iprot.readListEnd()
              self.parts[_key462] = _val463
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PutRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter471,viter472 in self.parts.items():
        oprot.writeI32(kiter471)
        oprot.writeListBegin(TType.STRUCT, len(viter472))
        for iter473 in viter472:
          iter473.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemoveRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype475, _vtype476, _size474 ) = iprot.readMapBegin() 
          if _size474 >= 0:
            for _i478 in six.moves.range(_size474):
              _key479 = iprot.readI32()
              _val480 = []
              (_etype484, _size481) = iprot.readListBegin()
              if _size481 >= 0:
                for _i485 in six.moves.range(_size481):
                  _elem486 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val480.append(_elem486)
              else: 
                while iprot.peekList():
                  _elem487 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val480.append(_elem487)
              iprot.readListEnd()
              self.parts[_key479] = _val480
          else: 
            while iprot.peekMap():
              _key488 = iprot.readI32()
              _val489 = []
              (_etype493, _size490) = iprot.readListBegin()
              if _size490 >= 0:
                for _i494 in six.moves.range(_size490):
                  _elem495 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val489.append(_elem495)
              else: 
                while iprot.peekList():
                  _elem496 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val489.append(_elem496)
              iprot.readListEnd()
              self.parts[_key488] = _val489
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter497,viter498 in self.parts.items():
        oprot.writeI32(kiter497)
        oprot.writeListBegin(TType.STRING, len(viter498))
        for iter499 in viter498:
          oprot.writeString(iter499.encode('utf-8')) if UTF8STRINGS and not isinstance(iter499, bytes) else oprot.writeString(iter499)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemoveRangeRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype501, _vtype502, _size500 ) = iprot.readMapBegin() 
          if _size500 >= 0:
            for _i504 in six.moves.range(_size500):
              _key505 = iprot.readI32()
              _val506 = []
              (_etype510, _size507) = iprot.readListBegin()
              if _size507 >= 0:
                for _i511 in six.moves.range(_size507):
                  _elem512 = nebula.common.ttypes.Pair()
                  _elem512.read(iprot)
                  _val506.append(_elem512)
              else: 
                while iprot.peekList():
                  _elem513 = nebula.common.ttypes.Pair()
                  _elem513.read(iprot)
                  _val506.append(_elem513)
              iprot.readListEnd()
              self.parts[_key505] = _val506
          else: 
            while iprot.peekMap():
              _key514 = iprot.readI32()
              _val515 = []
              (_etype519, _size516) = iprot.readListBegin()
              if _size516 >= 0:
                for _i520 in six.moves.range(_size516):
                  _elem521 = nebula.common.ttypes.Pair()
                  _elem521.read(iprot)
                  _val515.append(_elem521)
              else: 
                while iprot.peekList():
                  _elem522 = nebula.common.ttypes.Pair()
                  _elem522.read(iprot)
                  _val515.append(_elem522)
              iprot.readListEnd()
              self.parts[_key514] = _val515
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveRangeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter523,viter524 in self.parts.items():
        oprot.writeI32(kiter523)
        oprot.writeListBegin(TType.STRUCT, len(viter524))
        for iter525 in viter524:
          iter525.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_partly
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype527, _vtype528, _size526 ) = iprot.readMapBegin() 
          if _size526 >= 0:
            for _i530 in six.moves.range(_size526):
              _key531 = iprot.readI32()
              _val532 = []
              (_etype536, _size533) = iprot.readListBegin()
              if _size533 >= 0:
                for _i537 in six.moves.range(_size533):
                  _elem538 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val532.append(_elem538)
              else: 
                while iprot.peekList():
                  _elem539 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val532.append(_elem539)
              iprot.readListEnd()
              self.parts[_key531] = _val532
          else: 
            while iprot.peekMap():
              _key540 = iprot.readI32()
              _val541 = []
              (_etype545, _size542) = iprot.readListBegin()
              if _size542 >= 0:
                for _i546 in six.moves.range(_size542):
                  _elem547 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val541.append(_elem547)
              else: 
                while iprot.peekList():
                  _elem548 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val541.append(_elem548)
              iprot.readListEnd()
              self.parts[_key540] = _val541
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.return_partly = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter549,viter550 in self.parts.items():
        oprot.writeI32(kiter549)
        oprot.writeListBegin(TType.STRING, len(viter550))
        for iter551 in viter550:
          oprot.writeString(iter551.encode('utf-8')) if UTF8STRINGS and not isinstance(iter551, bytes) else oprot.writeString(iter551)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_partly != None:
      oprot.writeFieldBegin('return_partly', TType.BOOL, 3)
      oprot.writeBool(self.return_partly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_partly is not None:
      value = pprint.pformat(self.return_partly, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_partly=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PrefixRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype553, _vtype554, _size552 ) = iprot.readMapBegin() 
          if _size552 >= 0:
            for _i556 in six.moves.range(_size552):
              _key557 = iprot.readI32()
              _val558 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.parts[_key557] = _val558
          else: 
            while iprot.peekMap():
              _key559 = iprot.readI32()
              _val560 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.parts[_key559] = _val560
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PrefixRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.parts))
      for kiter561,viter562 in self.parts.items():
        oprot.writeI32(kiter561)
        oprot.writeString(viter562.encode('utf-8')) if UTF8STRINGS and not isinstance(viter562, bytes) else oprot.writeString(viter562)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype564, _vtype565, _size563 ) = iprot.readMapBegin() 
          if _size563 >= 0:
            for _i567 in six.moves.range(_size563):
              _key568 = iprot.readI32()
              _val569 = nebula.common.ttypes.Pair()
              _val569.read(iprot)
              self.parts[_key568] = _val569
          else: 
            while iprot.peekMap():
              _key570 = iprot.readI32()
              _val571 = nebula.common.ttypes.Pair()
              _val571.read(iprot)
              self.parts[_key570] = _val571
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.parts))
      for kiter572,viter573 in self.parts.items():
        oprot.writeI32(kiter572)
        viter573.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GeneralResponse:
  """
  Attributes:
   - result
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.values = {}
          (_ktype575, _vtype576, _size574 ) = iprot.readMapBegin() 
          if _size574 >= 0:
            for _i578 in six.moves.range(_size574):
              _key579 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val580 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.values[_key579] = _val580
          else: 
            while iprot.peekMap():
              _key581 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val582 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.values[_key581] = _val582
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GeneralResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GeneralResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.values != None:
      oprot.writeFieldBegin('values', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.values))
      for kiter583,viter584 in self.values.items():
        oprot.writeString(kiter583.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter583, bytes) else oprot.writeString(kiter583)
        oprot.writeString(viter584.encode('utf-8')) if UTF8STRINGS and not isinstance(viter584, bytes) else oprot.writeString(viter584)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUUIDReq:
  """
  Attributes:
   - space_id
   - part_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUUIDResp:
  """
  Attributes:
   - result
   - id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetUUIDResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BlockingSignRequest:
  """
  Attributes:
   - space_id
   - sign
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sign = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.sign == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'sign' was not found in serialized data! Struct: BlockingSignRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BlockingSignRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.sign != None:
      oprot.writeFieldBegin('sign', TType.I32, 2)
      oprot.writeI32(self.sign)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.sign is not None:
      value = pprint.pformat(self.sign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sign=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateCPRequest:
  """
  Attributes:
   - space_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropCPRequest:
  """
  Attributes:
   - space_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropCPRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RebuildIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - index_id
   - is_offline
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype588, _size585) = iprot.readListBegin()
          if _size585 >= 0:
            for _i589 in six.moves.range(_size585):
              _elem590 = iprot.readI32()
              self.parts.append(_elem590)
          else: 
            while iprot.peekList():
              _elem591 = iprot.readI32()
              self.parts.append(_elem591)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_offline = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter592 in self.parts:
        oprot.writeI32(iter592)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 3)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.is_offline != None:
      oprot.writeFieldBegin('is_offline', TType.BOOL, 4)
      oprot.writeBool(self.is_offline)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.is_offline is not None:
      value = pprint.pformat(self.is_offline, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_offline=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookUpIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - index_id
   - filter
   - return_columns
   - is_edge
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype596, _size593) = iprot.readListBegin()
          if _size593 >= 0:
            for _i597 in six.moves.range(_size593):
              _elem598 = iprot.readI32()
              self.parts.append(_elem598)
          else: 
            while iprot.peekList():
              _elem599 = iprot.readI32()
              self.parts.append(_elem599)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype603, _size600) = iprot.readListBegin()
          if _size600 >= 0:
            for _i604 in six.moves.range(_size600):
              _elem605 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.return_columns.append(_elem605)
          else: 
            while iprot.peekList():
              _elem606 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.return_columns.append(_elem606)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_edge = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookUpIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter607 in self.parts:
        oprot.writeI32(iter607)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 3)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 4)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 5)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter608 in self.return_columns:
        oprot.writeString(iter608.encode('utf-8')) if UTF8STRINGS and not isinstance(iter608, bytes) else oprot.writeString(iter608)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_edge != None:
      oprot.writeFieldBegin('is_edge', TType.BOOL, 6)
      oprot.writeBool(self.is_edge)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.is_edge is not None:
      value = pprint.pformat(self.is_edge, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_edge=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookUpIndexResp:
  """
  Attributes:
   - result
   - schema
   - vertices
   - edges
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = nebula.common.ttypes.Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.vertices = []
          (_etype612, _size609) = iprot.readListBegin()
          if _size609 >= 0:
            for _i613 in six.moves.range(_size609):
              _elem614 = VertexIndexData()
              _elem614.read(iprot)
              self.vertices.append(_elem614)
          else: 
            while iprot.peekList():
              _elem615 = VertexIndexData()
              _elem615.read(iprot)
              self.vertices.append(_elem615)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.edges = []
          (_etype619, _size616) = iprot.readListBegin()
          if _size616 >= 0:
            for _i620 in six.moves.range(_size616):
              _elem621 = Edge()
              _elem621.read(iprot)
              self.edges.append(_elem621)
          else: 
            while iprot.peekList():
              _elem622 = Edge()
              _elem622.read(iprot)
              self.edges.append(_elem622)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: LookUpIndexResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookUpIndexResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.vertices != None:
      oprot.writeFieldBegin('vertices', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.vertices))
      for iter623 in self.vertices:
        iter623.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edges != None:
      oprot.writeFieldBegin('edges', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.edges))
      for iter624 in self.edges:
        iter624.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.vertices is not None:
      value = pprint.pformat(self.vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertices=%s' % (value))
    if self.edges is not None:
      value = pprint.pformat(self.edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edges=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(EntryId)
EntryId.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
)

EntryId.thrift_struct_annotations = {
}
EntryId.thrift_field_annotations = {
}

def EntryId__init__(self, tag_id=None, edge_type=None,):
  self.field = 0
  self.value = None
  if tag_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = tag_id
  if edge_type is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = edge_type

EntryId.__init__ = EntryId__init__

all_structs.append(PropDef)
PropDef.thrift_spec = (
  None, # 0
  (1, TType.I32, 'owner', PropOwner, None, 2, ), # 1
  (2, TType.STRUCT, 'id', [EntryId, EntryId.thrift_spec, True], None, 2, ), # 2
  (3, TType.STRING, 'name', True, None, 2, ), # 3
  (4, TType.I32, 'stat', StatType, None, 2, ), # 4
)

PropDef.thrift_struct_annotations = {
}
PropDef.thrift_field_annotations = {
}

def PropDef__init__(self, owner=None, id=None, name=None, stat=None,):
  self.owner = owner
  self.id = id
  self.name = name
  self.stat = stat

PropDef.__init__ = PropDef__init__

def PropDef__setstate__(self, state):
  state.setdefault('owner', None)
  state.setdefault('id', None)
  state.setdefault('name', None)
  state.setdefault('stat', None)
  self.__dict__ = state

PropDef.__getstate__ = lambda self: self.__dict__.copy()
PropDef.__setstate__ = PropDef__setstate__

all_structs.append(ResultCode)
ResultCode.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 0, ), # 1
  (2, TType.I32, 'part_id', None, None, 0, ), # 2
  (3, TType.STRUCT, 'leader', [nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 3
)

ResultCode.thrift_struct_annotations = {
}
ResultCode.thrift_field_annotations = {
}

def ResultCode__init__(self, code=None, part_id=None, leader=None,):
  self.code = code
  self.part_id = part_id
  self.leader = leader

ResultCode.__init__ = ResultCode__init__

def ResultCode__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

ResultCode.__getstate__ = lambda self: self.__dict__.copy()
ResultCode.__setstate__ = ResultCode__setstate__

all_structs.append(EdgeKey)
EdgeKey.thrift_spec = (
  None, # 0
  (1, TType.I64, 'src', None, None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
  (3, TType.I64, 'ranking', None, None, 2, ), # 3
  (4, TType.I64, 'dst', None, None, 2, ), # 4
)

EdgeKey.thrift_struct_annotations = {
}
EdgeKey.thrift_field_annotations = {
}

def EdgeKey__init__(self, src=None, edge_type=None, ranking=None, dst=None,):
  self.src = src
  self.edge_type = edge_type
  self.ranking = ranking
  self.dst = dst

EdgeKey.__init__ = EdgeKey__init__

def EdgeKey__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('edge_type', None)
  state.setdefault('ranking', None)
  state.setdefault('dst', None)
  self.__dict__ = state

EdgeKey.__getstate__ = lambda self: self.__dict__.copy()
EdgeKey.__setstate__ = EdgeKey__setstate__

all_structs.append(Edge)
Edge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'props', False, None, 2, ), # 2
)

Edge.thrift_struct_annotations = {
}
Edge.thrift_field_annotations = {
}

def Edge__init__(self, key=None, props=None,):
  self.key = key
  self.props = props

Edge.__init__ = Edge__init__

def Edge__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('props', None)
  self.__dict__ = state

Edge.__getstate__ = lambda self: self.__dict__.copy()
Edge.__setstate__ = Edge__setstate__

all_structs.append(IdAndProp)
IdAndProp.thrift_spec = (
  None, # 0
  (1, TType.I64, 'dst', None, None, 2, ), # 1
  (2, TType.STRING, 'props', False, None, 2, ), # 2
)

IdAndProp.thrift_struct_annotations = {
}
IdAndProp.thrift_field_annotations = {
}

def IdAndProp__init__(self, dst=None, props=None,):
  self.dst = dst
  self.props = props

IdAndProp.__init__ = IdAndProp__init__

def IdAndProp__setstate__(self, state):
  state.setdefault('dst', None)
  state.setdefault('props', None)
  self.__dict__ = state

IdAndProp.__getstate__ = lambda self: self.__dict__.copy()
IdAndProp.__setstate__ = IdAndProp__setstate__

all_structs.append(EdgeData)
EdgeData.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', None, None, 2, ), # 1
  None, # 2
  (3, TType.LIST, 'edges', (TType.STRUCT,[IdAndProp, IdAndProp.thrift_spec, False]), None, 2, ), # 3
)

EdgeData.thrift_struct_annotations = {
}
EdgeData.thrift_field_annotations = {
}

def EdgeData__init__(self, type=None, edges=None,):
  self.type = type
  self.edges = edges

EdgeData.__init__ = EdgeData__init__

def EdgeData__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('edges', None)
  self.__dict__ = state

EdgeData.__getstate__ = lambda self: self.__dict__.copy()
EdgeData.__setstate__ = EdgeData__setstate__

all_structs.append(TagData)
TagData.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.STRING, 'data', False, None, 2, ), # 2
)

TagData.thrift_struct_annotations = {
}
TagData.thrift_field_annotations = {
}

def TagData__init__(self, tag_id=None, data=None,):
  self.tag_id = tag_id
  self.data = data

TagData.__init__ = TagData__init__

def TagData__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('data', None)
  self.__dict__ = state

TagData.__getstate__ = lambda self: self.__dict__.copy()
TagData.__setstate__ = TagData__setstate__

all_structs.append(VertexData)
VertexData.thrift_spec = (
  None, # 0
  (1, TType.I64, 'vertex_id', None, None, 2, ), # 1
  (2, TType.LIST, 'tag_data', (TType.STRUCT,[TagData, TagData.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'edge_data', (TType.STRUCT,[EdgeData, EdgeData.thrift_spec, False]), None, 2, ), # 3
)

VertexData.thrift_struct_annotations = {
}
VertexData.thrift_field_annotations = {
}

def VertexData__init__(self, vertex_id=None, tag_data=None, edge_data=None,):
  self.vertex_id = vertex_id
  self.tag_data = tag_data
  self.edge_data = edge_data

VertexData.__init__ = VertexData__init__

def VertexData__setstate__(self, state):
  state.setdefault('vertex_id', None)
  state.setdefault('tag_data', None)
  state.setdefault('edge_data', None)
  self.__dict__ = state

VertexData.__getstate__ = lambda self: self.__dict__.copy()
VertexData.__setstate__ = VertexData__setstate__

all_structs.append(VertexIndexData)
VertexIndexData.thrift_spec = (
  None, # 0
  (1, TType.I64, 'vertex_id', None, None, 2, ), # 1
  (2, TType.STRING, 'props', False, None, 2, ), # 2
)

VertexIndexData.thrift_struct_annotations = {
}
VertexIndexData.thrift_field_annotations = {
}

def VertexIndexData__init__(self, vertex_id=None, props=None,):
  self.vertex_id = vertex_id
  self.props = props

VertexIndexData.__init__ = VertexIndexData__init__

def VertexIndexData__setstate__(self, state):
  state.setdefault('vertex_id', None)
  state.setdefault('props', None)
  self.__dict__ = state

VertexIndexData.__getstate__ = lambda self: self.__dict__.copy()
VertexIndexData.__setstate__ = VertexIndexData__setstate__

all_structs.append(ResponseCommon)
ResponseCommon.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'failed_codes', (TType.STRUCT,[ResultCode, ResultCode.thrift_spec, False]), None, 0, ), # 1
  (2, TType.I32, 'latency_in_us', None, None, 0, ), # 2
)

ResponseCommon.thrift_struct_annotations = {
}
ResponseCommon.thrift_field_annotations = {
}

def ResponseCommon__init__(self, failed_codes=None, latency_in_us=None,):
  self.failed_codes = failed_codes
  self.latency_in_us = latency_in_us

ResponseCommon.__init__ = ResponseCommon__init__

def ResponseCommon__setstate__(self, state):
  state.setdefault('failed_codes', None)
  state.setdefault('latency_in_us', None)
  self.__dict__ = state

ResponseCommon.__getstate__ = lambda self: self.__dict__.copy()
ResponseCommon.__setstate__ = ResponseCommon__setstate__

all_structs.append(QueryResponse)
QueryResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'vertex_schema', (TType.I32,None,TType.STRUCT,[nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False]), None, 1, ), # 2
  (3, TType.MAP, 'edge_schema', (TType.I32,None,TType.STRUCT,[nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False]), None, 1, ), # 3
  (4, TType.LIST, 'vertices', (TType.STRUCT,[VertexData, VertexData.thrift_spec, False]), None, 1, ), # 4
  (5, TType.I32, 'total_edges', None, None, 1, ), # 5
)

QueryResponse.thrift_struct_annotations = {
}
QueryResponse.thrift_field_annotations = {
}

def QueryResponse__init__(self, result=None, vertex_schema=None, edge_schema=None, vertices=None, total_edges=None,):
  self.result = result
  self.vertex_schema = vertex_schema
  self.edge_schema = edge_schema
  self.vertices = vertices
  self.total_edges = total_edges

QueryResponse.__init__ = QueryResponse__init__

def QueryResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertex_schema', None)
  state.setdefault('edge_schema', None)
  state.setdefault('vertices', None)
  state.setdefault('total_edges', None)
  self.__dict__ = state

QueryResponse.__getstate__ = lambda self: self.__dict__.copy()
QueryResponse.__setstate__ = QueryResponse__setstate__

all_structs.append(ExecResponse)
ExecResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

ExecResponse.thrift_struct_annotations = {
}
ExecResponse.thrift_field_annotations = {
}

def ExecResponse__init__(self, result=None,):
  self.result = result

ExecResponse.__init__ = ExecResponse__init__

def ExecResponse__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

ExecResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecResponse.__setstate__ = ExecResponse__setstate__

all_structs.append(EdgePropResponse)
EdgePropResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'schema', [nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False], None, 1, ), # 2
  (3, TType.STRING, 'data', False, None, 1, ), # 3
)

EdgePropResponse.thrift_struct_annotations = {
}
EdgePropResponse.thrift_field_annotations = {
}

def EdgePropResponse__init__(self, result=None, schema=None, data=None,):
  self.result = result
  self.schema = schema
  self.data = data

EdgePropResponse.__init__ = EdgePropResponse__init__

def EdgePropResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('schema', None)
  state.setdefault('data', None)
  self.__dict__ = state

EdgePropResponse.__getstate__ = lambda self: self.__dict__.copy()
EdgePropResponse.__setstate__ = EdgePropResponse__setstate__

all_structs.append(QueryStatsResponse)
QueryStatsResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'schema', [nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False], None, 1, ), # 2
  (3, TType.STRING, 'data', False, None, 1, ), # 3
)

QueryStatsResponse.thrift_struct_annotations = {
}
QueryStatsResponse.thrift_field_annotations = {
}

def QueryStatsResponse__init__(self, result=None, schema=None, data=None,):
  self.result = result
  self.schema = schema
  self.data = data

QueryStatsResponse.__init__ = QueryStatsResponse__init__

def QueryStatsResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('schema', None)
  state.setdefault('data', None)
  self.__dict__ = state

QueryStatsResponse.__getstate__ = lambda self: self.__dict__.copy()
QueryStatsResponse.__setstate__ = QueryStatsResponse__setstate__

all_structs.append(Tag)
Tag.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.STRING, 'props', False, None, 2, ), # 2
)

Tag.thrift_struct_annotations = {
}
Tag.thrift_field_annotations = {
}

def Tag__init__(self, tag_id=None, props=None,):
  self.tag_id = tag_id
  self.props = props

Tag.__init__ = Tag__init__

def Tag__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('props', None)
  self.__dict__ = state

Tag.__getstate__ = lambda self: self.__dict__.copy()
Tag.__setstate__ = Tag__setstate__

all_structs.append(Vertex)
Vertex.thrift_spec = (
  None, # 0
  (1, TType.I64, 'id', None, None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[Tag, Tag.thrift_spec, False]), None, 2, ), # 2
)

Vertex.thrift_struct_annotations = {
}
Vertex.thrift_field_annotations = {
}

def Vertex__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

Vertex.__init__ = Vertex__init__

def Vertex__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

Vertex.__getstate__ = lambda self: self.__dict__.copy()
Vertex.__setstate__ = Vertex__setstate__

all_structs.append(GetNeighborsRequest)
GetNeighborsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.I64,None)), None, 2, ), # 2
  (3, TType.LIST, 'edge_types', (TType.I32,None), None, 2, ), # 3
  (4, TType.STRING, 'filter', False, None, 2, ), # 4
  (5, TType.LIST, 'return_columns', (TType.STRUCT,[PropDef, PropDef.thrift_spec, False]), None, 2, ), # 5
)

GetNeighborsRequest.thrift_struct_annotations = {
}
GetNeighborsRequest.thrift_field_annotations = {
}

def GetNeighborsRequest__init__(self, space_id=None, parts=None, edge_types=None, filter=None, return_columns=None,):
  self.space_id = space_id
  self.parts = parts
  self.edge_types = edge_types
  self.filter = filter
  self.return_columns = return_columns

GetNeighborsRequest.__init__ = GetNeighborsRequest__init__

def GetNeighborsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('edge_types', None)
  state.setdefault('filter', None)
  state.setdefault('return_columns', None)
  self.__dict__ = state

GetNeighborsRequest.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsRequest.__setstate__ = GetNeighborsRequest__setstate__

all_structs.append(VertexPropRequest)
VertexPropRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.I64,None)), None, 2, ), # 2
  (3, TType.LIST, 'return_columns', (TType.STRUCT,[PropDef, PropDef.thrift_spec, False]), None, 2, ), # 3
)

VertexPropRequest.thrift_struct_annotations = {
}
VertexPropRequest.thrift_field_annotations = {
}

def VertexPropRequest__init__(self, space_id=None, parts=None, return_columns=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_columns = return_columns

VertexPropRequest.__init__ = VertexPropRequest__init__

def VertexPropRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_columns', None)
  self.__dict__ = state

VertexPropRequest.__getstate__ = lambda self: self.__dict__.copy()
VertexPropRequest.__setstate__ = VertexPropRequest__setstate__

all_structs.append(EdgePropRequest)
EdgePropRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
  (3, TType.I32, 'edge_type', None, None, 2, ), # 3
  (4, TType.STRING, 'filter', False, None, 2, ), # 4
  (5, TType.LIST, 'return_columns', (TType.STRUCT,[PropDef, PropDef.thrift_spec, False]), None, 2, ), # 5
)

EdgePropRequest.thrift_struct_annotations = {
}
EdgePropRequest.thrift_field_annotations = {
}

def EdgePropRequest__init__(self, space_id=None, parts=None, edge_type=None, filter=None, return_columns=None,):
  self.space_id = space_id
  self.parts = parts
  self.edge_type = edge_type
  self.filter = filter
  self.return_columns = return_columns

EdgePropRequest.__init__ = EdgePropRequest__init__

def EdgePropRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('edge_type', None)
  state.setdefault('filter', None)
  state.setdefault('return_columns', None)
  self.__dict__ = state

EdgePropRequest.__getstate__ = lambda self: self.__dict__.copy()
EdgePropRequest.__setstate__ = EdgePropRequest__setstate__

all_structs.append(AddVerticesRequest)
AddVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[Vertex, Vertex.thrift_spec, False])), None, 2, ), # 2
  (3, TType.BOOL, 'overwritable', None, None, 2, ), # 3
)

AddVerticesRequest.thrift_struct_annotations = {
}
AddVerticesRequest.thrift_field_annotations = {
}

def AddVerticesRequest__init__(self, space_id=None, parts=None, overwritable=None,):
  self.space_id = space_id
  self.parts = parts
  self.overwritable = overwritable

AddVerticesRequest.__init__ = AddVerticesRequest__init__

def AddVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('overwritable', None)
  self.__dict__ = state

AddVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddVerticesRequest.__setstate__ = AddVerticesRequest__setstate__

all_structs.append(AddEdgesRequest)
AddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[Edge, Edge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.BOOL, 'overwritable', None, None, 2, ), # 3
)

AddEdgesRequest.thrift_struct_annotations = {
}
AddEdgesRequest.thrift_field_annotations = {
}

def AddEdgesRequest__init__(self, space_id=None, parts=None, overwritable=None,):
  self.space_id = space_id
  self.parts = parts
  self.overwritable = overwritable

AddEdgesRequest.__init__ = AddEdgesRequest__init__

def AddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('overwritable', None)
  self.__dict__ = state

AddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddEdgesRequest.__setstate__ = AddEdgesRequest__setstate__

all_structs.append(DeleteVerticesRequest)
DeleteVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.I64,None)), None, 2, ), # 2
)

DeleteVerticesRequest.thrift_struct_annotations = {
}
DeleteVerticesRequest.thrift_field_annotations = {
}

def DeleteVerticesRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

DeleteVerticesRequest.__init__ = DeleteVerticesRequest__init__

def DeleteVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

DeleteVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteVerticesRequest.__setstate__ = DeleteVerticesRequest__setstate__

all_structs.append(DeleteEdgesRequest)
DeleteEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
)

DeleteEdgesRequest.thrift_struct_annotations = {
}
DeleteEdgesRequest.thrift_field_annotations = {
}

def DeleteEdgesRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

DeleteEdgesRequest.__init__ = DeleteEdgesRequest__init__

def DeleteEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

DeleteEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteEdgesRequest.__setstate__ = DeleteEdgesRequest__setstate__

all_structs.append(AdminExecResp)
AdminExecResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

AdminExecResp.thrift_struct_annotations = {
}
AdminExecResp.thrift_field_annotations = {
}

def AdminExecResp__init__(self, result=None,):
  self.result = result

AdminExecResp.__init__ = AdminExecResp__init__

def AdminExecResp__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

AdminExecResp.__getstate__ = lambda self: self.__dict__.copy()
AdminExecResp.__setstate__ = AdminExecResp__setstate__

all_structs.append(AddPartReq)
AddPartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.BOOL, 'as_learner', None, None, 2, ), # 3
  (4, TType.LIST, 'peers', (TType.STRUCT,[nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 4
)

AddPartReq.thrift_struct_annotations = {
}
AddPartReq.thrift_field_annotations = {
}

def AddPartReq__init__(self, space_id=None, part_id=None, as_learner=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.as_learner = as_learner
  self.peers = peers

AddPartReq.__init__ = AddPartReq__init__

def AddPartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('as_learner', None)
  state.setdefault('peers', None)
  self.__dict__ = state

AddPartReq.__getstate__ = lambda self: self.__dict__.copy()
AddPartReq.__setstate__ = AddPartReq__setstate__

all_structs.append(RemovePartReq)
RemovePartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
)

RemovePartReq.thrift_struct_annotations = {
}
RemovePartReq.thrift_field_annotations = {
}

def RemovePartReq__init__(self, space_id=None, part_id=None,):
  self.space_id = space_id
  self.part_id = part_id

RemovePartReq.__init__ = RemovePartReq__init__

def RemovePartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  self.__dict__ = state

RemovePartReq.__getstate__ = lambda self: self.__dict__.copy()
RemovePartReq.__setstate__ = RemovePartReq__setstate__

all_structs.append(MemberChangeReq)
MemberChangeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'peer', [nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'add', None, None, 2, ), # 4
)

MemberChangeReq.thrift_struct_annotations = {
}
MemberChangeReq.thrift_field_annotations = {
}

def MemberChangeReq__init__(self, space_id=None, part_id=None, peer=None, add=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peer = peer
  self.add = add

MemberChangeReq.__init__ = MemberChangeReq__init__

def MemberChangeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peer', None)
  state.setdefault('add', None)
  self.__dict__ = state

MemberChangeReq.__getstate__ = lambda self: self.__dict__.copy()
MemberChangeReq.__setstate__ = MemberChangeReq__setstate__

all_structs.append(TransLeaderReq)
TransLeaderReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'new_leader', [nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

TransLeaderReq.thrift_struct_annotations = {
}
TransLeaderReq.thrift_field_annotations = {
}

def TransLeaderReq__init__(self, space_id=None, part_id=None, new_leader=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.new_leader = new_leader

TransLeaderReq.__init__ = TransLeaderReq__init__

def TransLeaderReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('new_leader', None)
  self.__dict__ = state

TransLeaderReq.__getstate__ = lambda self: self.__dict__.copy()
TransLeaderReq.__setstate__ = TransLeaderReq__setstate__

all_structs.append(AddLearnerReq)
AddLearnerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'learner', [nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

AddLearnerReq.thrift_struct_annotations = {
}
AddLearnerReq.thrift_field_annotations = {
}

def AddLearnerReq__init__(self, space_id=None, part_id=None, learner=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.learner = learner

AddLearnerReq.__init__ = AddLearnerReq__init__

def AddLearnerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('learner', None)
  self.__dict__ = state

AddLearnerReq.__getstate__ = lambda self: self.__dict__.copy()
AddLearnerReq.__setstate__ = AddLearnerReq__setstate__

all_structs.append(CatchUpDataReq)
CatchUpDataReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'target', [nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

CatchUpDataReq.thrift_struct_annotations = {
}
CatchUpDataReq.thrift_field_annotations = {
}

def CatchUpDataReq__init__(self, space_id=None, part_id=None, target=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.target = target

CatchUpDataReq.__init__ = CatchUpDataReq__init__

def CatchUpDataReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('target', None)
  self.__dict__ = state

CatchUpDataReq.__getstate__ = lambda self: self.__dict__.copy()
CatchUpDataReq.__setstate__ = CatchUpDataReq__setstate__

all_structs.append(CheckPeersReq)
CheckPeersReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula.common.ttypes.HostAddr, nebula.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

CheckPeersReq.thrift_struct_annotations = {
}
CheckPeersReq.thrift_field_annotations = {
}

def CheckPeersReq__init__(self, space_id=None, part_id=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peers = peers

CheckPeersReq.__init__ = CheckPeersReq__init__

def CheckPeersReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peers', None)
  self.__dict__ = state

CheckPeersReq.__getstate__ = lambda self: self.__dict__.copy()
CheckPeersReq.__setstate__ = CheckPeersReq__setstate__

all_structs.append(GetLeaderReq)
GetLeaderReq.thrift_spec = (
)

GetLeaderReq.thrift_struct_annotations = {
}
GetLeaderReq.thrift_field_annotations = {
}

all_structs.append(GetLeaderResp)
GetLeaderResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'leader_parts', (TType.I32,None,TType.LIST,(TType.I32,None)), None, 2, ), # 2
)

GetLeaderResp.thrift_struct_annotations = {
}
GetLeaderResp.thrift_field_annotations = {
}

def GetLeaderResp__init__(self, result=None, leader_parts=None,):
  self.result = result
  self.leader_parts = leader_parts

GetLeaderResp.__init__ = GetLeaderResp__init__

def GetLeaderResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('leader_parts', None)
  self.__dict__ = state

GetLeaderResp.__getstate__ = lambda self: self.__dict__.copy()
GetLeaderResp.__setstate__ = GetLeaderResp__setstate__

all_structs.append(UpdateResponse)
UpdateResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'schema', [nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False], None, 1, ), # 2
  (3, TType.STRING, 'data', False, None, 1, ), # 3
  (4, TType.BOOL, 'upsert', None, False, 1, ), # 4
)

UpdateResponse.thrift_struct_annotations = {
}
UpdateResponse.thrift_field_annotations = {
}

def UpdateResponse__init__(self, result=None, schema=None, data=None, upsert=UpdateResponse.thrift_spec[4][4],):
  self.result = result
  self.schema = schema
  self.data = data
  self.upsert = upsert

UpdateResponse.__init__ = UpdateResponse__init__

def UpdateResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('schema', None)
  state.setdefault('data', None)
  state.setdefault('upsert', False)
  self.__dict__ = state

UpdateResponse.__getstate__ = lambda self: self.__dict__.copy()
UpdateResponse.__setstate__ = UpdateResponse__setstate__

all_structs.append(UpdateItem)
UpdateItem.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRING, 'prop', False, None, 0, ), # 2
  (3, TType.STRING, 'value', False, None, 0, ), # 3
)

UpdateItem.thrift_struct_annotations = {
}
UpdateItem.thrift_field_annotations = {
}

def UpdateItem__init__(self, name=None, prop=None, value=None,):
  self.name = name
  self.prop = prop
  self.value = value

UpdateItem.__init__ = UpdateItem__init__

def UpdateItem__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('prop', None)
  state.setdefault('value', None)
  self.__dict__ = state

UpdateItem.__getstate__ = lambda self: self.__dict__.copy()
UpdateItem.__setstate__ = UpdateItem__setstate__

all_structs.append(UpdateVertexRequest)
UpdateVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I64, 'vertex_id', None, None, 2, ), # 2
  (3, TType.I32, 'part_id', None, None, 2, ), # 3
  (4, TType.STRING, 'filter', False, None, 2, ), # 4
  (5, TType.LIST, 'update_items', (TType.STRUCT,[UpdateItem, UpdateItem.thrift_spec, False]), None, 2, ), # 5
  (6, TType.LIST, 'return_columns', (TType.STRING,False), None, 2, ), # 6
  (7, TType.BOOL, 'insertable', None, None, 2, ), # 7
)

UpdateVertexRequest.thrift_struct_annotations = {
}
UpdateVertexRequest.thrift_field_annotations = {
}

def UpdateVertexRequest__init__(self, space_id=None, vertex_id=None, part_id=None, filter=None, update_items=None, return_columns=None, insertable=None,):
  self.space_id = space_id
  self.vertex_id = vertex_id
  self.part_id = part_id
  self.filter = filter
  self.update_items = update_items
  self.return_columns = return_columns
  self.insertable = insertable

UpdateVertexRequest.__init__ = UpdateVertexRequest__init__

def UpdateVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('vertex_id', None)
  state.setdefault('part_id', None)
  state.setdefault('filter', None)
  state.setdefault('update_items', None)
  state.setdefault('return_columns', None)
  state.setdefault('insertable', None)
  self.__dict__ = state

UpdateVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateVertexRequest.__setstate__ = UpdateVertexRequest__setstate__

all_structs.append(UpdateEdgeRequest)
UpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRUCT, 'edge_key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'part_id', None, None, 2, ), # 3
  (4, TType.STRING, 'filter', False, None, 2, ), # 4
  (5, TType.LIST, 'update_items', (TType.STRUCT,[UpdateItem, UpdateItem.thrift_spec, False]), None, 2, ), # 5
  (6, TType.LIST, 'return_columns', (TType.STRING,False), None, 2, ), # 6
  (7, TType.BOOL, 'insertable', None, None, 2, ), # 7
)

UpdateEdgeRequest.thrift_struct_annotations = {
}
UpdateEdgeRequest.thrift_field_annotations = {
}

def UpdateEdgeRequest__init__(self, space_id=None, edge_key=None, part_id=None, filter=None, update_items=None, return_columns=None, insertable=None,):
  self.space_id = space_id
  self.edge_key = edge_key
  self.part_id = part_id
  self.filter = filter
  self.update_items = update_items
  self.return_columns = return_columns
  self.insertable = insertable

UpdateEdgeRequest.__init__ = UpdateEdgeRequest__init__

def UpdateEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_key', None)
  state.setdefault('part_id', None)
  state.setdefault('filter', None)
  state.setdefault('update_items', None)
  state.setdefault('return_columns', None)
  state.setdefault('insertable', None)
  self.__dict__ = state

UpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateEdgeRequest.__setstate__ = UpdateEdgeRequest__setstate__

all_structs.append(ScanEdgeRequest)
ScanEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'cursor', False, None, 1, ), # 3
  (4, TType.MAP, 'return_columns', (TType.I32,None,TType.LIST,(TType.STRUCT,[PropDef, PropDef.thrift_spec, False])), None, 2, ), # 4
  (5, TType.BOOL, 'all_columns', None, None, 2, ), # 5
  (6, TType.I32, 'limit', None, None, 2, ), # 6
  (7, TType.I64, 'start_time', None, None, 2, ), # 7
  (8, TType.I64, 'end_time', None, None, 2, ), # 8
)

ScanEdgeRequest.thrift_struct_annotations = {
}
ScanEdgeRequest.thrift_field_annotations = {
}

def ScanEdgeRequest__init__(self, space_id=None, part_id=None, cursor=None, return_columns=None, all_columns=None, limit=None, start_time=None, end_time=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.cursor = cursor
  self.return_columns = return_columns
  self.all_columns = all_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time

ScanEdgeRequest.__init__ = ScanEdgeRequest__init__

def ScanEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('cursor', None)
  state.setdefault('return_columns', None)
  state.setdefault('all_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  self.__dict__ = state

ScanEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanEdgeRequest.__setstate__ = ScanEdgeRequest__setstate__

all_structs.append(ScanEdgeResponse)
ScanEdgeResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'edge_schema', (TType.I32,None,TType.STRUCT,[nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'edge_data', (TType.STRUCT,[ScanEdge, ScanEdge.thrift_spec, False]), None, 2, ), # 3
  (4, TType.BOOL, 'has_next', None, None, 2, ), # 4
  (5, TType.STRING, 'next_cursor', False, None, 2, ), # 5
)

ScanEdgeResponse.thrift_struct_annotations = {
}
ScanEdgeResponse.thrift_field_annotations = {
}

def ScanEdgeResponse__init__(self, result=None, edge_schema=None, edge_data=None, has_next=None, next_cursor=None,):
  self.result = result
  self.edge_schema = edge_schema
  self.edge_data = edge_data
  self.has_next = has_next
  self.next_cursor = next_cursor

ScanEdgeResponse.__init__ = ScanEdgeResponse__init__

def ScanEdgeResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('edge_schema', None)
  state.setdefault('edge_data', None)
  state.setdefault('has_next', None)
  state.setdefault('next_cursor', None)
  self.__dict__ = state

ScanEdgeResponse.__getstate__ = lambda self: self.__dict__.copy()
ScanEdgeResponse.__setstate__ = ScanEdgeResponse__setstate__

all_structs.append(ScanEdge)
ScanEdge.thrift_spec = (
  None, # 0
  (1, TType.I64, 'src', None, None, 2, ), # 1
  (2, TType.I32, 'type', None, None, 2, ), # 2
  (3, TType.I64, 'dst', None, None, 2, ), # 3
  (4, TType.STRING, 'value', False, None, 2, ), # 4
)

ScanEdge.thrift_struct_annotations = {
}
ScanEdge.thrift_field_annotations = {
}

def ScanEdge__init__(self, src=None, type=None, dst=None, value=None,):
  self.src = src
  self.type = type
  self.dst = dst
  self.value = value

ScanEdge.__init__ = ScanEdge__init__

def ScanEdge__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('type', None)
  state.setdefault('dst', None)
  state.setdefault('value', None)
  self.__dict__ = state

ScanEdge.__getstate__ = lambda self: self.__dict__.copy()
ScanEdge.__setstate__ = ScanEdge__setstate__

all_structs.append(ScanVertexRequest)
ScanVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'cursor', False, None, 1, ), # 3
  (4, TType.MAP, 'return_columns', (TType.I32,None,TType.LIST,(TType.STRUCT,[PropDef, PropDef.thrift_spec, False])), None, 2, ), # 4
  (5, TType.BOOL, 'all_columns', None, None, 2, ), # 5
  (6, TType.I32, 'limit', None, None, 2, ), # 6
  (7, TType.I64, 'start_time', None, None, 2, ), # 7
  (8, TType.I64, 'end_time', None, None, 2, ), # 8
)

ScanVertexRequest.thrift_struct_annotations = {
}
ScanVertexRequest.thrift_field_annotations = {
}

def ScanVertexRequest__init__(self, space_id=None, part_id=None, cursor=None, return_columns=None, all_columns=None, limit=None, start_time=None, end_time=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.cursor = cursor
  self.return_columns = return_columns
  self.all_columns = all_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time

ScanVertexRequest.__init__ = ScanVertexRequest__init__

def ScanVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('cursor', None)
  state.setdefault('return_columns', None)
  state.setdefault('all_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  self.__dict__ = state

ScanVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanVertexRequest.__setstate__ = ScanVertexRequest__setstate__

all_structs.append(ScanVertex)
ScanVertex.thrift_spec = (
  None, # 0
  (1, TType.I64, 'vertexId', None, None, 2, ), # 1
  (2, TType.I32, 'tagId', None, None, 2, ), # 2
  (3, TType.STRING, 'value', False, None, 2, ), # 3
)

ScanVertex.thrift_struct_annotations = {
}
ScanVertex.thrift_field_annotations = {
}

def ScanVertex__init__(self, vertexId=None, tagId=None, value=None,):
  self.vertexId = vertexId
  self.tagId = tagId
  self.value = value

ScanVertex.__init__ = ScanVertex__init__

def ScanVertex__setstate__(self, state):
  state.setdefault('vertexId', None)
  state.setdefault('tagId', None)
  state.setdefault('value', None)
  self.__dict__ = state

ScanVertex.__getstate__ = lambda self: self.__dict__.copy()
ScanVertex.__setstate__ = ScanVertex__setstate__

all_structs.append(ScanVertexResponse)
ScanVertexResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'vertex_schema', (TType.I32,None,TType.STRUCT,[nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'vertex_data', (TType.STRUCT,[ScanVertex, ScanVertex.thrift_spec, False]), None, 2, ), # 3
  (4, TType.BOOL, 'has_next', None, None, 2, ), # 4
  (5, TType.STRING, 'next_cursor', False, None, 2, ), # 5
)

ScanVertexResponse.thrift_struct_annotations = {
}
ScanVertexResponse.thrift_field_annotations = {
}

def ScanVertexResponse__init__(self, result=None, vertex_schema=None, vertex_data=None, has_next=None, next_cursor=None,):
  self.result = result
  self.vertex_schema = vertex_schema
  self.vertex_data = vertex_data
  self.has_next = has_next
  self.next_cursor = next_cursor

ScanVertexResponse.__init__ = ScanVertexResponse__init__

def ScanVertexResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertex_schema', None)
  state.setdefault('vertex_data', None)
  state.setdefault('has_next', None)
  state.setdefault('next_cursor', None)
  self.__dict__ = state

ScanVertexResponse.__getstate__ = lambda self: self.__dict__.copy()
ScanVertexResponse.__setstate__ = ScanVertexResponse__setstate__

all_structs.append(PutRequest)
PutRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula.common.ttypes.Pair, nebula.common.ttypes.Pair.thrift_spec, False])), None, 2, ), # 2
)

PutRequest.thrift_struct_annotations = {
}
PutRequest.thrift_field_annotations = {
}

def PutRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

PutRequest.__init__ = PutRequest__init__

def PutRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

PutRequest.__getstate__ = lambda self: self.__dict__.copy()
PutRequest.__setstate__ = PutRequest__setstate__

all_structs.append(RemoveRequest)
RemoveRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,True)), None, 2, ), # 2
)

RemoveRequest.thrift_struct_annotations = {
}
RemoveRequest.thrift_field_annotations = {
}

def RemoveRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

RemoveRequest.__init__ = RemoveRequest__init__

def RemoveRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

RemoveRequest.__getstate__ = lambda self: self.__dict__.copy()
RemoveRequest.__setstate__ = RemoveRequest__setstate__

all_structs.append(RemoveRangeRequest)
RemoveRangeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula.common.ttypes.Pair, nebula.common.ttypes.Pair.thrift_spec, False])), None, 2, ), # 2
)

RemoveRangeRequest.thrift_struct_annotations = {
}
RemoveRangeRequest.thrift_field_annotations = {
}

def RemoveRangeRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

RemoveRangeRequest.__init__ = RemoveRangeRequest__init__

def RemoveRangeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

RemoveRangeRequest.__getstate__ = lambda self: self.__dict__.copy()
RemoveRangeRequest.__setstate__ = RemoveRangeRequest__setstate__

all_structs.append(GetRequest)
GetRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,True)), None, 2, ), # 2
  (3, TType.BOOL, 'return_partly', None, None, 2, ), # 3
)

GetRequest.thrift_struct_annotations = {
}
GetRequest.thrift_field_annotations = {
}

def GetRequest__init__(self, space_id=None, parts=None, return_partly=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_partly = return_partly

GetRequest.__init__ = GetRequest__init__

def GetRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_partly', None)
  self.__dict__ = state

GetRequest.__getstate__ = lambda self: self.__dict__.copy()
GetRequest.__setstate__ = GetRequest__setstate__

all_structs.append(PrefixRequest)
PrefixRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRING,True), None, 2, ), # 2
)

PrefixRequest.thrift_struct_annotations = {
}
PrefixRequest.thrift_field_annotations = {
}

def PrefixRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

PrefixRequest.__init__ = PrefixRequest__init__

def PrefixRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

PrefixRequest.__getstate__ = lambda self: self.__dict__.copy()
PrefixRequest.__setstate__ = PrefixRequest__setstate__

all_structs.append(ScanRequest)
ScanRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRUCT,[nebula.common.ttypes.Pair, nebula.common.ttypes.Pair.thrift_spec, False]), None, 2, ), # 2
)

ScanRequest.thrift_struct_annotations = {
}
ScanRequest.thrift_field_annotations = {
}

def ScanRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

ScanRequest.__init__ = ScanRequest__init__

def ScanRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

ScanRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanRequest.__setstate__ = ScanRequest__setstate__

all_structs.append(GeneralResponse)
GeneralResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'values', (TType.STRING,True,TType.STRING,True), None, 2, ), # 2
)

GeneralResponse.thrift_struct_annotations = {
}
GeneralResponse.thrift_field_annotations = {
}

def GeneralResponse__init__(self, result=None, values=None,):
  self.result = result
  self.values = values

GeneralResponse.__init__ = GeneralResponse__init__

def GeneralResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('values', None)
  self.__dict__ = state

GeneralResponse.__getstate__ = lambda self: self.__dict__.copy()
GeneralResponse.__setstate__ = GeneralResponse__setstate__

all_structs.append(GetUUIDReq)
GetUUIDReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'name', True, None, 2, ), # 3
)

GetUUIDReq.thrift_struct_annotations = {
}
GetUUIDReq.thrift_field_annotations = {
}

def GetUUIDReq__init__(self, space_id=None, part_id=None, name=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.name = name

GetUUIDReq.__init__ = GetUUIDReq__init__

def GetUUIDReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

GetUUIDReq.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDReq.__setstate__ = GetUUIDReq__setstate__

all_structs.append(GetUUIDResp)
GetUUIDResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.I64, 'id', None, None, 2, ), # 2
)

GetUUIDResp.thrift_struct_annotations = {
}
GetUUIDResp.thrift_field_annotations = {
}

def GetUUIDResp__init__(self, result=None, id=None,):
  self.result = result
  self.id = id

GetUUIDResp.__init__ = GetUUIDResp__init__

def GetUUIDResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('id', None)
  self.__dict__ = state

GetUUIDResp.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDResp.__setstate__ = GetUUIDResp__setstate__

all_structs.append(BlockingSignRequest)
BlockingSignRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'sign', EngineSignType, None, 0, ), # 2
)

BlockingSignRequest.thrift_struct_annotations = {
}
BlockingSignRequest.thrift_field_annotations = {
}

def BlockingSignRequest__init__(self, space_id=None, sign=None,):
  self.space_id = space_id
  self.sign = sign

BlockingSignRequest.__init__ = BlockingSignRequest__init__

def BlockingSignRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('sign', None)
  self.__dict__ = state

BlockingSignRequest.__getstate__ = lambda self: self.__dict__.copy()
BlockingSignRequest.__setstate__ = BlockingSignRequest__setstate__

all_structs.append(CreateCPRequest)
CreateCPRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'name', True, None, 2, ), # 2
)

CreateCPRequest.thrift_struct_annotations = {
}
CreateCPRequest.thrift_field_annotations = {
}

def CreateCPRequest__init__(self, space_id=None, name=None,):
  self.space_id = space_id
  self.name = name

CreateCPRequest.__init__ = CreateCPRequest__init__

def CreateCPRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

CreateCPRequest.__getstate__ = lambda self: self.__dict__.copy()
CreateCPRequest.__setstate__ = CreateCPRequest__setstate__

all_structs.append(DropCPRequest)
DropCPRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'name', True, None, 2, ), # 2
)

DropCPRequest.thrift_struct_annotations = {
}
DropCPRequest.thrift_field_annotations = {
}

def DropCPRequest__init__(self, space_id=None, name=None,):
  self.space_id = space_id
  self.name = name

DropCPRequest.__init__ = DropCPRequest__init__

def DropCPRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

DropCPRequest.__getstate__ = lambda self: self.__dict__.copy()
DropCPRequest.__setstate__ = DropCPRequest__setstate__

all_structs.append(RebuildIndexRequest)
RebuildIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 2, ), # 2
  (3, TType.I32, 'index_id', None, None, 2, ), # 3
  (4, TType.BOOL, 'is_offline', None, None, 2, ), # 4
)

RebuildIndexRequest.thrift_struct_annotations = {
}
RebuildIndexRequest.thrift_field_annotations = {
}

def RebuildIndexRequest__init__(self, space_id=None, parts=None, index_id=None, is_offline=None,):
  self.space_id = space_id
  self.parts = parts
  self.index_id = index_id
  self.is_offline = is_offline

RebuildIndexRequest.__init__ = RebuildIndexRequest__init__

def RebuildIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('index_id', None)
  state.setdefault('is_offline', None)
  self.__dict__ = state

RebuildIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexRequest.__setstate__ = RebuildIndexRequest__setstate__

all_structs.append(LookUpIndexRequest)
LookUpIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 2, ), # 2
  (3, TType.I32, 'index_id', None, None, 2, ), # 3
  (4, TType.STRING, 'filter', False, None, 2, ), # 4
  (5, TType.LIST, 'return_columns', (TType.STRING,True), None, 2, ), # 5
  (6, TType.BOOL, 'is_edge', None, None, 2, ), # 6
)

LookUpIndexRequest.thrift_struct_annotations = {
}
LookUpIndexRequest.thrift_field_annotations = {
}

def LookUpIndexRequest__init__(self, space_id=None, parts=None, index_id=None, filter=None, return_columns=None, is_edge=None,):
  self.space_id = space_id
  self.parts = parts
  self.index_id = index_id
  self.filter = filter
  self.return_columns = return_columns
  self.is_edge = is_edge

LookUpIndexRequest.__init__ = LookUpIndexRequest__init__

def LookUpIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('index_id', None)
  state.setdefault('filter', None)
  state.setdefault('return_columns', None)
  state.setdefault('is_edge', None)
  self.__dict__ = state

LookUpIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
LookUpIndexRequest.__setstate__ = LookUpIndexRequest__setstate__

all_structs.append(LookUpIndexResp)
LookUpIndexResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'schema', [nebula.common.ttypes.Schema, nebula.common.ttypes.Schema.thrift_spec, False], None, 1, ), # 2
  (3, TType.LIST, 'vertices', (TType.STRUCT,[VertexIndexData, VertexIndexData.thrift_spec, False]), None, 1, ), # 3
  (4, TType.LIST, 'edges', (TType.STRUCT,[Edge, Edge.thrift_spec, False]), None, 1, ), # 4
)

LookUpIndexResp.thrift_struct_annotations = {
}
LookUpIndexResp.thrift_field_annotations = {
}

def LookUpIndexResp__init__(self, result=None, schema=None, vertices=None, edges=None,):
  self.result = result
  self.schema = schema
  self.vertices = vertices
  self.edges = edges

LookUpIndexResp.__init__ = LookUpIndexResp__init__

def LookUpIndexResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('schema', None)
  state.setdefault('vertices', None)
  state.setdefault('edges', None)
  self.__dict__ = state

LookUpIndexResp.__getstate__ = lambda self: self.__dict__.copy()
LookUpIndexResp.__setstate__ = LookUpIndexResp__setstate__

fix_spec(all_structs)
del all_structs
