#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import nebula.common.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ErrorCode', 'YearMonth', 'Date', 'DateTime', 'Vertex', 'Edge', 'PathEntry', 'Path', 'ColumnValue', 'RowValue', 'ExecutionResponse', 'AuthResponse', 'IdType', 'Timestamp', 'Year']

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAIL_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_BAD_USERNAME_PASSWORD = -4
  E_SESSION_INVALID = -5
  E_SESSION_TIMEOUT = -6
  E_SYNTAX_ERROR = -7
  E_EXECUTION_ERROR = -8
  E_STATEMENT_EMTPY = -9
  E_USER_NOT_FOUND = -10
  E_BAD_PERMISSION = -11

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAIL_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -4: "E_BAD_USERNAME_PASSWORD",
    -5: "E_SESSION_INVALID",
    -6: "E_SESSION_TIMEOUT",
    -7: "E_SYNTAX_ERROR",
    -8: "E_EXECUTION_ERROR",
    -9: "E_STATEMENT_EMTPY",
    -10: "E_USER_NOT_FOUND",
    -11: "E_BAD_PERMISSION",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAIL_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_BAD_USERNAME_PASSWORD": -4,
    "E_SESSION_INVALID": -5,
    "E_SESSION_TIMEOUT": -6,
    "E_SYNTAX_ERROR": -7,
    "E_EXECUTION_ERROR": -8,
    "E_STATEMENT_EMTPY": -9,
    "E_USER_NOT_FOUND": -10,
    "E_BAD_PERMISSION": -11,
  }

class YearMonth:
  """
  Attributes:
   - year
   - month
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('YearMonth')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Date:
  """
  Attributes:
   - year
   - month
   - day
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Date')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DateTime:
  """
  Attributes:
   - year
   - month
   - day
   - hour
   - minute
   - second
   - millisec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.second = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.millisec = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.microsec = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DateTime')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 4)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 5)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.second != None:
      oprot.writeFieldBegin('second', TType.BYTE, 6)
      oprot.writeByte(self.second)
      oprot.writeFieldEnd()
    if self.millisec != None:
      oprot.writeFieldBegin('millisec', TType.I16, 7)
      oprot.writeI16(self.millisec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I16, 8)
      oprot.writeI16(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.second is not None:
      value = pprint.pformat(self.second, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    second=%s' % (value))
    if self.millisec is not None:
      value = pprint.pformat(self.millisec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    millisec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Vertex:
  """
  Attributes:
   - id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Vertex')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Edge:
  """
  Attributes:
   - type
   - ranking
   - src
   - dst
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.type = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.src = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.dst = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Edge')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRING, 1)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 2)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.src != None:
      oprot.writeFieldBegin('src', TType.I64, 3)
      oprot.writeI64(self.src)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.I64, 4)
      oprot.writeI64(self.dst)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PathEntry(object):
  """
  Attributes:
   - vertex
   - edge
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  VERTEX = 1
  EDGE = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_vertex(self):
    assert self.field == 1
    return self.value

  def get_edge(self):
    assert self.field == 2
    return self.value

  def set_vertex(self, value):
    self.field = 1
    self.value = value

  def set_edge(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('vertex', value)
    if self.field == 2:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('edge', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          vertex = Vertex()
          vertex.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_vertex(vertex)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          edge = Edge()
          edge.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_edge(edge)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('PathEntry')
    if self.field == 1:
      oprot.writeFieldBegin('vertex', TType.STRUCT, 1)
      vertex = self.value
      vertex.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('edge', TType.STRUCT, 2)
      edge = self.value
      edge.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Path:
  """
  Attributes:
   - entry_list
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.entry_list = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = PathEntry()
              _elem5.read(iprot)
              self.entry_list.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = PathEntry()
              _elem6.read(iprot)
              self.entry_list.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Path')
    if self.entry_list != None:
      oprot.writeFieldBegin('entry_list', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.entry_list))
      for iter7 in self.entry_list:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.entry_list is not None:
      value = pprint.pformat(self.entry_list, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    entry_list=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ColumnValue(object):
  """
  Attributes:
   - bool_val
   - integer
   - id
   - single_precision
   - double_precision
   - str
   - timestamp
   - year
   - month
   - date
   - datetime
   - path
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  BOOL_VAL = 1
  INTEGER = 2
  ID = 3
  SINGLE_PRECISION = 4
  DOUBLE_PRECISION = 5
  STR = 6
  TIMESTAMP = 7
  YEAR = 8
  MONTH = 9
  DATE = 10
  DATETIME = 11
  PATH = 41
  
  @staticmethod
  def isUnion():
    return True

  def get_bool_val(self):
    assert self.field == 1
    return self.value

  def get_integer(self):
    assert self.field == 2
    return self.value

  def get_id(self):
    assert self.field == 3
    return self.value

  def get_single_precision(self):
    assert self.field == 4
    return self.value

  def get_double_precision(self):
    assert self.field == 5
    return self.value

  def get_str(self):
    assert self.field == 6
    return self.value

  def get_timestamp(self):
    assert self.field == 7
    return self.value

  def get_year(self):
    assert self.field == 8
    return self.value

  def get_month(self):
    assert self.field == 9
    return self.value

  def get_date(self):
    assert self.field == 10
    return self.value

  def get_datetime(self):
    assert self.field == 11
    return self.value

  def get_path(self):
    assert self.field == 41
    return self.value

  def set_bool_val(self, value):
    self.field = 1
    self.value = value

  def set_integer(self, value):
    self.field = 2
    self.value = value

  def set_id(self, value):
    self.field = 3
    self.value = value

  def set_single_precision(self, value):
    self.field = 4
    self.value = value

  def set_double_precision(self, value):
    self.field = 5
    self.value = value

  def set_str(self, value):
    self.field = 6
    self.value = value

  def set_timestamp(self, value):
    self.field = 7
    self.value = value

  def set_year(self, value):
    self.field = 8
    self.value = value

  def set_month(self, value):
    self.field = 9
    self.value = value

  def set_date(self, value):
    self.field = 10
    self.value = value

  def set_datetime(self, value):
    self.field = 11
    self.value = value

  def set_path(self, value):
    self.field = 41
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bool_val', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('integer', value)
    if self.field == 3:
      padding = ' ' * 3
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('id', value)
    if self.field == 4:
      padding = ' ' * 17
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('single_precision', value)
    if self.field == 5:
      padding = ' ' * 17
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('double_precision', value)
    if self.field == 6:
      padding = ' ' * 4
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('str', value)
    if self.field == 7:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('timestamp', value)
    if self.field == 8:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('year', value)
    if self.field == 9:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('month', value)
    if self.field == 10:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('date', value)
    if self.field == 11:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('datetime', value)
    if self.field == 41:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('path', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.BOOL:
          bool_val = iprot.readBool()
          assert self.field == 0 and self.value is None
          self.set_bool_val(bool_val)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          integer = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_integer(integer)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          id = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_id(id)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.FLOAT:
          single_precision = iprot.readFloat()
          assert self.field == 0 and self.value is None
          self.set_single_precision(single_precision)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.DOUBLE:
          double_precision = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_double_precision(double_precision)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          str = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_str(str)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          timestamp = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_timestamp(timestamp)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          year = iprot.readI16()
          assert self.field == 0 and self.value is None
          self.set_year(year)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          month = YearMonth()
          month.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_month(month)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          date = Date()
          date.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_date(date)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          datetime = DateTime()
          datetime.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_datetime(datetime)
        else:
          iprot.skip(ftype)
      elif fid == 41:
        if ftype == TType.STRUCT:
          path = Path()
          path.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_path(path)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('ColumnValue')
    if self.field == 1:
      oprot.writeFieldBegin('bool_val', TType.BOOL, 1)
      bool_val = self.value
      oprot.writeBool(bool_val)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('integer', TType.I64, 2)
      integer = self.value
      oprot.writeI64(integer)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('id', TType.I64, 3)
      id = self.value
      oprot.writeI64(id)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('single_precision', TType.FLOAT, 4)
      single_precision = self.value
      oprot.writeFloat(single_precision)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('double_precision', TType.DOUBLE, 5)
      double_precision = self.value
      oprot.writeDouble(double_precision)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('str', TType.STRING, 6)
      str = self.value
      oprot.writeString(str)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('timestamp', TType.I64, 7)
      timestamp = self.value
      oprot.writeI64(timestamp)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('year', TType.I16, 8)
      year = self.value
      oprot.writeI16(year)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('month', TType.STRUCT, 9)
      month = self.value
      month.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('date', TType.STRUCT, 10)
      date = self.value
      date.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('datetime', TType.STRUCT, 11)
      datetime = self.value
      datetime.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 41:
      oprot.writeFieldBegin('path', TType.STRUCT, 41)
      path = self.value
      path.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RowValue:
  """
  Attributes:
   - columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = ColumnValue()
              _elem13.read(iprot)
              self.columns.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = ColumnValue()
              _elem14.read(iprot)
              self.columns.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RowValue')
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter15 in self.columns:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.columns is not None:
      value = pprint.pformat(self.columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ExecutionResponse:
  """
  Attributes:
   - error_code
   - latency_in_us
   - error_msg
   - column_names
   - rows
   - space_name
   - warning_msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.latency_in_us = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = iprot.readString()
              self.column_names.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = iprot.readString()
              self.column_names.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.rows = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in six.moves.range(_size23):
              _elem28 = RowValue()
              _elem28.read(iprot)
              self.rows.append(_elem28)
          else: 
            while iprot.peekList():
              _elem29 = RowValue()
              _elem29.read(iprot)
              self.rows.append(_elem29)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.space_name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.warning_msg = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.error_code == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'error_code' was not found in serialized data! Struct: ExecutionResponse")

    if self.latency_in_us == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'latency_in_us' was not found in serialized data! Struct: ExecutionResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecutionResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I32, 2)
      oprot.writeI32(self.latency_in_us)
      oprot.writeFieldEnd()
    if self.error_msg != None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 3)
      oprot.writeString(self.error_msg.encode('utf-8')) if UTF8STRINGS and not isinstance(self.error_msg, bytes) else oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter30 in self.column_names:
        oprot.writeString(iter30)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rows != None:
      oprot.writeFieldBegin('rows', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.rows))
      for iter31 in self.rows:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 6)
      oprot.writeString(self.space_name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.space_name, bytes) else oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.warning_msg != None:
      oprot.writeFieldBegin('warning_msg', TType.STRING, 7)
      oprot.writeString(self.warning_msg.encode('utf-8')) if UTF8STRINGS and not isinstance(self.warning_msg, bytes) else oprot.writeString(self.warning_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    if self.error_msg is not None:
      value = pprint.pformat(self.error_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_msg=%s' % (value))
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.rows is not None:
      value = pprint.pformat(self.rows, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    rows=%s' % (value))
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.warning_msg is not None:
      value = pprint.pformat(self.warning_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    warning_msg=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AuthResponse:
  """
  Attributes:
   - error_code
   - session_id
   - error_msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.error_code == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'error_code' was not found in serialized data! Struct: AuthResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AuthResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 2)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    if self.error_msg != None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 3)
      oprot.writeString(self.error_msg.encode('utf-8')) if UTF8STRINGS and not isinstance(self.error_msg, bytes) else oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    if self.error_msg is not None:
      value = pprint.pformat(self.error_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_msg=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

IdType = UnimplementedTypedef()
Timestamp = UnimplementedTypedef()
Year = UnimplementedTypedef()
all_structs.append(YearMonth)
YearMonth.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
)

YearMonth.thrift_struct_annotations = {
}
YearMonth.thrift_field_annotations = {
}

def YearMonth__init__(self, year=None, month=None,):
  self.year = year
  self.month = month

YearMonth.__init__ = YearMonth__init__

def YearMonth__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  self.__dict__ = state

YearMonth.__getstate__ = lambda self: self.__dict__.copy()
YearMonth.__setstate__ = YearMonth__setstate__

all_structs.append(Date)
Date.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
)

Date.thrift_struct_annotations = {
}
Date.thrift_field_annotations = {
}

def Date__init__(self, year=None, month=None, day=None,):
  self.year = year
  self.month = month
  self.day = day

Date.__init__ = Date__init__

def Date__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  self.__dict__ = state

Date.__getstate__ = lambda self: self.__dict__.copy()
Date.__setstate__ = Date__setstate__

all_structs.append(DateTime)
DateTime.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
  (4, TType.BYTE, 'hour', None, None, 2, ), # 4
  (5, TType.BYTE, 'minute', None, None, 2, ), # 5
  (6, TType.BYTE, 'second', None, None, 2, ), # 6
  (7, TType.I16, 'millisec', None, None, 2, ), # 7
  (8, TType.I16, 'microsec', None, None, 2, ), # 8
)

DateTime.thrift_struct_annotations = {
}
DateTime.thrift_field_annotations = {
}

def DateTime__init__(self, year=None, month=None, day=None, hour=None, minute=None, second=None, millisec=None, microsec=None,):
  self.year = year
  self.month = month
  self.day = day
  self.hour = hour
  self.minute = minute
  self.second = second
  self.millisec = millisec
  self.microsec = microsec

DateTime.__init__ = DateTime__init__

def DateTime__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('second', None)
  state.setdefault('millisec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

DateTime.__getstate__ = lambda self: self.__dict__.copy()
DateTime.__setstate__ = DateTime__setstate__

all_structs.append(Vertex)
Vertex.thrift_spec = (
  None, # 0
  (1, TType.I64, 'id', None, None, 2, ), # 1
)

Vertex.thrift_struct_annotations = {
}
Vertex.thrift_field_annotations = {
}

def Vertex__init__(self, id=None,):
  self.id = id

Vertex.__init__ = Vertex__init__

def Vertex__setstate__(self, state):
  state.setdefault('id', None)
  self.__dict__ = state

Vertex.__getstate__ = lambda self: self.__dict__.copy()
Vertex.__setstate__ = Vertex__setstate__

all_structs.append(Edge)
Edge.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'type', False, None, 2, ), # 1
  (2, TType.I64, 'ranking', None, None, 2, ), # 2
  (3, TType.I64, 'src', None, None, 1, ), # 3
  (4, TType.I64, 'dst', None, None, 1, ), # 4
)

Edge.thrift_struct_annotations = {
}
Edge.thrift_field_annotations = {
}

def Edge__init__(self, type=None, ranking=None, src=None, dst=None,):
  self.type = type
  self.ranking = ranking
  self.src = src
  self.dst = dst

Edge.__init__ = Edge__init__

def Edge__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('ranking', None)
  state.setdefault('src', None)
  state.setdefault('dst', None)
  self.__dict__ = state

Edge.__getstate__ = lambda self: self.__dict__.copy()
Edge.__setstate__ = Edge__setstate__

all_structs.append(PathEntry)
PathEntry.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'vertex', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'edge', [Edge, Edge.thrift_spec, False], None, 2, ), # 2
)

PathEntry.thrift_struct_annotations = {
}
PathEntry.thrift_field_annotations = {
}

def PathEntry__init__(self, vertex=None, edge=None,):
  self.field = 0
  self.value = None
  if vertex is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = vertex
  if edge is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = edge

PathEntry.__init__ = PathEntry__init__

all_structs.append(Path)
Path.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'entry_list', (TType.STRUCT,[PathEntry, PathEntry.thrift_spec, True]), None, 2, ), # 1
)

Path.thrift_struct_annotations = {
}
Path.thrift_field_annotations = {
}

def Path__init__(self, entry_list=None,):
  self.entry_list = entry_list

Path.__init__ = Path__init__

def Path__setstate__(self, state):
  state.setdefault('entry_list', None)
  self.__dict__ = state

Path.__getstate__ = lambda self: self.__dict__.copy()
Path.__setstate__ = Path__setstate__

all_structs.append(ColumnValue)
ColumnValue.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'bool_val', None, None, 2, ), # 1
  (2, TType.I64, 'integer', None, None, 2, ), # 2
  (3, TType.I64, 'id', None, None, 2, ), # 3
  (4, TType.FLOAT, 'single_precision', None, None, 2, ), # 4
  (5, TType.DOUBLE, 'double_precision', None, None, 2, ), # 5
  (6, TType.STRING, 'str', False, None, 2, ), # 6
  (7, TType.I64, 'timestamp', None, None, 2, ), # 7
  (8, TType.I16, 'year', None, None, 2, ), # 8
  (9, TType.STRUCT, 'month', [YearMonth, YearMonth.thrift_spec, False], None, 2, ), # 9
  (10, TType.STRUCT, 'date', [Date, Date.thrift_spec, False], None, 2, ), # 10
  (11, TType.STRUCT, 'datetime', [DateTime, DateTime.thrift_spec, False], None, 2, ), # 11
  None, # 12
  None, # 13
  None, # 14
  None, # 15
  None, # 16
  None, # 17
  None, # 18
  None, # 19
  None, # 20
  None, # 21
  None, # 22
  None, # 23
  None, # 24
  None, # 25
  None, # 26
  None, # 27
  None, # 28
  None, # 29
  None, # 30
  None, # 31
  None, # 32
  None, # 33
  None, # 34
  None, # 35
  None, # 36
  None, # 37
  None, # 38
  None, # 39
  None, # 40
  (41, TType.STRUCT, 'path', [Path, Path.thrift_spec, False], None, 2, ), # 41
)

ColumnValue.thrift_struct_annotations = {
}
ColumnValue.thrift_field_annotations = {
}

def ColumnValue__init__(self, bool_val=None, integer=None, id=None, single_precision=None, double_precision=None, str=None, timestamp=None, year=None, month=None, date=None, datetime=None, path=None,):
  self.field = 0
  self.value = None
  if bool_val is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = bool_val
  if integer is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = integer
  if id is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = id
  if single_precision is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = single_precision
  if double_precision is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = double_precision
  if str is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = str
  if timestamp is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = timestamp
  if year is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = year
  if month is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = month
  if date is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = date
  if datetime is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = datetime
  if path is not None:
    assert self.field == 0 and self.value is None
    self.field = 41
    self.value = path

ColumnValue.__init__ = ColumnValue__init__

all_structs.append(RowValue)
RowValue.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'columns', (TType.STRUCT,[ColumnValue, ColumnValue.thrift_spec, True]), None, 2, ), # 1
)

RowValue.thrift_struct_annotations = {
}
RowValue.thrift_field_annotations = {
}

def RowValue__init__(self, columns=None,):
  self.columns = columns

RowValue.__init__ = RowValue__init__

def RowValue__setstate__(self, state):
  state.setdefault('columns', None)
  self.__dict__ = state

RowValue.__getstate__ = lambda self: self.__dict__.copy()
RowValue.__setstate__ = RowValue__setstate__

all_structs.append(ExecutionResponse)
ExecutionResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', ErrorCode, None, 0, ), # 1
  (2, TType.I32, 'latency_in_us', None, None, 0, ), # 2
  (3, TType.STRING, 'error_msg', True, None, 1, ), # 3
  (4, TType.LIST, 'column_names', (TType.STRING,False), None, 1, ), # 4
  (5, TType.LIST, 'rows', (TType.STRUCT,[RowValue, RowValue.thrift_spec, False]), None, 1, ), # 5
  (6, TType.STRING, 'space_name', True, None, 1, ), # 6
  (7, TType.STRING, 'warning_msg', True, None, 1, ), # 7
)

ExecutionResponse.thrift_struct_annotations = {
}
ExecutionResponse.thrift_field_annotations = {
}

def ExecutionResponse__init__(self, error_code=None, latency_in_us=None, error_msg=None, column_names=None, rows=None, space_name=None, warning_msg=None,):
  self.error_code = error_code
  self.latency_in_us = latency_in_us
  self.error_msg = error_msg
  self.column_names = column_names
  self.rows = rows
  self.space_name = space_name
  self.warning_msg = warning_msg

ExecutionResponse.__init__ = ExecutionResponse__init__

def ExecutionResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  state.setdefault('latency_in_us', None)
  state.setdefault('error_msg', None)
  state.setdefault('column_names', None)
  state.setdefault('rows', None)
  state.setdefault('space_name', None)
  state.setdefault('warning_msg', None)
  self.__dict__ = state

ExecutionResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecutionResponse.__setstate__ = ExecutionResponse__setstate__

all_structs.append(AuthResponse)
AuthResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', ErrorCode, None, 0, ), # 1
  (2, TType.I64, 'session_id', None, None, 1, ), # 2
  (3, TType.STRING, 'error_msg', True, None, 1, ), # 3
)

AuthResponse.thrift_struct_annotations = {
}
AuthResponse.thrift_field_annotations = {
}

def AuthResponse__init__(self, error_code=None, session_id=None, error_msg=None,):
  self.error_code = error_code
  self.session_id = session_id
  self.error_msg = error_msg

AuthResponse.__init__ = AuthResponse__init__

def AuthResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  state.setdefault('session_id', None)
  state.setdefault('error_msg', None)
  self.__dict__ = state

AuthResponse.__getstate__ = lambda self: self.__dict__.copy()
AuthResponse.__setstate__ = AuthResponse__setstate__

fix_spec(all_structs)
del all_structs
