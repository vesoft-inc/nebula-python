#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from nebula2.fbthrift.util.Recursive import fix_spec
from nebula2.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula2.fbthrift.protocol.TProtocol import TProtocolException


import nebula2.common.ttypes
import nebula2.meta.ttypes


import pprint
import warnings
from nebula2.fbthrift import Thrift
from nebula2.fbthrift.transport import TTransport
from nebula2.fbthrift.protocol import TBinaryProtocol
from nebula2.fbthrift.protocol import TCompactProtocol
from nebula2.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula2.fbthrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'StatType', 'OrderDirection', 'EdgeDirection', 'ScanType', 'EngineSignType', 'RequestCommon', 'PartitionResult', 'ResponseCommon', 'StatProp', 'Expr', 'EdgeProp', 'VertexProp', 'OrderBy', 'TraverseSpec', 'GetNeighborsRequest', 'GetNeighborsResponse', 'ExecResponse', 'GetPropRequest', 'GetPropResponse', 'NewTag', 'NewVertex', 'EdgeKey', 'NewEdge', 'AddVerticesRequest', 'AddEdgesRequest', 'DeleteVerticesRequest', 'DeleteEdgesRequest', 'DelTags', 'DeleteTagsRequest', 'UpdateResponse', 'UpdatedProp', 'UpdateVertexRequest', 'UpdateEdgeRequest', 'GetUUIDReq', 'GetUUIDResp', 'LookupIndexResp', 'IndexColumnHint', 'IndexQueryContext', 'IndexSpec', 'LookupIndexRequest', 'LookupAndTraverseRequest', 'ScanCursor', 'ScanVertexRequest', 'ScanEdgeRequest', 'ScanResponse', 'TaskPara', 'KVGetRequest', 'KVGetResponse', 'KVPutRequest', 'KVRemoveRequest', 'AdminExecResp', 'TransLeaderReq', 'AddPartReq', 'AddLearnerReq', 'RemovePartReq', 'MemberChangeReq', 'CatchUpDataReq', 'GetLeaderReq', 'CreateCPRequest', 'DropCPRequest', 'BlockingSignRequest', 'GetLeaderPartsResp', 'CheckPeersReq', 'RebuildIndexRequest', 'CreateCPResp', 'ListClusterInfoResp', 'ListClusterInfoReq', 'AddAdminTaskRequest', 'StopAdminTaskRequest', 'InternalTxnRequest', 'ChainAddEdgesRequest', 'ChainUpdateEdgeRequest']

class StatType:
  SUM = 1
  COUNT = 2
  AVG = 3
  MAX = 4
  MIN = 5

  _VALUES_TO_NAMES = {
    1: "SUM",
    2: "COUNT",
    3: "AVG",
    4: "MAX",
    5: "MIN",
  }

  _NAMES_TO_VALUES = {
    "SUM": 1,
    "COUNT": 2,
    "AVG": 3,
    "MAX": 4,
    "MIN": 5,
  }

class OrderDirection:
  ASCENDING = 1
  DESCENDING = 2

  _VALUES_TO_NAMES = {
    1: "ASCENDING",
    2: "DESCENDING",
  }

  _NAMES_TO_VALUES = {
    "ASCENDING": 1,
    "DESCENDING": 2,
  }

class EdgeDirection:
  BOTH = 1
  IN_EDGE = 2
  OUT_EDGE = 3

  _VALUES_TO_NAMES = {
    1: "BOTH",
    2: "IN_EDGE",
    3: "OUT_EDGE",
  }

  _NAMES_TO_VALUES = {
    "BOTH": 1,
    "IN_EDGE": 2,
    "OUT_EDGE": 3,
  }

class ScanType:
  PREFIX = 1
  RANGE = 2

  _VALUES_TO_NAMES = {
    1: "PREFIX",
    2: "RANGE",
  }

  _NAMES_TO_VALUES = {
    "PREFIX": 1,
    "RANGE": 2,
  }

class EngineSignType:
  BLOCK_ON = 1
  BLOCK_OFF = 2

  _VALUES_TO_NAMES = {
    1: "BLOCK_ON",
    2: "BLOCK_OFF",
  }

  _NAMES_TO_VALUES = {
    "BLOCK_ON": 1,
    "BLOCK_OFF": 2,
  }

class RequestCommon:
  """
  Attributes:
   - session_id
   - plan_id
   - profile_detail
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.plan_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.profile_detail = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RequestCommon')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    if self.plan_id != None:
      oprot.writeFieldBegin('plan_id', TType.I64, 2)
      oprot.writeI64(self.plan_id)
      oprot.writeFieldEnd()
    if self.profile_detail != None:
      oprot.writeFieldBegin('profile_detail', TType.BOOL, 3)
      oprot.writeBool(self.profile_detail)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    if self.plan_id is not None:
      value = pprint.pformat(self.plan_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    plan_id=%s' % (value))
    if self.profile_detail is not None:
      value = pprint.pformat(self.profile_detail, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    profile_detail=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PartitionResult:
  """
  Attributes:
   - code
   - part_id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionResult')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ResponseCommon:
  """
  Attributes:
   - failed_parts
   - latency_in_us
   - latency_detail_us
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.failed_parts = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = PartitionResult()
              _elem5.read(iprot)
              self.failed_parts.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = PartitionResult()
              _elem6.read(iprot)
              self.failed_parts.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.latency_in_us = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.latency_detail_us = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          if _size7 >= 0:
            for _i11 in range(_size7):
              _key12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val13 = iprot.readI32()
              self.latency_detail_us[_key12] = _val13
          else: 
            while iprot.peekMap():
              _key14 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val15 = iprot.readI32()
              self.latency_detail_us[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ResponseCommon')
    if self.failed_parts != None:
      oprot.writeFieldBegin('failed_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.failed_parts))
      for iter16 in self.failed_parts:
        iter16.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I64, 2)
      oprot.writeI64(self.latency_in_us)
      oprot.writeFieldEnd()
    if self.latency_detail_us != None:
      oprot.writeFieldBegin('latency_detail_us', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.latency_detail_us))
      for kiter17,viter18 in self.latency_detail_us.items():
        oprot.writeString(kiter17.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter17, bytes) else oprot.writeString(kiter17)
        oprot.writeI32(viter18)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.failed_parts is not None:
      value = pprint.pformat(self.failed_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    failed_parts=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    if self.latency_detail_us is not None:
      value = pprint.pformat(self.latency_detail_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_detail_us=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StatProp:
  """
  Attributes:
   - alias
   - prop
   - stat
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.stat = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StatProp')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 2)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.stat != None:
      oprot.writeFieldBegin('stat', TType.I32, 3)
      oprot.writeI32(self.stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.stat is not None:
      value = pprint.pformat(self.stat, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Expr:
  """
  Attributes:
   - alias
   - expr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Expr')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.expr != None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.expr is not None:
      value = pprint.pformat(self.expr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class EdgeProp:
  """
  Attributes:
   - type
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype22, _size19) = iprot.readListBegin()
          if _size19 >= 0:
            for _i23 in range(_size19):
              _elem24 = iprot.readString()
              self.props.append(_elem24)
          else: 
            while iprot.peekList():
              _elem25 = iprot.readString()
              self.props.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeProp')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter26 in self.props:
        oprot.writeString(iter26)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class VertexProp:
  """
  Attributes:
   - tag
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype30, _size27) = iprot.readListBegin()
          if _size27 >= 0:
            for _i31 in range(_size27):
              _elem32 = iprot.readString()
              self.props.append(_elem32)
          else: 
            while iprot.peekList():
              _elem33 = iprot.readString()
              self.props.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexProp')
    if self.tag != None:
      oprot.writeFieldBegin('tag', TType.I32, 1)
      oprot.writeI32(self.tag)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter34 in self.props:
        oprot.writeString(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag is not None:
      value = pprint.pformat(self.tag, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class OrderBy:
  """
  Attributes:
   - prop
   - direction
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OrderBy')
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 1)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, 2)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.direction is not None:
      value = pprint.pformat(self.direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    direction=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TraverseSpec:
  """
  Attributes:
   - edge_types
   - edge_direction
   - dedup
   - stat_props
   - vertex_props
   - edge_props
   - expressions
   - order_by
   - random
   - limit
   - filter
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.edge_types = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in range(_size35):
              _elem40 = iprot.readI32()
              self.edge_types.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = iprot.readI32()
              self.edge_types.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stat_props = []
          (_etype45, _size42) = iprot.readListBegin()
          if _size42 >= 0:
            for _i46 in range(_size42):
              _elem47 = StatProp()
              _elem47.read(iprot)
              self.stat_props.append(_elem47)
          else: 
            while iprot.peekList():
              _elem48 = StatProp()
              _elem48.read(iprot)
              self.stat_props.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype52, _size49) = iprot.readListBegin()
          if _size49 >= 0:
            for _i53 in range(_size49):
              _elem54 = VertexProp()
              _elem54.read(iprot)
              self.vertex_props.append(_elem54)
          else: 
            while iprot.peekList():
              _elem55 = VertexProp()
              _elem55.read(iprot)
              self.vertex_props.append(_elem55)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype59, _size56) = iprot.readListBegin()
          if _size56 >= 0:
            for _i60 in range(_size56):
              _elem61 = EdgeProp()
              _elem61.read(iprot)
              self.edge_props.append(_elem61)
          else: 
            while iprot.peekList():
              _elem62 = EdgeProp()
              _elem62.read(iprot)
              self.edge_props.append(_elem62)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype66, _size63) = iprot.readListBegin()
          if _size63 >= 0:
            for _i67 in range(_size63):
              _elem68 = Expr()
              _elem68.read(iprot)
              self.expressions.append(_elem68)
          else: 
            while iprot.peekList():
              _elem69 = Expr()
              _elem69.read(iprot)
              self.expressions.append(_elem69)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype73, _size70) = iprot.readListBegin()
          if _size70 >= 0:
            for _i74 in range(_size70):
              _elem75 = OrderBy()
              _elem75.read(iprot)
              self.order_by.append(_elem75)
          else: 
            while iprot.peekList():
              _elem76 = OrderBy()
              _elem76.read(iprot)
              self.order_by.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.random = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TraverseSpec')
    if self.edge_types != None:
      oprot.writeFieldBegin('edge_types', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.edge_types))
      for iter77 in self.edge_types:
        oprot.writeI32(iter77)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_direction != None:
      oprot.writeFieldBegin('edge_direction', TType.I32, 2)
      oprot.writeI32(self.edge_direction)
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 3)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.stat_props != None:
      oprot.writeFieldBegin('stat_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.stat_props))
      for iter78 in self.stat_props:
        iter78.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter79 in self.vertex_props:
        iter79.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter80 in self.edge_props:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter81 in self.expressions:
        iter81.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter82 in self.order_by:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.random != None:
      oprot.writeFieldBegin('random', TType.BOOL, 9)
      oprot.writeBool(self.random)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 10)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 11)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.edge_types is not None:
      value = pprint.pformat(self.edge_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_types=%s' % (value))
    if self.edge_direction is not None:
      value = pprint.pformat(self.edge_direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_direction=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.stat_props is not None:
      value = pprint.pformat(self.stat_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat_props=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.random is not None:
      value = pprint.pformat(self.random, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    random=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetNeighborsRequest:
  """
  Attributes:
   - space_id
   - column_names
   - parts
   - traverse_spec
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype86, _size83) = iprot.readListBegin()
          if _size83 >= 0:
            for _i87 in range(_size83):
              _elem88 = iprot.readString()
              self.column_names.append(_elem88)
          else: 
            while iprot.peekList():
              _elem89 = iprot.readString()
              self.column_names.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin() 
          if _size90 >= 0:
            for _i94 in range(_size90):
              _key95 = iprot.readI32()
              _val96 = []
              (_etype100, _size97) = iprot.readListBegin()
              if _size97 >= 0:
                for _i101 in range(_size97):
                  _elem102 = nebula2.common.ttypes.Row()
                  _elem102.read(iprot)
                  _val96.append(_elem102)
              else: 
                while iprot.peekList():
                  _elem103 = nebula2.common.ttypes.Row()
                  _elem103.read(iprot)
                  _val96.append(_elem103)
              iprot.readListEnd()
              self.parts[_key95] = _val96
          else: 
            while iprot.peekMap():
              _key104 = iprot.readI32()
              _val105 = []
              (_etype109, _size106) = iprot.readListBegin()
              if _size106 >= 0:
                for _i110 in range(_size106):
                  _elem111 = nebula2.common.ttypes.Row()
                  _elem111.read(iprot)
                  _val105.append(_elem111)
              else: 
                while iprot.peekList():
                  _elem112 = nebula2.common.ttypes.Row()
                  _elem112.read(iprot)
                  _val105.append(_elem112)
              iprot.readListEnd()
              self.parts[_key104] = _val105
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter113 in self.column_names:
        oprot.writeString(iter113)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter114,viter115 in self.parts.items():
        oprot.writeI32(kiter114)
        oprot.writeListBegin(TType.STRUCT, len(viter115))
        for iter116 in viter115:
          iter116.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 5)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetNeighborsResponse:
  """
  Attributes:
   - result
   - vertices
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vertices = nebula2.common.ttypes.DataSet()
          self.vertices.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertices != None:
      oprot.writeFieldBegin('vertices', TType.STRUCT, 2)
      self.vertices.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertices is not None:
      value = pprint.pformat(self.vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertices=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ExecResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetPropRequest:
  """
  Attributes:
   - space_id
   - parts
   - vertex_props
   - edge_props
   - expressions
   - dedup
   - order_by
   - limit
   - filter
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype118, _vtype119, _size117 ) = iprot.readMapBegin() 
          if _size117 >= 0:
            for _i121 in range(_size117):
              _key122 = iprot.readI32()
              _val123 = []
              (_etype127, _size124) = iprot.readListBegin()
              if _size124 >= 0:
                for _i128 in range(_size124):
                  _elem129 = nebula2.common.ttypes.Row()
                  _elem129.read(iprot)
                  _val123.append(_elem129)
              else: 
                while iprot.peekList():
                  _elem130 = nebula2.common.ttypes.Row()
                  _elem130.read(iprot)
                  _val123.append(_elem130)
              iprot.readListEnd()
              self.parts[_key122] = _val123
          else: 
            while iprot.peekMap():
              _key131 = iprot.readI32()
              _val132 = []
              (_etype136, _size133) = iprot.readListBegin()
              if _size133 >= 0:
                for _i137 in range(_size133):
                  _elem138 = nebula2.common.ttypes.Row()
                  _elem138.read(iprot)
                  _val132.append(_elem138)
              else: 
                while iprot.peekList():
                  _elem139 = nebula2.common.ttypes.Row()
                  _elem139.read(iprot)
                  _val132.append(_elem139)
              iprot.readListEnd()
              self.parts[_key131] = _val132
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype143, _size140) = iprot.readListBegin()
          if _size140 >= 0:
            for _i144 in range(_size140):
              _elem145 = VertexProp()
              _elem145.read(iprot)
              self.vertex_props.append(_elem145)
          else: 
            while iprot.peekList():
              _elem146 = VertexProp()
              _elem146.read(iprot)
              self.vertex_props.append(_elem146)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype150, _size147) = iprot.readListBegin()
          if _size147 >= 0:
            for _i151 in range(_size147):
              _elem152 = EdgeProp()
              _elem152.read(iprot)
              self.edge_props.append(_elem152)
          else: 
            while iprot.peekList():
              _elem153 = EdgeProp()
              _elem153.read(iprot)
              self.edge_props.append(_elem153)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype157, _size154) = iprot.readListBegin()
          if _size154 >= 0:
            for _i158 in range(_size154):
              _elem159 = Expr()
              _elem159.read(iprot)
              self.expressions.append(_elem159)
          else: 
            while iprot.peekList():
              _elem160 = Expr()
              _elem160.read(iprot)
              self.expressions.append(_elem160)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype164, _size161) = iprot.readListBegin()
          if _size161 >= 0:
            for _i165 in range(_size161):
              _elem166 = OrderBy()
              _elem166.read(iprot)
              self.order_by.append(_elem166)
          else: 
            while iprot.peekList():
              _elem167 = OrderBy()
              _elem167.read(iprot)
              self.order_by.append(_elem167)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter168,viter169 in self.parts.items():
        oprot.writeI32(kiter168)
        oprot.writeListBegin(TType.STRUCT, len(viter169))
        for iter170 in viter169:
          iter170.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter171 in self.vertex_props:
        iter171.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter172 in self.edge_props:
        iter172.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter173 in self.expressions:
        iter173.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 6)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter174 in self.order_by:
        iter174.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 8)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 9)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 10)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetPropResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NewTag:
  """
  Attributes:
   - tag_id
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype178, _size175) = iprot.readListBegin()
          if _size175 >= 0:
            for _i179 in range(_size175):
              _elem180 = nebula2.common.ttypes.Value()
              _elem180.read(iprot)
              self.props.append(_elem180)
          else: 
            while iprot.peekList():
              _elem181 = nebula2.common.ttypes.Value()
              _elem181.read(iprot)
              self.props.append(_elem181)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewTag')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter182 in self.props:
        iter182.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NewVertex:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = nebula2.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype186, _size183) = iprot.readListBegin()
          if _size183 >= 0:
            for _i187 in range(_size183):
              _elem188 = NewTag()
              _elem188.read(iprot)
              self.tags.append(_elem188)
          else: 
            while iprot.peekList():
              _elem189 = NewTag()
              _elem189.read(iprot)
              self.tags.append(_elem189)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewVertex')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter190 in self.tags:
        iter190.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class EdgeKey:
  """
  Attributes:
   - src
   - edge_type
   - ranking
   - dst
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = nebula2.common.ttypes.Value()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.dst = nebula2.common.ttypes.Value()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeKey')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 3)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 4)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NewEdge:
  """
  Attributes:
   - key
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = EdgeKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype194, _size191) = iprot.readListBegin()
          if _size191 >= 0:
            for _i195 in range(_size191):
              _elem196 = nebula2.common.ttypes.Value()
              _elem196.read(iprot)
              self.props.append(_elem196)
          else: 
            while iprot.peekList():
              _elem197 = nebula2.common.ttypes.Value()
              _elem197.read(iprot)
              self.props.append(_elem197)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewEdge')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter198 in self.props:
        iter198.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - if_not_exists
   - ignore_existed_index
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype200, _vtype201, _size199 ) = iprot.readMapBegin() 
          if _size199 >= 0:
            for _i203 in range(_size199):
              _key204 = iprot.readI32()
              _val205 = []
              (_etype209, _size206) = iprot.readListBegin()
              if _size206 >= 0:
                for _i210 in range(_size206):
                  _elem211 = NewVertex()
                  _elem211.read(iprot)
                  _val205.append(_elem211)
              else: 
                while iprot.peekList():
                  _elem212 = NewVertex()
                  _elem212.read(iprot)
                  _val205.append(_elem212)
              iprot.readListEnd()
              self.parts[_key204] = _val205
          else: 
            while iprot.peekMap():
              _key213 = iprot.readI32()
              _val214 = []
              (_etype218, _size215) = iprot.readListBegin()
              if _size215 >= 0:
                for _i219 in range(_size215):
                  _elem220 = NewVertex()
                  _elem220.read(iprot)
                  _val214.append(_elem220)
              else: 
                while iprot.peekList():
                  _elem221 = NewVertex()
                  _elem221.read(iprot)
                  _val214.append(_elem221)
              iprot.readListEnd()
              self.parts[_key213] = _val214
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.prop_names = {}
          (_ktype223, _vtype224, _size222 ) = iprot.readMapBegin() 
          if _size222 >= 0:
            for _i226 in range(_size222):
              _key227 = iprot.readI32()
              _val228 = []
              (_etype232, _size229) = iprot.readListBegin()
              if _size229 >= 0:
                for _i233 in range(_size229):
                  _elem234 = iprot.readString()
                  _val228.append(_elem234)
              else: 
                while iprot.peekList():
                  _elem235 = iprot.readString()
                  _val228.append(_elem235)
              iprot.readListEnd()
              self.prop_names[_key227] = _val228
          else: 
            while iprot.peekMap():
              _key236 = iprot.readI32()
              _val237 = []
              (_etype241, _size238) = iprot.readListBegin()
              if _size238 >= 0:
                for _i242 in range(_size238):
                  _elem243 = iprot.readString()
                  _val237.append(_elem243)
              else: 
                while iprot.peekList():
                  _elem244 = iprot.readString()
                  _val237.append(_elem244)
              iprot.readListEnd()
              self.prop_names[_key236] = _val237
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ignore_existed_index = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter245,viter246 in self.parts.items():
        oprot.writeI32(kiter245)
        oprot.writeListBegin(TType.STRUCT, len(viter246))
        for iter247 in viter246:
          iter247.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.prop_names))
      for kiter248,viter249 in self.prop_names.items():
        oprot.writeI32(kiter248)
        oprot.writeListBegin(TType.STRING, len(viter249))
        for iter250 in viter249:
          oprot.writeString(iter250)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.ignore_existed_index != None:
      oprot.writeFieldBegin('ignore_existed_index', TType.BOOL, 5)
      oprot.writeBool(self.ignore_existed_index)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 6)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.ignore_existed_index is not None:
      value = pprint.pformat(self.ignore_existed_index, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ignore_existed_index=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - if_not_exists
   - ignore_existed_index
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype252, _vtype253, _size251 ) = iprot.readMapBegin() 
          if _size251 >= 0:
            for _i255 in range(_size251):
              _key256 = iprot.readI32()
              _val257 = []
              (_etype261, _size258) = iprot.readListBegin()
              if _size258 >= 0:
                for _i262 in range(_size258):
                  _elem263 = NewEdge()
                  _elem263.read(iprot)
                  _val257.append(_elem263)
              else: 
                while iprot.peekList():
                  _elem264 = NewEdge()
                  _elem264.read(iprot)
                  _val257.append(_elem264)
              iprot.readListEnd()
              self.parts[_key256] = _val257
          else: 
            while iprot.peekMap():
              _key265 = iprot.readI32()
              _val266 = []
              (_etype270, _size267) = iprot.readListBegin()
              if _size267 >= 0:
                for _i271 in range(_size267):
                  _elem272 = NewEdge()
                  _elem272.read(iprot)
                  _val266.append(_elem272)
              else: 
                while iprot.peekList():
                  _elem273 = NewEdge()
                  _elem273.read(iprot)
                  _val266.append(_elem273)
              iprot.readListEnd()
              self.parts[_key265] = _val266
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prop_names = []
          (_etype277, _size274) = iprot.readListBegin()
          if _size274 >= 0:
            for _i278 in range(_size274):
              _elem279 = iprot.readString()
              self.prop_names.append(_elem279)
          else: 
            while iprot.peekList():
              _elem280 = iprot.readString()
              self.prop_names.append(_elem280)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ignore_existed_index = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter281,viter282 in self.parts.items():
        oprot.writeI32(kiter281)
        oprot.writeListBegin(TType.STRUCT, len(viter282))
        for iter283 in viter282:
          iter283.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.prop_names))
      for iter284 in self.prop_names:
        oprot.writeString(iter284)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.ignore_existed_index != None:
      oprot.writeFieldBegin('ignore_existed_index', TType.BOOL, 5)
      oprot.writeBool(self.ignore_existed_index)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 6)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.ignore_existed_index is not None:
      value = pprint.pformat(self.ignore_existed_index, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ignore_existed_index=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DeleteVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype286, _vtype287, _size285 ) = iprot.readMapBegin() 
          if _size285 >= 0:
            for _i289 in range(_size285):
              _key290 = iprot.readI32()
              _val291 = []
              (_etype295, _size292) = iprot.readListBegin()
              if _size292 >= 0:
                for _i296 in range(_size292):
                  _elem297 = nebula2.common.ttypes.Value()
                  _elem297.read(iprot)
                  _val291.append(_elem297)
              else: 
                while iprot.peekList():
                  _elem298 = nebula2.common.ttypes.Value()
                  _elem298.read(iprot)
                  _val291.append(_elem298)
              iprot.readListEnd()
              self.parts[_key290] = _val291
          else: 
            while iprot.peekMap():
              _key299 = iprot.readI32()
              _val300 = []
              (_etype304, _size301) = iprot.readListBegin()
              if _size301 >= 0:
                for _i305 in range(_size301):
                  _elem306 = nebula2.common.ttypes.Value()
                  _elem306.read(iprot)
                  _val300.append(_elem306)
              else: 
                while iprot.peekList():
                  _elem307 = nebula2.common.ttypes.Value()
                  _elem307.read(iprot)
                  _val300.append(_elem307)
              iprot.readListEnd()
              self.parts[_key299] = _val300
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter308,viter309 in self.parts.items():
        oprot.writeI32(kiter308)
        oprot.writeListBegin(TType.STRUCT, len(viter309))
        for iter310 in viter309:
          iter310.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DeleteEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype312, _vtype313, _size311 ) = iprot.readMapBegin() 
          if _size311 >= 0:
            for _i315 in range(_size311):
              _key316 = iprot.readI32()
              _val317 = []
              (_etype321, _size318) = iprot.readListBegin()
              if _size318 >= 0:
                for _i322 in range(_size318):
                  _elem323 = EdgeKey()
                  _elem323.read(iprot)
                  _val317.append(_elem323)
              else: 
                while iprot.peekList():
                  _elem324 = EdgeKey()
                  _elem324.read(iprot)
                  _val317.append(_elem324)
              iprot.readListEnd()
              self.parts[_key316] = _val317
          else: 
            while iprot.peekMap():
              _key325 = iprot.readI32()
              _val326 = []
              (_etype330, _size327) = iprot.readListBegin()
              if _size327 >= 0:
                for _i331 in range(_size327):
                  _elem332 = EdgeKey()
                  _elem332.read(iprot)
                  _val326.append(_elem332)
              else: 
                while iprot.peekList():
                  _elem333 = EdgeKey()
                  _elem333.read(iprot)
                  _val326.append(_elem333)
              iprot.readListEnd()
              self.parts[_key325] = _val326
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter334,viter335 in self.parts.items():
        oprot.writeI32(kiter334)
        oprot.writeListBegin(TType.STRUCT, len(viter335))
        for iter336 in viter335:
          iter336.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DelTags:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = nebula2.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype340, _size337) = iprot.readListBegin()
          if _size337 >= 0:
            for _i341 in range(_size337):
              _elem342 = iprot.readI32()
              self.tags.append(_elem342)
          else: 
            while iprot.peekList():
              _elem343 = iprot.readI32()
              self.tags.append(_elem343)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DelTags')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.tags))
      for iter344 in self.tags:
        oprot.writeI32(iter344)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DeleteTagsRequest:
  """
  Attributes:
   - space_id
   - parts
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype346, _vtype347, _size345 ) = iprot.readMapBegin() 
          if _size345 >= 0:
            for _i349 in range(_size345):
              _key350 = iprot.readI32()
              _val351 = []
              (_etype355, _size352) = iprot.readListBegin()
              if _size352 >= 0:
                for _i356 in range(_size352):
                  _elem357 = DelTags()
                  _elem357.read(iprot)
                  _val351.append(_elem357)
              else: 
                while iprot.peekList():
                  _elem358 = DelTags()
                  _elem358.read(iprot)
                  _val351.append(_elem358)
              iprot.readListEnd()
              self.parts[_key350] = _val351
          else: 
            while iprot.peekMap():
              _key359 = iprot.readI32()
              _val360 = []
              (_etype364, _size361) = iprot.readListBegin()
              if _size361 >= 0:
                for _i365 in range(_size361):
                  _elem366 = DelTags()
                  _elem366.read(iprot)
                  _val360.append(_elem366)
              else: 
                while iprot.peekList():
                  _elem367 = DelTags()
                  _elem367.read(iprot)
                  _val360.append(_elem367)
              iprot.readListEnd()
              self.parts[_key359] = _val360
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteTagsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter368,viter369 in self.parts.items():
        oprot.writeI32(kiter368)
        oprot.writeListBegin(TType.STRUCT, len(viter369))
        for iter370 in viter369:
          iter370.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdatedProp:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdatedProp')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateVertexRequest:
  """
  Attributes:
   - space_id
   - part_id
   - vertex_id
   - tag_id
   - updated_props
   - insertable
   - return_props
   - condition
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.vertex_id = nebula2.common.ttypes.Value()
          self.vertex_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype374, _size371) = iprot.readListBegin()
          if _size371 >= 0:
            for _i375 in range(_size371):
              _elem376 = UpdatedProp()
              _elem376.read(iprot)
              self.updated_props.append(_elem376)
          else: 
            while iprot.peekList():
              _elem377 = UpdatedProp()
              _elem377.read(iprot)
              self.updated_props.append(_elem377)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype381, _size378) = iprot.readListBegin()
          if _size378 >= 0:
            for _i382 in range(_size378):
              _elem383 = iprot.readString()
              self.return_props.append(_elem383)
          else: 
            while iprot.peekList():
              _elem384 = iprot.readString()
              self.return_props.append(_elem384)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.STRUCT, 3)
      self.vertex_id.write(oprot)
      oprot.writeFieldEnd()
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 4)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter385 in self.updated_props:
        iter385.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[6][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 6)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter386 in self.return_props:
        oprot.writeString(iter386)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 8)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 9)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateEdgeRequest:
  """
  Attributes:
   - space_id
   - part_id
   - edge_key
   - updated_props
   - insertable
   - return_props
   - condition
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.edge_key = EdgeKey()
          self.edge_key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype390, _size387) = iprot.readListBegin()
          if _size387 >= 0:
            for _i391 in range(_size387):
              _elem392 = UpdatedProp()
              _elem392.read(iprot)
              self.updated_props.append(_elem392)
          else: 
            while iprot.peekList():
              _elem393 = UpdatedProp()
              _elem393.read(iprot)
              self.updated_props.append(_elem393)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype397, _size394) = iprot.readListBegin()
          if _size394 >= 0:
            for _i398 in range(_size394):
              _elem399 = iprot.readString()
              self.return_props.append(_elem399)
          else: 
            while iprot.peekList():
              _elem400 = iprot.readString()
              self.return_props.append(_elem400)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.edge_key != None:
      oprot.writeFieldBegin('edge_key', TType.STRUCT, 3)
      self.edge_key.write(oprot)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter401 in self.updated_props:
        iter401.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[5][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 5)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter402 in self.return_props:
        oprot.writeString(iter402)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 7)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 8)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.edge_key is not None:
      value = pprint.pformat(self.edge_key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_key=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetUUIDReq:
  """
  Attributes:
   - space_id
   - part_id
   - name
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 4)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetUUIDResp:
  """
  Attributes:
   - result
   - id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.id = nebula2.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 2)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LookupIndexResp:
  """
  Attributes:
   - result
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = nebula2.common.ttypes.DataSet()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexColumnHint:
  """
  Attributes:
   - column_name
   - scan_type
   - begin_value
   - end_value
   - include_begin
   - include_end
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.scan_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.begin_value = nebula2.common.ttypes.Value()
          self.begin_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.end_value = nebula2.common.ttypes.Value()
          self.end_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.include_begin = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.include_end = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexColumnHint')
    if self.column_name != None:
      oprot.writeFieldBegin('column_name', TType.STRING, 1)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.scan_type != None:
      oprot.writeFieldBegin('scan_type', TType.I32, 2)
      oprot.writeI32(self.scan_type)
      oprot.writeFieldEnd()
    if self.begin_value != None:
      oprot.writeFieldBegin('begin_value', TType.STRUCT, 3)
      self.begin_value.write(oprot)
      oprot.writeFieldEnd()
    if self.end_value != None:
      oprot.writeFieldBegin('end_value', TType.STRUCT, 4)
      self.end_value.write(oprot)
      oprot.writeFieldEnd()
    if self.include_begin != None:
      oprot.writeFieldBegin('include_begin', TType.BOOL, 5)
      oprot.writeBool(self.include_begin)
      oprot.writeFieldEnd()
    if self.include_end != None:
      oprot.writeFieldBegin('include_end', TType.BOOL, 6)
      oprot.writeBool(self.include_end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_name is not None:
      value = pprint.pformat(self.column_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_name=%s' % (value))
    if self.scan_type is not None:
      value = pprint.pformat(self.scan_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    scan_type=%s' % (value))
    if self.begin_value is not None:
      value = pprint.pformat(self.begin_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    begin_value=%s' % (value))
    if self.end_value is not None:
      value = pprint.pformat(self.end_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_value=%s' % (value))
    if self.include_begin is not None:
      value = pprint.pformat(self.include_begin, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    include_begin=%s' % (value))
    if self.include_end is not None:
      value = pprint.pformat(self.include_end, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    include_end=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexQueryContext:
  """
  Attributes:
   - index_id
   - filter
   - column_hints
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.column_hints = []
          (_etype406, _size403) = iprot.readListBegin()
          if _size403 >= 0:
            for _i407 in range(_size403):
              _elem408 = IndexColumnHint()
              _elem408.read(iprot)
              self.column_hints.append(_elem408)
          else: 
            while iprot.peekList():
              _elem409 = IndexColumnHint()
              _elem409.read(iprot)
              self.column_hints.append(_elem409)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexQueryContext')
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 1)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.column_hints != None:
      oprot.writeFieldBegin('column_hints', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.column_hints))
      for iter410 in self.column_hints:
        iter410.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.column_hints is not None:
      value = pprint.pformat(self.column_hints, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_hints=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexSpec:
  """
  Attributes:
   - contexts
   - schema_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.contexts = []
          (_etype414, _size411) = iprot.readListBegin()
          if _size411 >= 0:
            for _i415 in range(_size411):
              _elem416 = IndexQueryContext()
              _elem416.read(iprot)
              self.contexts.append(_elem416)
          else: 
            while iprot.peekList():
              _elem417 = IndexQueryContext()
              _elem417.read(iprot)
              self.contexts.append(_elem417)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema_id = nebula2.common.ttypes.SchemaID()
          self.schema_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexSpec')
    if self.contexts != None:
      oprot.writeFieldBegin('contexts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.contexts))
      for iter418 in self.contexts:
        iter418.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_id != None:
      oprot.writeFieldBegin('schema_id', TType.STRUCT, 2)
      self.schema_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.contexts is not None:
      value = pprint.pformat(self.contexts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    contexts=%s' % (value))
    if self.schema_id is not None:
      value = pprint.pformat(self.schema_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LookupIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - return_columns
   - common
   - limit
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype422, _size419) = iprot.readListBegin()
          if _size419 >= 0:
            for _i423 in range(_size419):
              _elem424 = iprot.readI32()
              self.parts.append(_elem424)
          else: 
            while iprot.peekList():
              _elem425 = iprot.readI32()
              self.parts.append(_elem425)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype429, _size426) = iprot.readListBegin()
          if _size426 >= 0:
            for _i430 in range(_size426):
              _elem431 = iprot.readString()
              self.return_columns.append(_elem431)
          else: 
            while iprot.peekList():
              _elem432 = iprot.readString()
              self.return_columns.append(_elem432)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter433 in self.parts:
        oprot.writeI32(iter433)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter434 in self.return_columns:
        oprot.writeString(iter434)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 5)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 6)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LookupAndTraverseRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - traverse_spec
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype438, _size435) = iprot.readListBegin()
          if _size435 >= 0:
            for _i439 in range(_size435):
              _elem440 = iprot.readI32()
              self.parts.append(_elem440)
          else: 
            while iprot.peekList():
              _elem441 = iprot.readI32()
              self.parts.append(_elem441)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupAndTraverseRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter442 in self.parts:
        oprot.writeI32(iter442)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 5)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanCursor:
  """
  Attributes:
   - next_cursor
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.next_cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanCursor')
    if self.next_cursor != None:
      oprot.writeFieldBegin('next_cursor', TType.STRING, 1)
      oprot.writeString(self.next_cursor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.next_cursor is not None:
      value = pprint.pformat(self.next_cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    next_cursor=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanVertexRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_columns
   - limit
   - start_time
   - end_time
   - filter
   - only_latest_version
   - enable_read_from_follower
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype444, _vtype445, _size443 ) = iprot.readMapBegin() 
          if _size443 >= 0:
            for _i447 in range(_size443):
              _key448 = iprot.readI32()
              _val449 = ScanCursor()
              _val449.read(iprot)
              self.parts[_key448] = _val449
          else: 
            while iprot.peekMap():
              _key450 = iprot.readI32()
              _val451 = ScanCursor()
              _val451.read(iprot)
              self.parts[_key450] = _val451
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype455, _size452) = iprot.readListBegin()
          if _size452 >= 0:
            for _i456 in range(_size452):
              _elem457 = VertexProp()
              _elem457.read(iprot)
              self.return_columns.append(_elem457)
          else: 
            while iprot.peekList():
              _elem458 = VertexProp()
              _elem458.read(iprot)
              self.return_columns.append(_elem458)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.only_latest_version = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enable_read_from_follower = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.parts))
      for kiter459,viter460 in self.parts.items():
        oprot.writeI32(kiter459)
        viter460.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter461 in self.return_columns:
        iter461.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 5)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 6)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 7)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.only_latest_version != None:
      oprot.writeFieldBegin('only_latest_version', TType.BOOL, 8)
      oprot.writeBool(self.only_latest_version)
      oprot.writeFieldEnd()
    if self.enable_read_from_follower != None:
      oprot.writeFieldBegin('enable_read_from_follower', TType.BOOL, 9)
      oprot.writeBool(self.enable_read_from_follower)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 10)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.only_latest_version is not None:
      value = pprint.pformat(self.only_latest_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    only_latest_version=%s' % (value))
    if self.enable_read_from_follower is not None:
      value = pprint.pformat(self.enable_read_from_follower, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_read_from_follower=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanEdgeRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_columns
   - limit
   - start_time
   - end_time
   - filter
   - only_latest_version
   - enable_read_from_follower
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype463, _vtype464, _size462 ) = iprot.readMapBegin() 
          if _size462 >= 0:
            for _i466 in range(_size462):
              _key467 = iprot.readI32()
              _val468 = ScanCursor()
              _val468.read(iprot)
              self.parts[_key467] = _val468
          else: 
            while iprot.peekMap():
              _key469 = iprot.readI32()
              _val470 = ScanCursor()
              _val470.read(iprot)
              self.parts[_key469] = _val470
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype474, _size471) = iprot.readListBegin()
          if _size471 >= 0:
            for _i475 in range(_size471):
              _elem476 = EdgeProp()
              _elem476.read(iprot)
              self.return_columns.append(_elem476)
          else: 
            while iprot.peekList():
              _elem477 = EdgeProp()
              _elem477.read(iprot)
              self.return_columns.append(_elem477)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.only_latest_version = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enable_read_from_follower = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.parts))
      for kiter478,viter479 in self.parts.items():
        oprot.writeI32(kiter478)
        viter479.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter480 in self.return_columns:
        iter480.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 5)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 6)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 7)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.only_latest_version != None:
      oprot.writeFieldBegin('only_latest_version', TType.BOOL, 8)
      oprot.writeBool(self.only_latest_version)
      oprot.writeFieldEnd()
    if self.enable_read_from_follower != None:
      oprot.writeFieldBegin('enable_read_from_follower', TType.BOOL, 9)
      oprot.writeBool(self.enable_read_from_follower)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 10)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.only_latest_version is not None:
      value = pprint.pformat(self.only_latest_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    only_latest_version=%s' % (value))
    if self.enable_read_from_follower is not None:
      value = pprint.pformat(self.enable_read_from_follower, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_read_from_follower=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanResponse:
  """
  Attributes:
   - result
   - props
   - cursors
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.cursors = {}
          (_ktype482, _vtype483, _size481 ) = iprot.readMapBegin() 
          if _size481 >= 0:
            for _i485 in range(_size481):
              _key486 = iprot.readI32()
              _val487 = ScanCursor()
              _val487.read(iprot)
              self.cursors[_key486] = _val487
          else: 
            while iprot.peekMap():
              _key488 = iprot.readI32()
              _val489 = ScanCursor()
              _val489.read(iprot)
              self.cursors[_key488] = _val489
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    if self.cursors != None:
      oprot.writeFieldBegin('cursors', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.cursors))
      for kiter490,viter491 in self.cursors.items():
        oprot.writeI32(kiter490)
        viter491.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    if self.cursors is not None:
      value = pprint.pformat(self.cursors, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cursors=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TaskPara:
  """
  Attributes:
   - space_id
   - parts
   - task_specific_paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype495, _size492) = iprot.readListBegin()
          if _size492 >= 0:
            for _i496 in range(_size492):
              _elem497 = iprot.readI32()
              self.parts.append(_elem497)
          else: 
            while iprot.peekList():
              _elem498 = iprot.readI32()
              self.parts.append(_elem498)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.task_specific_paras = []
          (_etype502, _size499) = iprot.readListBegin()
          if _size499 >= 0:
            for _i503 in range(_size499):
              _elem504 = iprot.readString()
              self.task_specific_paras.append(_elem504)
          else: 
            while iprot.peekList():
              _elem505 = iprot.readString()
              self.task_specific_paras.append(_elem505)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TaskPara')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter506 in self.parts:
        oprot.writeI32(iter506)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.task_specific_paras != None:
      oprot.writeFieldBegin('task_specific_paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.task_specific_paras))
      for iter507 in self.task_specific_paras:
        oprot.writeString(iter507)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.task_specific_paras is not None:
      value = pprint.pformat(self.task_specific_paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_specific_paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVGetRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_partly
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype509, _vtype510, _size508 ) = iprot.readMapBegin() 
          if _size508 >= 0:
            for _i512 in range(_size508):
              _key513 = iprot.readI32()
              _val514 = []
              (_etype518, _size515) = iprot.readListBegin()
              if _size515 >= 0:
                for _i519 in range(_size515):
                  _elem520 = iprot.readString()
                  _val514.append(_elem520)
              else: 
                while iprot.peekList():
                  _elem521 = iprot.readString()
                  _val514.append(_elem521)
              iprot.readListEnd()
              self.parts[_key513] = _val514
          else: 
            while iprot.peekMap():
              _key522 = iprot.readI32()
              _val523 = []
              (_etype527, _size524) = iprot.readListBegin()
              if _size524 >= 0:
                for _i528 in range(_size524):
                  _elem529 = iprot.readString()
                  _val523.append(_elem529)
              else: 
                while iprot.peekList():
                  _elem530 = iprot.readString()
                  _val523.append(_elem530)
              iprot.readListEnd()
              self.parts[_key522] = _val523
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.return_partly = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter531,viter532 in self.parts.items():
        oprot.writeI32(kiter531)
        oprot.writeListBegin(TType.STRING, len(viter532))
        for iter533 in viter532:
          oprot.writeString(iter533)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_partly != None:
      oprot.writeFieldBegin('return_partly', TType.BOOL, 3)
      oprot.writeBool(self.return_partly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_partly is not None:
      value = pprint.pformat(self.return_partly, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_partly=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVGetResponse:
  """
  Attributes:
   - result
   - key_values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.key_values = {}
          (_ktype535, _vtype536, _size534 ) = iprot.readMapBegin() 
          if _size534 >= 0:
            for _i538 in range(_size534):
              _key539 = iprot.readString()
              _val540 = iprot.readString()
              self.key_values[_key539] = _val540
          else: 
            while iprot.peekMap():
              _key541 = iprot.readString()
              _val542 = iprot.readString()
              self.key_values[_key541] = _val542
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.key_values != None:
      oprot.writeFieldBegin('key_values', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.key_values))
      for kiter543,viter544 in self.key_values.items():
        oprot.writeString(kiter543)
        oprot.writeString(viter544)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.key_values is not None:
      value = pprint.pformat(self.key_values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key_values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVPutRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype546, _vtype547, _size545 ) = iprot.readMapBegin() 
          if _size545 >= 0:
            for _i549 in range(_size545):
              _key550 = iprot.readI32()
              _val551 = []
              (_etype555, _size552) = iprot.readListBegin()
              if _size552 >= 0:
                for _i556 in range(_size552):
                  _elem557 = nebula2.common.ttypes.KeyValue()
                  _elem557.read(iprot)
                  _val551.append(_elem557)
              else: 
                while iprot.peekList():
                  _elem558 = nebula2.common.ttypes.KeyValue()
                  _elem558.read(iprot)
                  _val551.append(_elem558)
              iprot.readListEnd()
              self.parts[_key550] = _val551
          else: 
            while iprot.peekMap():
              _key559 = iprot.readI32()
              _val560 = []
              (_etype564, _size561) = iprot.readListBegin()
              if _size561 >= 0:
                for _i565 in range(_size561):
                  _elem566 = nebula2.common.ttypes.KeyValue()
                  _elem566.read(iprot)
                  _val560.append(_elem566)
              else: 
                while iprot.peekList():
                  _elem567 = nebula2.common.ttypes.KeyValue()
                  _elem567.read(iprot)
                  _val560.append(_elem567)
              iprot.readListEnd()
              self.parts[_key559] = _val560
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVPutRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter568,viter569 in self.parts.items():
        oprot.writeI32(kiter568)
        oprot.writeListBegin(TType.STRUCT, len(viter569))
        for iter570 in viter569:
          iter570.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVRemoveRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype572, _vtype573, _size571 ) = iprot.readMapBegin() 
          if _size571 >= 0:
            for _i575 in range(_size571):
              _key576 = iprot.readI32()
              _val577 = []
              (_etype581, _size578) = iprot.readListBegin()
              if _size578 >= 0:
                for _i582 in range(_size578):
                  _elem583 = iprot.readString()
                  _val577.append(_elem583)
              else: 
                while iprot.peekList():
                  _elem584 = iprot.readString()
                  _val577.append(_elem584)
              iprot.readListEnd()
              self.parts[_key576] = _val577
          else: 
            while iprot.peekMap():
              _key585 = iprot.readI32()
              _val586 = []
              (_etype590, _size587) = iprot.readListBegin()
              if _size587 >= 0:
                for _i591 in range(_size587):
                  _elem592 = iprot.readString()
                  _val586.append(_elem592)
              else: 
                while iprot.peekList():
                  _elem593 = iprot.readString()
                  _val586.append(_elem593)
              iprot.readListEnd()
              self.parts[_key585] = _val586
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVRemoveRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter594,viter595 in self.parts.items():
        oprot.writeI32(kiter594)
        oprot.writeListBegin(TType.STRING, len(viter595))
        for iter596 in viter595:
          oprot.writeString(iter596)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AdminExecResp:
  """
  Attributes:
   - result
   - stats
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stats = nebula2.meta.ttypes.StatsItem()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminExecResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.stats != None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 2)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.stats is not None:
      value = pprint.pformat(self.stats, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stats=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TransLeaderReq:
  """
  Attributes:
   - space_id
   - part_id
   - new_leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_leader = nebula2.common.ttypes.HostAddr()
          self.new_leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TransLeaderReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.new_leader != None:
      oprot.writeFieldBegin('new_leader', TType.STRUCT, 3)
      self.new_leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.new_leader is not None:
      value = pprint.pformat(self.new_leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddPartReq:
  """
  Attributes:
   - space_id
   - part_id
   - as_learner
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.as_learner = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.peers = []
          (_etype600, _size597) = iprot.readListBegin()
          if _size597 >= 0:
            for _i601 in range(_size597):
              _elem602 = nebula2.common.ttypes.HostAddr()
              _elem602.read(iprot)
              self.peers.append(_elem602)
          else: 
            while iprot.peekList():
              _elem603 = nebula2.common.ttypes.HostAddr()
              _elem603.read(iprot)
              self.peers.append(_elem603)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddPartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.as_learner != None:
      oprot.writeFieldBegin('as_learner', TType.BOOL, 3)
      oprot.writeBool(self.as_learner)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter604 in self.peers:
        iter604.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.as_learner is not None:
      value = pprint.pformat(self.as_learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    as_learner=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddLearnerReq:
  """
  Attributes:
   - space_id
   - part_id
   - learner
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.learner = nebula2.common.ttypes.HostAddr()
          self.learner.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddLearnerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.learner != None:
      oprot.writeFieldBegin('learner', TType.STRUCT, 3)
      self.learner.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.learner is not None:
      value = pprint.pformat(self.learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    learner=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RemovePartReq:
  """
  Attributes:
   - space_id
   - part_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemovePartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class MemberChangeReq:
  """
  Attributes:
   - space_id
   - part_id
   - peer
   - add
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.peer = nebula2.common.ttypes.HostAddr()
          self.peer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.add = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MemberChangeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peer != None:
      oprot.writeFieldBegin('peer', TType.STRUCT, 3)
      self.peer.write(oprot)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BOOL, 4)
      oprot.writeBool(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peer is not None:
      value = pprint.pformat(self.peer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peer=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CatchUpDataReq:
  """
  Attributes:
   - space_id
   - part_id
   - target
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.target = nebula2.common.ttypes.HostAddr()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CatchUpDataReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.target != None:
      oprot.writeFieldBegin('target', TType.STRUCT, 3)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.target is not None:
      value = pprint.pformat(self.target, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    target=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetLeaderReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateCPRequest:
  """
  Attributes:
   - space_ids
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.space_ids = []
          (_etype608, _size605) = iprot.readListBegin()
          if _size605 >= 0:
            for _i609 in range(_size605):
              _elem610 = iprot.readI32()
              self.space_ids.append(_elem610)
          else: 
            while iprot.peekList():
              _elem611 = iprot.readI32()
              self.space_ids.append(_elem611)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPRequest')
    if self.space_ids != None:
      oprot.writeFieldBegin('space_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.space_ids))
      for iter612 in self.space_ids:
        oprot.writeI32(iter612)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_ids is not None:
      value = pprint.pformat(self.space_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_ids=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropCPRequest:
  """
  Attributes:
   - space_ids
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.space_ids = []
          (_etype616, _size613) = iprot.readListBegin()
          if _size613 >= 0:
            for _i617 in range(_size613):
              _elem618 = iprot.readI32()
              self.space_ids.append(_elem618)
          else: 
            while iprot.peekList():
              _elem619 = iprot.readI32()
              self.space_ids.append(_elem619)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropCPRequest')
    if self.space_ids != None:
      oprot.writeFieldBegin('space_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.space_ids))
      for iter620 in self.space_ids:
        oprot.writeI32(iter620)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_ids is not None:
      value = pprint.pformat(self.space_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_ids=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class BlockingSignRequest:
  """
  Attributes:
   - space_ids
   - sign
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.space_ids = []
          (_etype624, _size621) = iprot.readListBegin()
          if _size621 >= 0:
            for _i625 in range(_size621):
              _elem626 = iprot.readI32()
              self.space_ids.append(_elem626)
          else: 
            while iprot.peekList():
              _elem627 = iprot.readI32()
              self.space_ids.append(_elem627)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sign = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BlockingSignRequest')
    if self.space_ids != None:
      oprot.writeFieldBegin('space_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.space_ids))
      for iter628 in self.space_ids:
        oprot.writeI32(iter628)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sign != None:
      oprot.writeFieldBegin('sign', TType.I32, 2)
      oprot.writeI32(self.sign)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_ids is not None:
      value = pprint.pformat(self.space_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_ids=%s' % (value))
    if self.sign is not None:
      value = pprint.pformat(self.sign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sign=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetLeaderPartsResp:
  """
  Attributes:
   - result
   - leader_parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype630, _vtype631, _size629 ) = iprot.readMapBegin() 
          if _size629 >= 0:
            for _i633 in range(_size629):
              _key634 = iprot.readI32()
              _val635 = []
              (_etype639, _size636) = iprot.readListBegin()
              if _size636 >= 0:
                for _i640 in range(_size636):
                  _elem641 = iprot.readI32()
                  _val635.append(_elem641)
              else: 
                while iprot.peekList():
                  _elem642 = iprot.readI32()
                  _val635.append(_elem642)
              iprot.readListEnd()
              self.leader_parts[_key634] = _val635
          else: 
            while iprot.peekMap():
              _key643 = iprot.readI32()
              _val644 = []
              (_etype648, _size645) = iprot.readListBegin()
              if _size645 >= 0:
                for _i649 in range(_size645):
                  _elem650 = iprot.readI32()
                  _val644.append(_elem650)
              else: 
                while iprot.peekList():
                  _elem651 = iprot.readI32()
                  _val644.append(_elem651)
              iprot.readListEnd()
              self.leader_parts[_key643] = _val644
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderPartsResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_parts))
      for kiter652,viter653 in self.leader_parts.items():
        oprot.writeI32(kiter652)
        oprot.writeListBegin(TType.I32, len(viter653))
        for iter654 in viter653:
          oprot.writeI32(iter654)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CheckPeersReq:
  """
  Attributes:
   - space_id
   - part_id
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype658, _size655) = iprot.readListBegin()
          if _size655 >= 0:
            for _i659 in range(_size655):
              _elem660 = nebula2.common.ttypes.HostAddr()
              _elem660.read(iprot)
              self.peers.append(_elem660)
          else: 
            while iprot.peekList():
              _elem661 = nebula2.common.ttypes.HostAddr()
              _elem661.read(iprot)
              self.peers.append(_elem661)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckPeersReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter662 in self.peers:
        iter662.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RebuildIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - index_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype666, _size663) = iprot.readListBegin()
          if _size663 >= 0:
            for _i667 in range(_size663):
              _elem668 = iprot.readI32()
              self.parts.append(_elem668)
          else: 
            while iprot.peekList():
              _elem669 = iprot.readI32()
              self.parts.append(_elem669)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter670 in self.parts:
        oprot.writeI32(iter670)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 3)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateCPResp:
  """
  Attributes:
   - result
   - info
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.info = []
          (_etype674, _size671) = iprot.readListBegin()
          if _size671 >= 0:
            for _i675 in range(_size671):
              _elem676 = nebula2.common.ttypes.CheckpointInfo()
              _elem676.read(iprot)
              self.info.append(_elem676)
          else: 
            while iprot.peekList():
              _elem677 = nebula2.common.ttypes.CheckpointInfo()
              _elem677.read(iprot)
              self.info.append(_elem677)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.info != None:
      oprot.writeFieldBegin('info', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.info))
      for iter678 in self.info:
        iter678.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.info is not None:
      value = pprint.pformat(self.info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    info=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListClusterInfoResp:
  """
  Attributes:
   - result
   - dir
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dir = nebula2.common.ttypes.DirInfo()
          self.dir.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListClusterInfoResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.dir != None:
      oprot.writeFieldBegin('dir', TType.STRUCT, 2)
      self.dir.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.dir is not None:
      value = pprint.pformat(self.dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dir=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListClusterInfoReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListClusterInfoReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddAdminTaskRequest:
  """
  Attributes:
   - cmd
   - job_id
   - task_id
   - para
   - concurrency
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.para = TaskPara()
          self.para.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.concurrency = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddAdminTaskRequest')
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 1)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 2)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 3)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.para != None:
      oprot.writeFieldBegin('para', TType.STRUCT, 4)
      self.para.write(oprot)
      oprot.writeFieldEnd()
    if self.concurrency != None:
      oprot.writeFieldBegin('concurrency', TType.I32, 5)
      oprot.writeI32(self.concurrency)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.para is not None:
      value = pprint.pformat(self.para, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    para=%s' % (value))
    if self.concurrency is not None:
      value = pprint.pformat(self.concurrency, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    concurrency=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StopAdminTaskRequest:
  """
  Attributes:
   - job_id
   - task_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StopAdminTaskRequest')
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 1)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 2)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class InternalTxnRequest:
  """
  Attributes:
   - txn_id
   - term_of_parts
   - add_edge_req
   - upd_edge_req
   - edge_ver
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.term_of_parts = {}
          (_ktype680, _vtype681, _size679 ) = iprot.readMapBegin() 
          if _size679 >= 0:
            for _i683 in range(_size679):
              _key684 = iprot.readI32()
              _val685 = iprot.readI64()
              self.term_of_parts[_key684] = _val685
          else: 
            while iprot.peekMap():
              _key686 = iprot.readI32()
              _val687 = iprot.readI64()
              self.term_of_parts[_key686] = _val687
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.add_edge_req = AddEdgesRequest()
          self.add_edge_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.upd_edge_req = UpdateEdgeRequest()
          self.upd_edge_req.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.edge_ver = {}
          (_ktype689, _vtype690, _size688 ) = iprot.readMapBegin() 
          if _size688 >= 0:
            for _i692 in range(_size688):
              _key693 = iprot.readI32()
              _val694 = []
              (_etype698, _size695) = iprot.readListBegin()
              if _size695 >= 0:
                for _i699 in range(_size695):
                  _elem700 = iprot.readI64()
                  _val694.append(_elem700)
              else: 
                while iprot.peekList():
                  _elem701 = iprot.readI64()
                  _val694.append(_elem701)
              iprot.readListEnd()
              self.edge_ver[_key693] = _val694
          else: 
            while iprot.peekMap():
              _key702 = iprot.readI32()
              _val703 = []
              (_etype707, _size704) = iprot.readListBegin()
              if _size704 >= 0:
                for _i708 in range(_size704):
                  _elem709 = iprot.readI64()
                  _val703.append(_elem709)
              else: 
                while iprot.peekList():
                  _elem710 = iprot.readI64()
                  _val703.append(_elem710)
              iprot.readListEnd()
              self.edge_ver[_key702] = _val703
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InternalTxnRequest')
    if self.txn_id != None:
      oprot.writeFieldBegin('txn_id', TType.I64, 1)
      oprot.writeI64(self.txn_id)
      oprot.writeFieldEnd()
    if self.term_of_parts != None:
      oprot.writeFieldBegin('term_of_parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.I64, len(self.term_of_parts))
      for kiter711,viter712 in self.term_of_parts.items():
        oprot.writeI32(kiter711)
        oprot.writeI64(viter712)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add_edge_req != None:
      oprot.writeFieldBegin('add_edge_req', TType.STRUCT, 3)
      self.add_edge_req.write(oprot)
      oprot.writeFieldEnd()
    if self.upd_edge_req != None:
      oprot.writeFieldBegin('upd_edge_req', TType.STRUCT, 4)
      self.upd_edge_req.write(oprot)
      oprot.writeFieldEnd()
    if self.edge_ver != None:
      oprot.writeFieldBegin('edge_ver', TType.MAP, 5)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.edge_ver))
      for kiter713,viter714 in self.edge_ver.items():
        oprot.writeI32(kiter713)
        oprot.writeListBegin(TType.I64, len(viter714))
        for iter715 in viter714:
          oprot.writeI64(iter715)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.txn_id is not None:
      value = pprint.pformat(self.txn_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    txn_id=%s' % (value))
    if self.term_of_parts is not None:
      value = pprint.pformat(self.term_of_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term_of_parts=%s' % (value))
    if self.add_edge_req is not None:
      value = pprint.pformat(self.add_edge_req, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add_edge_req=%s' % (value))
    if self.upd_edge_req is not None:
      value = pprint.pformat(self.upd_edge_req, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    upd_edge_req=%s' % (value))
    if self.edge_ver is not None:
      value = pprint.pformat(self.edge_ver, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_ver=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ChainAddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - if_not_exists
   - term
   - edge_version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype717, _vtype718, _size716 ) = iprot.readMapBegin() 
          if _size716 >= 0:
            for _i720 in range(_size716):
              _key721 = iprot.readI32()
              _val722 = []
              (_etype726, _size723) = iprot.readListBegin()
              if _size723 >= 0:
                for _i727 in range(_size723):
                  _elem728 = NewEdge()
                  _elem728.read(iprot)
                  _val722.append(_elem728)
              else: 
                while iprot.peekList():
                  _elem729 = NewEdge()
                  _elem729.read(iprot)
                  _val722.append(_elem729)
              iprot.readListEnd()
              self.parts[_key721] = _val722
          else: 
            while iprot.peekMap():
              _key730 = iprot.readI32()
              _val731 = []
              (_etype735, _size732) = iprot.readListBegin()
              if _size732 >= 0:
                for _i736 in range(_size732):
                  _elem737 = NewEdge()
                  _elem737.read(iprot)
                  _val731.append(_elem737)
              else: 
                while iprot.peekList():
                  _elem738 = NewEdge()
                  _elem738.read(iprot)
                  _val731.append(_elem738)
              iprot.readListEnd()
              self.parts[_key730] = _val731
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prop_names = []
          (_etype742, _size739) = iprot.readListBegin()
          if _size739 >= 0:
            for _i743 in range(_size739):
              _elem744 = iprot.readString()
              self.prop_names.append(_elem744)
          else: 
            while iprot.peekList():
              _elem745 = iprot.readString()
              self.prop_names.append(_elem745)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.edge_version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChainAddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter746,viter747 in self.parts.items():
        oprot.writeI32(kiter746)
        oprot.writeListBegin(TType.STRUCT, len(viter747))
        for iter748 in viter747:
          iter748.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.prop_names))
      for iter749 in self.prop_names:
        oprot.writeString(iter749)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 5)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    if self.edge_version != None:
      oprot.writeFieldBegin('edge_version', TType.I64, 6)
      oprot.writeI64(self.edge_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    if self.edge_version is not None:
      value = pprint.pformat(self.edge_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ChainUpdateEdgeRequest:
  """
  Attributes:
   - update_edge_request
   - term
   - edge_version
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.update_edge_request = UpdateEdgeRequest()
          self.update_edge_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.edge_version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.parts = []
          (_etype753, _size750) = iprot.readListBegin()
          if _size750 >= 0:
            for _i754 in range(_size750):
              _elem755 = iprot.readI32()
              self.parts.append(_elem755)
          else: 
            while iprot.peekList():
              _elem756 = iprot.readI32()
              self.parts.append(_elem756)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChainUpdateEdgeRequest')
    if self.update_edge_request != None:
      oprot.writeFieldBegin('update_edge_request', TType.STRUCT, 1)
      self.update_edge_request.write(oprot)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 2)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    if self.edge_version != None:
      oprot.writeFieldBegin('edge_version', TType.I64, 3)
      oprot.writeI64(self.edge_version)
      oprot.writeFieldEnd()
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 4)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter757 in self.parts:
        oprot.writeI32(iter757)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.update_edge_request is not None:
      value = pprint.pformat(self.update_edge_request, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    update_edge_request=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    if self.edge_version is not None:
      value = pprint.pformat(self.edge_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_version=%s' % (value))
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(RequestCommon)
RequestCommon.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 1, ), # 1
  (2, TType.I64, 'plan_id', None, None, 1, ), # 2
  (3, TType.BOOL, 'profile_detail', None, None, 1, ), # 3
)

RequestCommon.thrift_struct_annotations = {
}
RequestCommon.thrift_field_annotations = {
}

def RequestCommon__init__(self, session_id=None, plan_id=None, profile_detail=None,):
  self.session_id = session_id
  self.plan_id = plan_id
  self.profile_detail = profile_detail

RequestCommon.__init__ = RequestCommon__init__

def RequestCommon__setstate__(self, state):
  state.setdefault('session_id', None)
  state.setdefault('plan_id', None)
  state.setdefault('profile_detail', None)
  self.__dict__ = state

RequestCommon.__getstate__ = lambda self: self.__dict__.copy()
RequestCommon.__setstate__ = RequestCommon__setstate__

all_structs.append(PartitionResult)
PartitionResult.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula2.common.ttypes.ErrorCode, None, 0, ), # 1
  (2, TType.I32, 'part_id', None, None, 0, ), # 2
  (3, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 3
)

PartitionResult.thrift_struct_annotations = {
}
PartitionResult.thrift_field_annotations = {
}

def PartitionResult__init__(self, code=None, part_id=None, leader=None,):
  self.code = code
  self.part_id = part_id
  self.leader = leader

PartitionResult.__init__ = PartitionResult__init__

def PartitionResult__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

PartitionResult.__getstate__ = lambda self: self.__dict__.copy()
PartitionResult.__setstate__ = PartitionResult__setstate__

all_structs.append(ResponseCommon)
ResponseCommon.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'failed_parts', (TType.STRUCT,[PartitionResult, PartitionResult.thrift_spec, False]), None, 0, ), # 1
  (2, TType.I64, 'latency_in_us', None, None, 0, ), # 2
  (3, TType.MAP, 'latency_detail_us', (TType.STRING,True,TType.I32,None), None, 1, ), # 3
)

ResponseCommon.thrift_struct_annotations = {
}
ResponseCommon.thrift_field_annotations = {
}

def ResponseCommon__init__(self, failed_parts=None, latency_in_us=None, latency_detail_us=None,):
  self.failed_parts = failed_parts
  self.latency_in_us = latency_in_us
  self.latency_detail_us = latency_detail_us

ResponseCommon.__init__ = ResponseCommon__init__

def ResponseCommon__setstate__(self, state):
  state.setdefault('failed_parts', None)
  state.setdefault('latency_in_us', None)
  state.setdefault('latency_detail_us', None)
  self.__dict__ = state

ResponseCommon.__getstate__ = lambda self: self.__dict__.copy()
ResponseCommon.__setstate__ = ResponseCommon__setstate__

all_structs.append(StatProp)
StatProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'prop', False, None, 2, ), # 2
  (3, TType.I32, 'stat', StatType, None, 2, ), # 3
)

StatProp.thrift_struct_annotations = {
}
StatProp.thrift_field_annotations = {
}

def StatProp__init__(self, alias=None, prop=None, stat=None,):
  self.alias = alias
  self.prop = prop
  self.stat = stat

StatProp.__init__ = StatProp__init__

def StatProp__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('prop', None)
  state.setdefault('stat', None)
  self.__dict__ = state

StatProp.__getstate__ = lambda self: self.__dict__.copy()
StatProp.__setstate__ = StatProp__setstate__

all_structs.append(Expr)
Expr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'expr', False, None, 2, ), # 2
)

Expr.thrift_struct_annotations = {
}
Expr.thrift_field_annotations = {
}

def Expr__init__(self, alias=None, expr=None,):
  self.alias = alias
  self.expr = expr

Expr.__init__ = Expr__init__

def Expr__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('expr', None)
  self.__dict__ = state

Expr.__getstate__ = lambda self: self.__dict__.copy()
Expr.__setstate__ = Expr__setstate__

all_structs.append(EdgeProp)
EdgeProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

EdgeProp.thrift_struct_annotations = {
}
EdgeProp.thrift_field_annotations = {
}

def EdgeProp__init__(self, type=None, props=None,):
  self.type = type
  self.props = props

EdgeProp.__init__ = EdgeProp__init__

def EdgeProp__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('props', None)
  self.__dict__ = state

EdgeProp.__getstate__ = lambda self: self.__dict__.copy()
EdgeProp.__setstate__ = EdgeProp__setstate__

all_structs.append(VertexProp)
VertexProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

VertexProp.thrift_struct_annotations = {
}
VertexProp.thrift_field_annotations = {
}

def VertexProp__init__(self, tag=None, props=None,):
  self.tag = tag
  self.props = props

VertexProp.__init__ = VertexProp__init__

def VertexProp__setstate__(self, state):
  state.setdefault('tag', None)
  state.setdefault('props', None)
  self.__dict__ = state

VertexProp.__getstate__ = lambda self: self.__dict__.copy()
VertexProp.__setstate__ = VertexProp__setstate__

all_structs.append(OrderBy)
OrderBy.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'prop', False, None, 2, ), # 1
  (2, TType.I32, 'direction', OrderDirection, None, 2, ), # 2
)

OrderBy.thrift_struct_annotations = {
}
OrderBy.thrift_field_annotations = {
}

def OrderBy__init__(self, prop=None, direction=None,):
  self.prop = prop
  self.direction = direction

OrderBy.__init__ = OrderBy__init__

def OrderBy__setstate__(self, state):
  state.setdefault('prop', None)
  state.setdefault('direction', None)
  self.__dict__ = state

OrderBy.__getstate__ = lambda self: self.__dict__.copy()
OrderBy.__setstate__ = OrderBy__setstate__

all_structs.append(TraverseSpec)
TraverseSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'edge_types', (TType.I32,None), None, 2, ), # 1
  (2, TType.I32, 'edge_direction', EdgeDirection,   1, 2, ), # 2
  (3, TType.BOOL, 'dedup', None, False, 2, ), # 3
  (4, TType.LIST, 'stat_props', (TType.STRUCT,[StatProp, StatProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 5
  (6, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 6
  (7, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 7
  (8, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 8
  (9, TType.BOOL, 'random', None, None, 1, ), # 9
  (10, TType.I64, 'limit', None, None, 1, ), # 10
  (11, TType.STRING, 'filter', False, None, 1, ), # 11
)

TraverseSpec.thrift_struct_annotations = {
}
TraverseSpec.thrift_field_annotations = {
}

def TraverseSpec__init__(self, edge_types=None, edge_direction=TraverseSpec.thrift_spec[2][4], dedup=TraverseSpec.thrift_spec[3][4], stat_props=None, vertex_props=None, edge_props=None, expressions=None, order_by=None, random=None, limit=None, filter=None,):
  self.edge_types = edge_types
  self.edge_direction = edge_direction
  self.dedup = dedup
  self.stat_props = stat_props
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.order_by = order_by
  self.random = random
  self.limit = limit
  self.filter = filter

TraverseSpec.__init__ = TraverseSpec__init__

def TraverseSpec__setstate__(self, state):
  state.setdefault('edge_types', None)
  state.setdefault('edge_direction',   1)
  state.setdefault('dedup', False)
  state.setdefault('stat_props', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('order_by', None)
  state.setdefault('random', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  self.__dict__ = state

TraverseSpec.__getstate__ = lambda self: self.__dict__.copy()
TraverseSpec.__setstate__ = TraverseSpec__setstate__

all_structs.append(GetNeighborsRequest)
GetNeighborsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Row, nebula2.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 5
)

GetNeighborsRequest.thrift_struct_annotations = {
}
GetNeighborsRequest.thrift_field_annotations = {
}

def GetNeighborsRequest__init__(self, space_id=None, column_names=None, parts=None, traverse_spec=None, common=None,):
  self.space_id = space_id
  self.column_names = column_names
  self.parts = parts
  self.traverse_spec = traverse_spec
  self.common = common

GetNeighborsRequest.__init__ = GetNeighborsRequest__init__

def GetNeighborsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('column_names', None)
  state.setdefault('parts', None)
  state.setdefault('traverse_spec', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetNeighborsRequest.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsRequest.__setstate__ = GetNeighborsRequest__setstate__

all_structs.append(GetNeighborsResponse)
GetNeighborsResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'vertices', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetNeighborsResponse.thrift_struct_annotations = {
}
GetNeighborsResponse.thrift_field_annotations = {
}

def GetNeighborsResponse__init__(self, result=None, vertices=None,):
  self.result = result
  self.vertices = vertices

GetNeighborsResponse.__init__ = GetNeighborsResponse__init__

def GetNeighborsResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertices', None)
  self.__dict__ = state

GetNeighborsResponse.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsResponse.__setstate__ = GetNeighborsResponse__setstate__

all_structs.append(ExecResponse)
ExecResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

ExecResponse.thrift_struct_annotations = {
}
ExecResponse.thrift_field_annotations = {
}

def ExecResponse__init__(self, result=None,):
  self.result = result

ExecResponse.__init__ = ExecResponse__init__

def ExecResponse__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

ExecResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecResponse.__setstate__ = ExecResponse__setstate__

all_structs.append(GetPropRequest)
GetPropRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Row, nebula2.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 3
  (4, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 5
  (6, TType.BOOL, 'dedup', None, False, 2, ), # 6
  (7, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 7
  (8, TType.I64, 'limit', None, None, 1, ), # 8
  (9, TType.STRING, 'filter', False, None, 1, ), # 9
  (10, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 10
)

GetPropRequest.thrift_struct_annotations = {
}
GetPropRequest.thrift_field_annotations = {
}

def GetPropRequest__init__(self, space_id=None, parts=None, vertex_props=None, edge_props=None, expressions=None, dedup=GetPropRequest.thrift_spec[6][4], order_by=None, limit=None, filter=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.dedup = dedup
  self.order_by = order_by
  self.limit = limit
  self.filter = filter
  self.common = common

GetPropRequest.__init__ = GetPropRequest__init__

def GetPropRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('dedup', False)
  state.setdefault('order_by', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetPropRequest.__getstate__ = lambda self: self.__dict__.copy()
GetPropRequest.__setstate__ = GetPropRequest__setstate__

all_structs.append(GetPropResponse)
GetPropResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetPropResponse.thrift_struct_annotations = {
}
GetPropResponse.thrift_field_annotations = {
}

def GetPropResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

GetPropResponse.__init__ = GetPropResponse__init__

def GetPropResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

GetPropResponse.__getstate__ = lambda self: self.__dict__.copy()
GetPropResponse.__setstate__ = GetPropResponse__setstate__

all_structs.append(NewTag)
NewTag.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewTag.thrift_struct_annotations = {
}
NewTag.thrift_field_annotations = {
}

def NewTag__init__(self, tag_id=None, props=None,):
  self.tag_id = tag_id
  self.props = props

NewTag.__init__ = NewTag__init__

def NewTag__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewTag.__getstate__ = lambda self: self.__dict__.copy()
NewTag.__setstate__ = NewTag__setstate__

all_structs.append(NewVertex)
NewVertex.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[NewTag, NewTag.thrift_spec, False]), None, 2, ), # 2
)

NewVertex.thrift_struct_annotations = {
}
NewVertex.thrift_field_annotations = {
}

def NewVertex__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

NewVertex.__init__ = NewVertex__init__

def NewVertex__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

NewVertex.__getstate__ = lambda self: self.__dict__.copy()
NewVertex.__setstate__ = NewVertex__setstate__

all_structs.append(EdgeKey)
EdgeKey.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
  (3, TType.I64, 'ranking', None, None, 2, ), # 3
  (4, TType.STRUCT, 'dst', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

EdgeKey.thrift_struct_annotations = {
}
EdgeKey.thrift_field_annotations = {
}

def EdgeKey__init__(self, src=None, edge_type=None, ranking=None, dst=None,):
  self.src = src
  self.edge_type = edge_type
  self.ranking = ranking
  self.dst = dst

EdgeKey.__init__ = EdgeKey__init__

def EdgeKey__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('edge_type', None)
  state.setdefault('ranking', None)
  state.setdefault('dst', None)
  self.__dict__ = state

EdgeKey.__getstate__ = lambda self: self.__dict__.copy()
EdgeKey.__setstate__ = EdgeKey__setstate__

all_structs.append(NewEdge)
NewEdge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewEdge.thrift_struct_annotations = {
}
NewEdge.thrift_field_annotations = {
}

def NewEdge__init__(self, key=None, props=None,):
  self.key = key
  self.props = props

NewEdge.__init__ = NewEdge__init__

def NewEdge__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewEdge.__getstate__ = lambda self: self.__dict__.copy()
NewEdge.__setstate__ = NewEdge__setstate__

all_structs.append(AddVerticesRequest)
AddVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewVertex, NewVertex.thrift_spec, False])), None, 2, ), # 2
  (3, TType.MAP, 'prop_names', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
  (5, TType.BOOL, 'ignore_existed_index', None, False, 2, ), # 5
  (6, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 6
)

AddVerticesRequest.thrift_struct_annotations = {
}
AddVerticesRequest.thrift_field_annotations = {
}

def AddVerticesRequest__init__(self, space_id=None, parts=None, prop_names=None, if_not_exists=None, ignore_existed_index=AddVerticesRequest.thrift_spec[5][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.if_not_exists = if_not_exists
  self.ignore_existed_index = ignore_existed_index
  self.common = common

AddVerticesRequest.__init__ = AddVerticesRequest__init__

def AddVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('ignore_existed_index', False)
  state.setdefault('common', None)
  self.__dict__ = state

AddVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddVerticesRequest.__setstate__ = AddVerticesRequest__setstate__

all_structs.append(AddEdgesRequest)
AddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewEdge, NewEdge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'prop_names', (TType.STRING,False), None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
  (5, TType.BOOL, 'ignore_existed_index', None, False, 2, ), # 5
  (6, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 6
)

AddEdgesRequest.thrift_struct_annotations = {
}
AddEdgesRequest.thrift_field_annotations = {
}

def AddEdgesRequest__init__(self, space_id=None, parts=None, prop_names=None, if_not_exists=None, ignore_existed_index=AddEdgesRequest.thrift_spec[5][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.if_not_exists = if_not_exists
  self.ignore_existed_index = ignore_existed_index
  self.common = common

AddEdgesRequest.__init__ = AddEdgesRequest__init__

def AddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('ignore_existed_index', False)
  state.setdefault('common', None)
  self.__dict__ = state

AddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddEdgesRequest.__setstate__ = AddEdgesRequest__setstate__

all_structs.append(DeleteVerticesRequest)
DeleteVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True])), None, 2, ), # 2
  (3, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 3
)

DeleteVerticesRequest.thrift_struct_annotations = {
}
DeleteVerticesRequest.thrift_field_annotations = {
}

def DeleteVerticesRequest__init__(self, space_id=None, parts=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.common = common

DeleteVerticesRequest.__init__ = DeleteVerticesRequest__init__

def DeleteVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('common', None)
  self.__dict__ = state

DeleteVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteVerticesRequest.__setstate__ = DeleteVerticesRequest__setstate__

all_structs.append(DeleteEdgesRequest)
DeleteEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
  (3, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 3
)

DeleteEdgesRequest.thrift_struct_annotations = {
}
DeleteEdgesRequest.thrift_field_annotations = {
}

def DeleteEdgesRequest__init__(self, space_id=None, parts=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.common = common

DeleteEdgesRequest.__init__ = DeleteEdgesRequest__init__

def DeleteEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('common', None)
  self.__dict__ = state

DeleteEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteEdgesRequest.__setstate__ = DeleteEdgesRequest__setstate__

all_structs.append(DelTags)
DelTags.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.I32,None), None, 2, ), # 2
)

DelTags.thrift_struct_annotations = {
}
DelTags.thrift_field_annotations = {
}

def DelTags__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

DelTags.__init__ = DelTags__init__

def DelTags__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

DelTags.__getstate__ = lambda self: self.__dict__.copy()
DelTags.__setstate__ = DelTags__setstate__

all_structs.append(DeleteTagsRequest)
DeleteTagsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[DelTags, DelTags.thrift_spec, False])), None, 2, ), # 2
  (3, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 3
)

DeleteTagsRequest.thrift_struct_annotations = {
}
DeleteTagsRequest.thrift_field_annotations = {
}

def DeleteTagsRequest__init__(self, space_id=None, parts=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.common = common

DeleteTagsRequest.__init__ = DeleteTagsRequest__init__

def DeleteTagsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('common', None)
  self.__dict__ = state

DeleteTagsRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteTagsRequest.__setstate__ = DeleteTagsRequest__setstate__

all_structs.append(UpdateResponse)
UpdateResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

UpdateResponse.thrift_struct_annotations = {
}
UpdateResponse.thrift_field_annotations = {
}

def UpdateResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

UpdateResponse.__init__ = UpdateResponse__init__

def UpdateResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

UpdateResponse.__getstate__ = lambda self: self.__dict__.copy()
UpdateResponse.__setstate__ = UpdateResponse__setstate__

all_structs.append(UpdatedProp)
UpdatedProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRING, 'value', False, None, 0, ), # 2
)

UpdatedProp.thrift_struct_annotations = {
}
UpdatedProp.thrift_field_annotations = {
}

def UpdatedProp__init__(self, name=None, value=None,):
  self.name = name
  self.value = value

UpdatedProp.__init__ = UpdatedProp__init__

def UpdatedProp__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('value', None)
  self.__dict__ = state

UpdatedProp.__getstate__ = lambda self: self.__dict__.copy()
UpdatedProp.__setstate__ = UpdatedProp__setstate__

all_structs.append(UpdateVertexRequest)
UpdateVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'vertex_id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.I32, 'tag_id', None, None, 0, ), # 4
  (5, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 5
  (6, TType.BOOL, 'insertable', None, False, 1, ), # 6
  (7, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 7
  (8, TType.STRING, 'condition', False, None, 1, ), # 8
  (9, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 9
)

UpdateVertexRequest.thrift_struct_annotations = {
}
UpdateVertexRequest.thrift_field_annotations = {
}

def UpdateVertexRequest__init__(self, space_id=None, part_id=None, vertex_id=None, tag_id=None, updated_props=None, insertable=UpdateVertexRequest.thrift_spec[6][4], return_props=None, condition=None, common=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.vertex_id = vertex_id
  self.tag_id = tag_id
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition
  self.common = common

UpdateVertexRequest.__init__ = UpdateVertexRequest__init__

def UpdateVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('vertex_id', None)
  state.setdefault('tag_id', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  state.setdefault('common', None)
  self.__dict__ = state

UpdateVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateVertexRequest.__setstate__ = UpdateVertexRequest__setstate__

all_structs.append(UpdateEdgeRequest)
UpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'edge_key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'insertable', None, False, 1, ), # 5
  (6, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 6
  (7, TType.STRING, 'condition', False, None, 1, ), # 7
  (8, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 8
)

UpdateEdgeRequest.thrift_struct_annotations = {
}
UpdateEdgeRequest.thrift_field_annotations = {
}

def UpdateEdgeRequest__init__(self, space_id=None, part_id=None, edge_key=None, updated_props=None, insertable=UpdateEdgeRequest.thrift_spec[5][4], return_props=None, condition=None, common=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.edge_key = edge_key
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition
  self.common = common

UpdateEdgeRequest.__init__ = UpdateEdgeRequest__init__

def UpdateEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('edge_key', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  state.setdefault('common', None)
  self.__dict__ = state

UpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateEdgeRequest.__setstate__ = UpdateEdgeRequest__setstate__

all_structs.append(GetUUIDReq)
GetUUIDReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
  (4, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 4
)

GetUUIDReq.thrift_struct_annotations = {
}
GetUUIDReq.thrift_field_annotations = {
}

def GetUUIDReq__init__(self, space_id=None, part_id=None, name=None, common=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.name = name
  self.common = common

GetUUIDReq.__init__ = GetUUIDReq__init__

def GetUUIDReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('name', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetUUIDReq.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDReq.__setstate__ = GetUUIDReq__setstate__

all_structs.append(GetUUIDResp)
GetUUIDResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 2
)

GetUUIDResp.thrift_struct_annotations = {
}
GetUUIDResp.thrift_field_annotations = {
}

def GetUUIDResp__init__(self, result=None, id=None,):
  self.result = result
  self.id = id

GetUUIDResp.__init__ = GetUUIDResp__init__

def GetUUIDResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('id', None)
  self.__dict__ = state

GetUUIDResp.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDResp.__setstate__ = GetUUIDResp__setstate__

all_structs.append(LookupIndexResp)
LookupIndexResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'data', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

LookupIndexResp.thrift_struct_annotations = {
}
LookupIndexResp.thrift_field_annotations = {
}

def LookupIndexResp__init__(self, result=None, data=None,):
  self.result = result
  self.data = data

LookupIndexResp.__init__ = LookupIndexResp__init__

def LookupIndexResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('data', None)
  self.__dict__ = state

LookupIndexResp.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexResp.__setstate__ = LookupIndexResp__setstate__

all_structs.append(IndexColumnHint)
IndexColumnHint.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'column_name', False, None, 2, ), # 1
  (2, TType.I32, 'scan_type', ScanType, None, 2, ), # 2
  (3, TType.STRUCT, 'begin_value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.STRUCT, 'end_value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
  (5, TType.BOOL, 'include_begin', None, True, 2, ), # 5
  (6, TType.BOOL, 'include_end', None, False, 2, ), # 6
)

IndexColumnHint.thrift_struct_annotations = {
}
IndexColumnHint.thrift_field_annotations = {
}

def IndexColumnHint__init__(self, column_name=None, scan_type=None, begin_value=None, end_value=None, include_begin=IndexColumnHint.thrift_spec[5][4], include_end=IndexColumnHint.thrift_spec[6][4],):
  self.column_name = column_name
  self.scan_type = scan_type
  self.begin_value = begin_value
  self.end_value = end_value
  self.include_begin = include_begin
  self.include_end = include_end

IndexColumnHint.__init__ = IndexColumnHint__init__

def IndexColumnHint__setstate__(self, state):
  state.setdefault('column_name', None)
  state.setdefault('scan_type', None)
  state.setdefault('begin_value', None)
  state.setdefault('end_value', None)
  state.setdefault('include_begin', True)
  state.setdefault('include_end', False)
  self.__dict__ = state

IndexColumnHint.__getstate__ = lambda self: self.__dict__.copy()
IndexColumnHint.__setstate__ = IndexColumnHint__setstate__

all_structs.append(IndexQueryContext)
IndexQueryContext.thrift_spec = (
  None, # 0
  (1, TType.I32, 'index_id', None, None, 2, ), # 1
  (2, TType.STRING, 'filter', False, None, 2, ), # 2
  (3, TType.LIST, 'column_hints', (TType.STRUCT,[IndexColumnHint, IndexColumnHint.thrift_spec, False]), None, 2, ), # 3
)

IndexQueryContext.thrift_struct_annotations = {
}
IndexQueryContext.thrift_field_annotations = {
}

def IndexQueryContext__init__(self, index_id=None, filter=None, column_hints=None,):
  self.index_id = index_id
  self.filter = filter
  self.column_hints = column_hints

IndexQueryContext.__init__ = IndexQueryContext__init__

def IndexQueryContext__setstate__(self, state):
  state.setdefault('index_id', None)
  state.setdefault('filter', None)
  state.setdefault('column_hints', None)
  self.__dict__ = state

IndexQueryContext.__getstate__ = lambda self: self.__dict__.copy()
IndexQueryContext.__setstate__ = IndexQueryContext__setstate__

all_structs.append(IndexSpec)
IndexSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'contexts', (TType.STRUCT,[IndexQueryContext, IndexQueryContext.thrift_spec, False]), None, 0, ), # 1
  (2, TType.STRUCT, 'schema_id', [nebula2.common.ttypes.SchemaID, nebula2.common.ttypes.SchemaID.thrift_spec, True], None, 2, ), # 2
)

IndexSpec.thrift_struct_annotations = {
}
IndexSpec.thrift_field_annotations = {
}

def IndexSpec__init__(self, contexts=None, schema_id=None,):
  self.contexts = contexts
  self.schema_id = schema_id

IndexSpec.__init__ = IndexSpec__init__

def IndexSpec__setstate__(self, state):
  state.setdefault('contexts', None)
  state.setdefault('schema_id', None)
  self.__dict__ = state

IndexSpec.__getstate__ = lambda self: self.__dict__.copy()
IndexSpec.__setstate__ = IndexSpec__setstate__

all_structs.append(LookupIndexRequest)
LookupIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'return_columns', (TType.STRING,False), None, 1, ), # 4
  (5, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 5
  (6, TType.I64, 'limit', None, None, 1, ), # 6
)

LookupIndexRequest.thrift_struct_annotations = {
}
LookupIndexRequest.thrift_field_annotations = {
}

def LookupIndexRequest__init__(self, space_id=None, parts=None, indices=None, return_columns=None, common=None, limit=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.return_columns = return_columns
  self.common = common
  self.limit = limit

LookupIndexRequest.__init__ = LookupIndexRequest__init__

def LookupIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('return_columns', None)
  state.setdefault('common', None)
  state.setdefault('limit', None)
  self.__dict__ = state

LookupIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexRequest.__setstate__ = LookupIndexRequest__setstate__

all_structs.append(LookupAndTraverseRequest)
LookupAndTraverseRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 5
)

LookupAndTraverseRequest.thrift_struct_annotations = {
}
LookupAndTraverseRequest.thrift_field_annotations = {
}

def LookupAndTraverseRequest__init__(self, space_id=None, parts=None, indices=None, traverse_spec=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.traverse_spec = traverse_spec
  self.common = common

LookupAndTraverseRequest.__init__ = LookupAndTraverseRequest__init__

def LookupAndTraverseRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('traverse_spec', None)
  state.setdefault('common', None)
  self.__dict__ = state

LookupAndTraverseRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupAndTraverseRequest.__setstate__ = LookupAndTraverseRequest__setstate__

all_structs.append(ScanCursor)
ScanCursor.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'next_cursor', False, None, 1, ), # 1
)

ScanCursor.thrift_struct_annotations = {
}
ScanCursor.thrift_field_annotations = {
}

def ScanCursor__init__(self, next_cursor=None,):
  self.next_cursor = next_cursor

ScanCursor.__init__ = ScanCursor__init__

def ScanCursor__setstate__(self, state):
  state.setdefault('next_cursor', None)
  self.__dict__ = state

ScanCursor.__getstate__ = lambda self: self.__dict__.copy()
ScanCursor.__setstate__ = ScanCursor__setstate__

all_structs.append(ScanVertexRequest)
ScanVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRUCT,[ScanCursor, ScanCursor.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'return_columns', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 2, ), # 3
  (4, TType.I64, 'limit', None, None, 2, ), # 4
  (5, TType.I64, 'start_time', None, None, 1, ), # 5
  (6, TType.I64, 'end_time', None, None, 1, ), # 6
  (7, TType.STRING, 'filter', False, None, 1, ), # 7
  (8, TType.BOOL, 'only_latest_version', None, False, 2, ), # 8
  (9, TType.BOOL, 'enable_read_from_follower', None, True, 2, ), # 9
  (10, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 10
)

ScanVertexRequest.thrift_struct_annotations = {
}
ScanVertexRequest.thrift_field_annotations = {
}

def ScanVertexRequest__init__(self, space_id=None, parts=None, return_columns=None, limit=None, start_time=None, end_time=None, filter=None, only_latest_version=ScanVertexRequest.thrift_spec[8][4], enable_read_from_follower=ScanVertexRequest.thrift_spec[9][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_columns = return_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time
  self.filter = filter
  self.only_latest_version = only_latest_version
  self.enable_read_from_follower = enable_read_from_follower
  self.common = common

ScanVertexRequest.__init__ = ScanVertexRequest__init__

def ScanVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  state.setdefault('filter', None)
  state.setdefault('only_latest_version', False)
  state.setdefault('enable_read_from_follower', True)
  state.setdefault('common', None)
  self.__dict__ = state

ScanVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanVertexRequest.__setstate__ = ScanVertexRequest__setstate__

all_structs.append(ScanEdgeRequest)
ScanEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRUCT,[ScanCursor, ScanCursor.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'return_columns', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 2, ), # 3
  (4, TType.I64, 'limit', None, None, 2, ), # 4
  (5, TType.I64, 'start_time', None, None, 1, ), # 5
  (6, TType.I64, 'end_time', None, None, 1, ), # 6
  (7, TType.STRING, 'filter', False, None, 1, ), # 7
  (8, TType.BOOL, 'only_latest_version', None, False, 2, ), # 8
  (9, TType.BOOL, 'enable_read_from_follower', None, True, 2, ), # 9
  (10, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 10
)

ScanEdgeRequest.thrift_struct_annotations = {
}
ScanEdgeRequest.thrift_field_annotations = {
}

def ScanEdgeRequest__init__(self, space_id=None, parts=None, return_columns=None, limit=None, start_time=None, end_time=None, filter=None, only_latest_version=ScanEdgeRequest.thrift_spec[8][4], enable_read_from_follower=ScanEdgeRequest.thrift_spec[9][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_columns = return_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time
  self.filter = filter
  self.only_latest_version = only_latest_version
  self.enable_read_from_follower = enable_read_from_follower
  self.common = common

ScanEdgeRequest.__init__ = ScanEdgeRequest__init__

def ScanEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  state.setdefault('filter', None)
  state.setdefault('only_latest_version', False)
  state.setdefault('enable_read_from_follower', True)
  state.setdefault('common', None)
  self.__dict__ = state

ScanEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanEdgeRequest.__setstate__ = ScanEdgeRequest__setstate__

all_structs.append(ScanResponse)
ScanResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
  (3, TType.MAP, 'cursors', (TType.I32,None,TType.STRUCT,[ScanCursor, ScanCursor.thrift_spec, False]), None, 2, ), # 3
)

ScanResponse.thrift_struct_annotations = {
}
ScanResponse.thrift_field_annotations = {
}

def ScanResponse__init__(self, result=None, props=None, cursors=None,):
  self.result = result
  self.props = props
  self.cursors = cursors

ScanResponse.__init__ = ScanResponse__init__

def ScanResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  state.setdefault('cursors', None)
  self.__dict__ = state

ScanResponse.__getstate__ = lambda self: self.__dict__.copy()
ScanResponse.__setstate__ = ScanResponse__setstate__

all_structs.append(TaskPara)
TaskPara.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 1, ), # 2
  (3, TType.LIST, 'task_specific_paras', (TType.STRING,False), None, 1, ), # 3
)

TaskPara.thrift_struct_annotations = {
}
TaskPara.thrift_field_annotations = {
}

def TaskPara__init__(self, space_id=None, parts=None, task_specific_paras=None,):
  self.space_id = space_id
  self.parts = parts
  self.task_specific_paras = task_specific_paras

TaskPara.__init__ = TaskPara__init__

def TaskPara__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('task_specific_paras', None)
  self.__dict__ = state

TaskPara.__getstate__ = lambda self: self.__dict__.copy()
TaskPara.__setstate__ = TaskPara__setstate__

all_structs.append(KVGetRequest)
KVGetRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
  (3, TType.BOOL, 'return_partly', None, None, 2, ), # 3
)

KVGetRequest.thrift_struct_annotations = {
}
KVGetRequest.thrift_field_annotations = {
}

def KVGetRequest__init__(self, space_id=None, parts=None, return_partly=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_partly = return_partly

KVGetRequest.__init__ = KVGetRequest__init__

def KVGetRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_partly', None)
  self.__dict__ = state

KVGetRequest.__getstate__ = lambda self: self.__dict__.copy()
KVGetRequest.__setstate__ = KVGetRequest__setstate__

all_structs.append(KVGetResponse)
KVGetResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'key_values', (TType.STRING,False,TType.STRING,False), None, 2, ), # 2
)

KVGetResponse.thrift_struct_annotations = {
}
KVGetResponse.thrift_field_annotations = {
}

def KVGetResponse__init__(self, result=None, key_values=None,):
  self.result = result
  self.key_values = key_values

KVGetResponse.__init__ = KVGetResponse__init__

def KVGetResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('key_values', None)
  self.__dict__ = state

KVGetResponse.__getstate__ = lambda self: self.__dict__.copy()
KVGetResponse.__setstate__ = KVGetResponse__setstate__

all_structs.append(KVPutRequest)
KVPutRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.KeyValue, nebula2.common.ttypes.KeyValue.thrift_spec, False])), None, 2, ), # 2
)

KVPutRequest.thrift_struct_annotations = {
}
KVPutRequest.thrift_field_annotations = {
}

def KVPutRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVPutRequest.__init__ = KVPutRequest__init__

def KVPutRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVPutRequest.__getstate__ = lambda self: self.__dict__.copy()
KVPutRequest.__setstate__ = KVPutRequest__setstate__

all_structs.append(KVRemoveRequest)
KVRemoveRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
)

KVRemoveRequest.thrift_struct_annotations = {
}
KVRemoveRequest.thrift_field_annotations = {
}

def KVRemoveRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVRemoveRequest.__init__ = KVRemoveRequest__init__

def KVRemoveRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVRemoveRequest.__getstate__ = lambda self: self.__dict__.copy()
KVRemoveRequest.__setstate__ = KVRemoveRequest__setstate__

all_structs.append(AdminExecResp)
AdminExecResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'stats', [nebula2.meta.ttypes.StatsItem, nebula2.meta.ttypes.StatsItem.thrift_spec, False], None, 1, ), # 2
)

AdminExecResp.thrift_struct_annotations = {
}
AdminExecResp.thrift_field_annotations = {
}

def AdminExecResp__init__(self, result=None, stats=None,):
  self.result = result
  self.stats = stats

AdminExecResp.__init__ = AdminExecResp__init__

def AdminExecResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('stats', None)
  self.__dict__ = state

AdminExecResp.__getstate__ = lambda self: self.__dict__.copy()
AdminExecResp.__setstate__ = AdminExecResp__setstate__

all_structs.append(TransLeaderReq)
TransLeaderReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'new_leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

TransLeaderReq.thrift_struct_annotations = {
}
TransLeaderReq.thrift_field_annotations = {
}

def TransLeaderReq__init__(self, space_id=None, part_id=None, new_leader=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.new_leader = new_leader

TransLeaderReq.__init__ = TransLeaderReq__init__

def TransLeaderReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('new_leader', None)
  self.__dict__ = state

TransLeaderReq.__getstate__ = lambda self: self.__dict__.copy()
TransLeaderReq.__setstate__ = TransLeaderReq__setstate__

all_structs.append(AddPartReq)
AddPartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.BOOL, 'as_learner', None, None, 2, ), # 3
  (4, TType.LIST, 'peers', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 4
)

AddPartReq.thrift_struct_annotations = {
}
AddPartReq.thrift_field_annotations = {
}

def AddPartReq__init__(self, space_id=None, part_id=None, as_learner=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.as_learner = as_learner
  self.peers = peers

AddPartReq.__init__ = AddPartReq__init__

def AddPartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('as_learner', None)
  state.setdefault('peers', None)
  self.__dict__ = state

AddPartReq.__getstate__ = lambda self: self.__dict__.copy()
AddPartReq.__setstate__ = AddPartReq__setstate__

all_structs.append(AddLearnerReq)
AddLearnerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'learner', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

AddLearnerReq.thrift_struct_annotations = {
}
AddLearnerReq.thrift_field_annotations = {
}

def AddLearnerReq__init__(self, space_id=None, part_id=None, learner=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.learner = learner

AddLearnerReq.__init__ = AddLearnerReq__init__

def AddLearnerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('learner', None)
  self.__dict__ = state

AddLearnerReq.__getstate__ = lambda self: self.__dict__.copy()
AddLearnerReq.__setstate__ = AddLearnerReq__setstate__

all_structs.append(RemovePartReq)
RemovePartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
)

RemovePartReq.thrift_struct_annotations = {
}
RemovePartReq.thrift_field_annotations = {
}

def RemovePartReq__init__(self, space_id=None, part_id=None,):
  self.space_id = space_id
  self.part_id = part_id

RemovePartReq.__init__ = RemovePartReq__init__

def RemovePartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  self.__dict__ = state

RemovePartReq.__getstate__ = lambda self: self.__dict__.copy()
RemovePartReq.__setstate__ = RemovePartReq__setstate__

all_structs.append(MemberChangeReq)
MemberChangeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'peer', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'add', None, None, 2, ), # 4
)

MemberChangeReq.thrift_struct_annotations = {
}
MemberChangeReq.thrift_field_annotations = {
}

def MemberChangeReq__init__(self, space_id=None, part_id=None, peer=None, add=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peer = peer
  self.add = add

MemberChangeReq.__init__ = MemberChangeReq__init__

def MemberChangeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peer', None)
  state.setdefault('add', None)
  self.__dict__ = state

MemberChangeReq.__getstate__ = lambda self: self.__dict__.copy()
MemberChangeReq.__setstate__ = MemberChangeReq__setstate__

all_structs.append(CatchUpDataReq)
CatchUpDataReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'target', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

CatchUpDataReq.thrift_struct_annotations = {
}
CatchUpDataReq.thrift_field_annotations = {
}

def CatchUpDataReq__init__(self, space_id=None, part_id=None, target=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.target = target

CatchUpDataReq.__init__ = CatchUpDataReq__init__

def CatchUpDataReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('target', None)
  self.__dict__ = state

CatchUpDataReq.__getstate__ = lambda self: self.__dict__.copy()
CatchUpDataReq.__setstate__ = CatchUpDataReq__setstate__

all_structs.append(GetLeaderReq)
GetLeaderReq.thrift_spec = (
)

GetLeaderReq.thrift_struct_annotations = {
}
GetLeaderReq.thrift_field_annotations = {
}

all_structs.append(CreateCPRequest)
CreateCPRequest.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'space_ids', (TType.I32,None), None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

CreateCPRequest.thrift_struct_annotations = {
}
CreateCPRequest.thrift_field_annotations = {
}

def CreateCPRequest__init__(self, space_ids=None, name=None,):
  self.space_ids = space_ids
  self.name = name

CreateCPRequest.__init__ = CreateCPRequest__init__

def CreateCPRequest__setstate__(self, state):
  state.setdefault('space_ids', None)
  state.setdefault('name', None)
  self.__dict__ = state

CreateCPRequest.__getstate__ = lambda self: self.__dict__.copy()
CreateCPRequest.__setstate__ = CreateCPRequest__setstate__

all_structs.append(DropCPRequest)
DropCPRequest.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'space_ids', (TType.I32,None), None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

DropCPRequest.thrift_struct_annotations = {
}
DropCPRequest.thrift_field_annotations = {
}

def DropCPRequest__init__(self, space_ids=None, name=None,):
  self.space_ids = space_ids
  self.name = name

DropCPRequest.__init__ = DropCPRequest__init__

def DropCPRequest__setstate__(self, state):
  state.setdefault('space_ids', None)
  state.setdefault('name', None)
  self.__dict__ = state

DropCPRequest.__getstate__ = lambda self: self.__dict__.copy()
DropCPRequest.__setstate__ = DropCPRequest__setstate__

all_structs.append(BlockingSignRequest)
BlockingSignRequest.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'space_ids', (TType.I32,None), None, 2, ), # 1
  (2, TType.I32, 'sign', EngineSignType, None, 0, ), # 2
)

BlockingSignRequest.thrift_struct_annotations = {
}
BlockingSignRequest.thrift_field_annotations = {
}

def BlockingSignRequest__init__(self, space_ids=None, sign=None,):
  self.space_ids = space_ids
  self.sign = sign

BlockingSignRequest.__init__ = BlockingSignRequest__init__

def BlockingSignRequest__setstate__(self, state):
  state.setdefault('space_ids', None)
  state.setdefault('sign', None)
  self.__dict__ = state

BlockingSignRequest.__getstate__ = lambda self: self.__dict__.copy()
BlockingSignRequest.__setstate__ = BlockingSignRequest__setstate__

all_structs.append(GetLeaderPartsResp)
GetLeaderPartsResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'leader_parts', (TType.I32,None,TType.LIST,(TType.I32,None)), None, 2, ), # 2
)

GetLeaderPartsResp.thrift_struct_annotations = {
}
GetLeaderPartsResp.thrift_field_annotations = {
}

def GetLeaderPartsResp__init__(self, result=None, leader_parts=None,):
  self.result = result
  self.leader_parts = leader_parts

GetLeaderPartsResp.__init__ = GetLeaderPartsResp__init__

def GetLeaderPartsResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('leader_parts', None)
  self.__dict__ = state

GetLeaderPartsResp.__getstate__ = lambda self: self.__dict__.copy()
GetLeaderPartsResp.__setstate__ = GetLeaderPartsResp__setstate__

all_structs.append(CheckPeersReq)
CheckPeersReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

CheckPeersReq.thrift_struct_annotations = {
}
CheckPeersReq.thrift_field_annotations = {
}

def CheckPeersReq__init__(self, space_id=None, part_id=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peers = peers

CheckPeersReq.__init__ = CheckPeersReq__init__

def CheckPeersReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peers', None)
  self.__dict__ = state

CheckPeersReq.__getstate__ = lambda self: self.__dict__.copy()
CheckPeersReq.__setstate__ = CheckPeersReq__setstate__

all_structs.append(RebuildIndexRequest)
RebuildIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 2, ), # 2
  (3, TType.I32, 'index_id', None, None, 2, ), # 3
)

RebuildIndexRequest.thrift_struct_annotations = {
}
RebuildIndexRequest.thrift_field_annotations = {
}

def RebuildIndexRequest__init__(self, space_id=None, parts=None, index_id=None,):
  self.space_id = space_id
  self.parts = parts
  self.index_id = index_id

RebuildIndexRequest.__init__ = RebuildIndexRequest__init__

def RebuildIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('index_id', None)
  self.__dict__ = state

RebuildIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexRequest.__setstate__ = RebuildIndexRequest__setstate__

all_structs.append(CreateCPResp)
CreateCPResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.LIST, 'info', (TType.STRUCT,[nebula2.common.ttypes.CheckpointInfo, nebula2.common.ttypes.CheckpointInfo.thrift_spec, False]), None, 2, ), # 2
)

CreateCPResp.thrift_struct_annotations = {
}
CreateCPResp.thrift_field_annotations = {
}

def CreateCPResp__init__(self, result=None, info=None,):
  self.result = result
  self.info = info

CreateCPResp.__init__ = CreateCPResp__init__

def CreateCPResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('info', None)
  self.__dict__ = state

CreateCPResp.__getstate__ = lambda self: self.__dict__.copy()
CreateCPResp.__setstate__ = CreateCPResp__setstate__

all_structs.append(ListClusterInfoResp)
ListClusterInfoResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'dir', [nebula2.common.ttypes.DirInfo, nebula2.common.ttypes.DirInfo.thrift_spec, False], None, 2, ), # 2
)

ListClusterInfoResp.thrift_struct_annotations = {
}
ListClusterInfoResp.thrift_field_annotations = {
}

def ListClusterInfoResp__init__(self, result=None, dir=None,):
  self.result = result
  self.dir = dir

ListClusterInfoResp.__init__ = ListClusterInfoResp__init__

def ListClusterInfoResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('dir', None)
  self.__dict__ = state

ListClusterInfoResp.__getstate__ = lambda self: self.__dict__.copy()
ListClusterInfoResp.__setstate__ = ListClusterInfoResp__setstate__

all_structs.append(ListClusterInfoReq)
ListClusterInfoReq.thrift_spec = (
)

ListClusterInfoReq.thrift_struct_annotations = {
}
ListClusterInfoReq.thrift_field_annotations = {
}

all_structs.append(AddAdminTaskRequest)
AddAdminTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'cmd', nebula2.meta.ttypes.AdminCmd, None, 2, ), # 1
  (2, TType.I32, 'job_id', None, None, 2, ), # 2
  (3, TType.I32, 'task_id', None, None, 2, ), # 3
  (4, TType.STRUCT, 'para', [TaskPara, TaskPara.thrift_spec, False], None, 2, ), # 4
  (5, TType.I32, 'concurrency', None, None, 1, ), # 5
)

AddAdminTaskRequest.thrift_struct_annotations = {
}
AddAdminTaskRequest.thrift_field_annotations = {
}

def AddAdminTaskRequest__init__(self, cmd=None, job_id=None, task_id=None, para=None, concurrency=None,):
  self.cmd = cmd
  self.job_id = job_id
  self.task_id = task_id
  self.para = para
  self.concurrency = concurrency

AddAdminTaskRequest.__init__ = AddAdminTaskRequest__init__

def AddAdminTaskRequest__setstate__(self, state):
  state.setdefault('cmd', None)
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  state.setdefault('para', None)
  state.setdefault('concurrency', None)
  self.__dict__ = state

AddAdminTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
AddAdminTaskRequest.__setstate__ = AddAdminTaskRequest__setstate__

all_structs.append(StopAdminTaskRequest)
StopAdminTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_id', None, None, 2, ), # 1
  (2, TType.I32, 'task_id', None, None, 2, ), # 2
)

StopAdminTaskRequest.thrift_struct_annotations = {
}
StopAdminTaskRequest.thrift_field_annotations = {
}

def StopAdminTaskRequest__init__(self, job_id=None, task_id=None,):
  self.job_id = job_id
  self.task_id = task_id

StopAdminTaskRequest.__init__ = StopAdminTaskRequest__init__

def StopAdminTaskRequest__setstate__(self, state):
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  self.__dict__ = state

StopAdminTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
StopAdminTaskRequest.__setstate__ = StopAdminTaskRequest__setstate__

all_structs.append(InternalTxnRequest)
InternalTxnRequest.thrift_spec = (
  None, # 0
  (1, TType.I64, 'txn_id', None, None, 2, ), # 1
  (2, TType.MAP, 'term_of_parts', (TType.I32,None,TType.I64,None), None, 2, ), # 2
  (3, TType.STRUCT, 'add_edge_req', [AddEdgesRequest, AddEdgesRequest.thrift_spec, False], None, 1, ), # 3
  (4, TType.STRUCT, 'upd_edge_req', [UpdateEdgeRequest, UpdateEdgeRequest.thrift_spec, False], None, 1, ), # 4
  (5, TType.MAP, 'edge_ver', (TType.I32,None,TType.LIST,(TType.I64,None)), None, 1, ), # 5
)

InternalTxnRequest.thrift_struct_annotations = {
}
InternalTxnRequest.thrift_field_annotations = {
}

def InternalTxnRequest__init__(self, txn_id=None, term_of_parts=None, add_edge_req=None, upd_edge_req=None, edge_ver=None,):
  self.txn_id = txn_id
  self.term_of_parts = term_of_parts
  self.add_edge_req = add_edge_req
  self.upd_edge_req = upd_edge_req
  self.edge_ver = edge_ver

InternalTxnRequest.__init__ = InternalTxnRequest__init__

def InternalTxnRequest__setstate__(self, state):
  state.setdefault('txn_id', None)
  state.setdefault('term_of_parts', None)
  state.setdefault('add_edge_req', None)
  state.setdefault('upd_edge_req', None)
  state.setdefault('edge_ver', None)
  self.__dict__ = state

InternalTxnRequest.__getstate__ = lambda self: self.__dict__.copy()
InternalTxnRequest.__setstate__ = InternalTxnRequest__setstate__

all_structs.append(ChainAddEdgesRequest)
ChainAddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewEdge, NewEdge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'prop_names', (TType.STRING,False), None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
  (5, TType.I64, 'term', None, None, 2, ), # 5
  (6, TType.I64, 'edge_version', None, None, 1, ), # 6
)

ChainAddEdgesRequest.thrift_struct_annotations = {
}
ChainAddEdgesRequest.thrift_field_annotations = {
}

def ChainAddEdgesRequest__init__(self, space_id=None, parts=None, prop_names=None, if_not_exists=None, term=None, edge_version=None,):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.if_not_exists = if_not_exists
  self.term = term
  self.edge_version = edge_version

ChainAddEdgesRequest.__init__ = ChainAddEdgesRequest__init__

def ChainAddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('term', None)
  state.setdefault('edge_version', None)
  self.__dict__ = state

ChainAddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
ChainAddEdgesRequest.__setstate__ = ChainAddEdgesRequest__setstate__

all_structs.append(ChainUpdateEdgeRequest)
ChainUpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'update_edge_request', [UpdateEdgeRequest, UpdateEdgeRequest.thrift_spec, False], None, 2, ), # 1
  (2, TType.I64, 'term', None, None, 2, ), # 2
  (3, TType.I64, 'edge_version', None, None, 1, ), # 3
  (4, TType.I32, 'space_id', None, None, 2, ), # 4
  (5, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 5
)

ChainUpdateEdgeRequest.thrift_struct_annotations = {
}
ChainUpdateEdgeRequest.thrift_field_annotations = {
}

def ChainUpdateEdgeRequest__init__(self, update_edge_request=None, term=None, edge_version=None, space_id=None, parts=None,):
  self.update_edge_request = update_edge_request
  self.term = term
  self.edge_version = edge_version
  self.space_id = space_id
  self.parts = parts

ChainUpdateEdgeRequest.__init__ = ChainUpdateEdgeRequest__init__

def ChainUpdateEdgeRequest__setstate__(self, state):
  state.setdefault('update_edge_request', None)
  state.setdefault('term', None)
  state.setdefault('edge_version', None)
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

ChainUpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
ChainUpdateEdgeRequest.__setstate__ = ChainUpdateEdgeRequest__setstate__

fix_spec(all_structs)
del all_structs
