#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from nebula2.fbthrift.util.Recursive import fix_spec
from nebula2.fbthrift.Thrift import *
from nebula2.fbthrift.protocol.TProtocol import TProtocolException


import nebula2.common.ttypes
import nebula2.meta.ttypes


import pprint
import warnings
from nebula2.fbthrift import Thrift
from nebula2.fbthrift.transport import TTransport
from nebula2.fbthrift.protocol import TBinaryProtocol
from nebula2.fbthrift.protocol import TCompactProtocol
from nebula2.fbthrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from nebula2.fbthrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ErrorCode', 'StatType', 'OrderDirection', 'EdgeDirection', 'ScanType', 'EngineSignType', 'PartitionResult', 'ResponseCommon', 'StatProp', 'Expr', 'EdgeProp', 'VertexProp', 'OrderBy', 'TraverseSpec', 'GetNeighborsRequest', 'GetNeighborsResponse', 'ExecResponse', 'GetPropRequest', 'GetPropResponse', 'NewTag', 'NewVertex', 'EdgeKey', 'NewEdge', 'AddVerticesRequest', 'AddEdgesRequest', 'DeleteVerticesRequest', 'DeleteEdgesRequest', 'UpdateResponse', 'UpdatedProp', 'UpdateVertexRequest', 'UpdateEdgeRequest', 'GetUUIDReq', 'GetUUIDResp', 'LookupIndexResp', 'IndexColumnHint', 'IndexQueryContext', 'IndexSpec', 'LookupIndexRequest', 'LookupAndTraverseRequest', 'ScanVertexRequest', 'ScanVertexResponse', 'ScanEdgeRequest', 'ScanEdgeResponse', 'TaskPara', 'AddAdminTaskRequest', 'StopAdminTaskRequest', 'AdminExecResp', 'TransLeaderReq', 'AddPartReq', 'AddLearnerReq', 'RemovePartReq', 'MemberChangeReq', 'CatchUpDataReq', 'GetLeaderReq', 'CreateCPRequest', 'DropCPRequest', 'BlockingSignRequest', 'GetLeaderPartsResp', 'CheckPeersReq', 'RebuildIndexRequest', 'CreateCPResp', 'PartitionInfoResp', 'PartitionInfoRequest', 'KVGetRequest', 'KVGetResponse', 'KVPutRequest', 'KVRemoveRequest', 'InternalTxnRequest', 'GetValueRequest', 'GetValueResponse']

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAILED_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_LEADER_CHANGED = -11
  E_KEY_HAS_EXISTS = -12
  E_SPACE_NOT_FOUND = -13
  E_PART_NOT_FOUND = -14
  E_KEY_NOT_FOUND = -15
  E_CONSENSUS_ERROR = -16
  E_DATA_TYPE_MISMATCH = -17
  E_INVALID_FIELD_VALUE = -18
  E_REBUILD_INDEX_FAILED = -19
  E_INVALID_OPERATION = -20
  E_NOT_NULLABLE = -21
  E_FIELD_UNSET = -22
  E_OUT_OF_RANGE = -23
  E_ATOMIC_OP_FAILED = -24
  E_DATA_CONFLICT_ERROR = -25
  E_EDGE_PROP_NOT_FOUND = -31
  E_TAG_PROP_NOT_FOUND = -32
  E_IMPROPER_DATA_TYPE = -33
  E_EDGE_NOT_FOUND = -34
  E_TAG_NOT_FOUND = -35
  E_INVALID_SPACEVIDLEN = -36
  E_INDEX_NOT_FOUND = -37
  E_INVALID_FILTER = -41
  E_INVALID_UPDATER = -42
  E_INVALID_STORE = -43
  E_INVALID_PEER = -44
  E_RETRY_EXHAUSTED = -45
  E_TRANSFER_LEADER_FAILED = -46
  E_INVALID_STAT_TYPE = -47
  E_INVALID_VID = -48
  E_NO_TRANSFORMED = -49
  E_LOAD_META_FAILED = -51
  E_FAILED_TO_CHECKPOINT = -60
  E_CHECKPOINT_BLOCKED = -61
  E_BACKUP_FAILED = -65
  E_PARTIAL_RESULT = -71
  E_FILTER_OUT = -81
  E_INVALID_DATA = -82
  E_MUTATE_EDGE_CONFLICT = -85
  E_OUTDATED_LOCK = -86
  E_INVALID_TASK_PARA = -90
  E_USER_CANCEL = -99
  E_UNKNOWN = -100

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAILED_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -11: "E_LEADER_CHANGED",
    -12: "E_KEY_HAS_EXISTS",
    -13: "E_SPACE_NOT_FOUND",
    -14: "E_PART_NOT_FOUND",
    -15: "E_KEY_NOT_FOUND",
    -16: "E_CONSENSUS_ERROR",
    -17: "E_DATA_TYPE_MISMATCH",
    -18: "E_INVALID_FIELD_VALUE",
    -19: "E_REBUILD_INDEX_FAILED",
    -20: "E_INVALID_OPERATION",
    -21: "E_NOT_NULLABLE",
    -22: "E_FIELD_UNSET",
    -23: "E_OUT_OF_RANGE",
    -24: "E_ATOMIC_OP_FAILED",
    -25: "E_DATA_CONFLICT_ERROR",
    -31: "E_EDGE_PROP_NOT_FOUND",
    -32: "E_TAG_PROP_NOT_FOUND",
    -33: "E_IMPROPER_DATA_TYPE",
    -34: "E_EDGE_NOT_FOUND",
    -35: "E_TAG_NOT_FOUND",
    -36: "E_INVALID_SPACEVIDLEN",
    -37: "E_INDEX_NOT_FOUND",
    -41: "E_INVALID_FILTER",
    -42: "E_INVALID_UPDATER",
    -43: "E_INVALID_STORE",
    -44: "E_INVALID_PEER",
    -45: "E_RETRY_EXHAUSTED",
    -46: "E_TRANSFER_LEADER_FAILED",
    -47: "E_INVALID_STAT_TYPE",
    -48: "E_INVALID_VID",
    -49: "E_NO_TRANSFORMED",
    -51: "E_LOAD_META_FAILED",
    -60: "E_FAILED_TO_CHECKPOINT",
    -61: "E_CHECKPOINT_BLOCKED",
    -65: "E_BACKUP_FAILED",
    -71: "E_PARTIAL_RESULT",
    -81: "E_FILTER_OUT",
    -82: "E_INVALID_DATA",
    -85: "E_MUTATE_EDGE_CONFLICT",
    -86: "E_OUTDATED_LOCK",
    -90: "E_INVALID_TASK_PARA",
    -99: "E_USER_CANCEL",
    -100: "E_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAILED_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_LEADER_CHANGED": -11,
    "E_KEY_HAS_EXISTS": -12,
    "E_SPACE_NOT_FOUND": -13,
    "E_PART_NOT_FOUND": -14,
    "E_KEY_NOT_FOUND": -15,
    "E_CONSENSUS_ERROR": -16,
    "E_DATA_TYPE_MISMATCH": -17,
    "E_INVALID_FIELD_VALUE": -18,
    "E_REBUILD_INDEX_FAILED": -19,
    "E_INVALID_OPERATION": -20,
    "E_NOT_NULLABLE": -21,
    "E_FIELD_UNSET": -22,
    "E_OUT_OF_RANGE": -23,
    "E_ATOMIC_OP_FAILED": -24,
    "E_DATA_CONFLICT_ERROR": -25,
    "E_EDGE_PROP_NOT_FOUND": -31,
    "E_TAG_PROP_NOT_FOUND": -32,
    "E_IMPROPER_DATA_TYPE": -33,
    "E_EDGE_NOT_FOUND": -34,
    "E_TAG_NOT_FOUND": -35,
    "E_INVALID_SPACEVIDLEN": -36,
    "E_INDEX_NOT_FOUND": -37,
    "E_INVALID_FILTER": -41,
    "E_INVALID_UPDATER": -42,
    "E_INVALID_STORE": -43,
    "E_INVALID_PEER": -44,
    "E_RETRY_EXHAUSTED": -45,
    "E_TRANSFER_LEADER_FAILED": -46,
    "E_INVALID_STAT_TYPE": -47,
    "E_INVALID_VID": -48,
    "E_NO_TRANSFORMED": -49,
    "E_LOAD_META_FAILED": -51,
    "E_FAILED_TO_CHECKPOINT": -60,
    "E_CHECKPOINT_BLOCKED": -61,
    "E_BACKUP_FAILED": -65,
    "E_PARTIAL_RESULT": -71,
    "E_FILTER_OUT": -81,
    "E_INVALID_DATA": -82,
    "E_MUTATE_EDGE_CONFLICT": -85,
    "E_OUTDATED_LOCK": -86,
    "E_INVALID_TASK_PARA": -90,
    "E_USER_CANCEL": -99,
    "E_UNKNOWN": -100,
  }

class StatType:
  SUM = 1
  COUNT = 2
  AVG = 3
  MAX = 4
  MIN = 5

  _VALUES_TO_NAMES = {
    1: "SUM",
    2: "COUNT",
    3: "AVG",
    4: "MAX",
    5: "MIN",
  }

  _NAMES_TO_VALUES = {
    "SUM": 1,
    "COUNT": 2,
    "AVG": 3,
    "MAX": 4,
    "MIN": 5,
  }

class OrderDirection:
  ASCENDING = 1
  DESCENDING = 2

  _VALUES_TO_NAMES = {
    1: "ASCENDING",
    2: "DESCENDING",
  }

  _NAMES_TO_VALUES = {
    "ASCENDING": 1,
    "DESCENDING": 2,
  }

class EdgeDirection:
  BOTH = 1
  IN_EDGE = 2
  OUT_EDGE = 3

  _VALUES_TO_NAMES = {
    1: "BOTH",
    2: "IN_EDGE",
    3: "OUT_EDGE",
  }

  _NAMES_TO_VALUES = {
    "BOTH": 1,
    "IN_EDGE": 2,
    "OUT_EDGE": 3,
  }

class ScanType:
  PREFIX = 1
  RANGE = 2

  _VALUES_TO_NAMES = {
    1: "PREFIX",
    2: "RANGE",
  }

  _NAMES_TO_VALUES = {
    "PREFIX": 1,
    "RANGE": 2,
  }

class EngineSignType:
  BLOCK_ON = 1
  BLOCK_OFF = 2

  _VALUES_TO_NAMES = {
    1: "BLOCK_ON",
    2: "BLOCK_OFF",
  }

  _NAMES_TO_VALUES = {
    "BLOCK_ON": 1,
    "BLOCK_OFF": 2,
  }

class PartitionResult:
  """
  Attributes:
   - code
   - part_id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.code == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'code' was not found in serialized data! Struct: PartitionResult")

    if self.part_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'part_id' was not found in serialized data! Struct: PartitionResult")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionResult')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ResponseCommon:
  """
  Attributes:
   - failed_parts
   - latency_in_us
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.failed_parts = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = PartitionResult()
              _elem5.read(iprot)
              self.failed_parts.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = PartitionResult()
              _elem6.read(iprot)
              self.failed_parts.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.latency_in_us = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.failed_parts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'failed_parts' was not found in serialized data! Struct: ResponseCommon")

    if self.latency_in_us == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'latency_in_us' was not found in serialized data! Struct: ResponseCommon")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ResponseCommon')
    if self.failed_parts != None:
      oprot.writeFieldBegin('failed_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.failed_parts))
      for iter7 in self.failed_parts:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I32, 2)
      oprot.writeI32(self.latency_in_us)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.failed_parts is not None:
      value = pprint.pformat(self.failed_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    failed_parts=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class StatProp:
  """
  Attributes:
   - alias
   - prop
   - stat
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.stat = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StatProp')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 2)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.stat != None:
      oprot.writeFieldBegin('stat', TType.I32, 3)
      oprot.writeI32(self.stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.stat is not None:
      value = pprint.pformat(self.stat, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Expr:
  """
  Attributes:
   - alias
   - expr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Expr')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.expr != None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.expr is not None:
      value = pprint.pformat(self.expr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeProp:
  """
  Attributes:
   - type
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = iprot.readString()
              self.props.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = iprot.readString()
              self.props.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeProp')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter15 in self.props:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class VertexProp:
  """
  Attributes:
   - tag
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = iprot.readString()
              self.props.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = iprot.readString()
              self.props.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexProp')
    if self.tag != None:
      oprot.writeFieldBegin('tag', TType.I32, 1)
      oprot.writeI32(self.tag)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter23 in self.props:
        oprot.writeString(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag is not None:
      value = pprint.pformat(self.tag, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class OrderBy:
  """
  Attributes:
   - prop
   - direction
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OrderBy')
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 1)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, 2)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.direction is not None:
      value = pprint.pformat(self.direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    direction=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TraverseSpec:
  """
  Attributes:
   - edge_types
   - edge_direction
   - dedup
   - stat_props
   - vertex_props
   - edge_props
   - expressions
   - order_by
   - random
   - limit
   - filter
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.edge_types = []
          (_etype27, _size24) = iprot.readListBegin()
          if _size24 >= 0:
            for _i28 in six.moves.range(_size24):
              _elem29 = iprot.readI32()
              self.edge_types.append(_elem29)
          else: 
            while iprot.peekList():
              _elem30 = iprot.readI32()
              self.edge_types.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stat_props = []
          (_etype34, _size31) = iprot.readListBegin()
          if _size31 >= 0:
            for _i35 in six.moves.range(_size31):
              _elem36 = StatProp()
              _elem36.read(iprot)
              self.stat_props.append(_elem36)
          else: 
            while iprot.peekList():
              _elem37 = StatProp()
              _elem37.read(iprot)
              self.stat_props.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype41, _size38) = iprot.readListBegin()
          if _size38 >= 0:
            for _i42 in six.moves.range(_size38):
              _elem43 = VertexProp()
              _elem43.read(iprot)
              self.vertex_props.append(_elem43)
          else: 
            while iprot.peekList():
              _elem44 = VertexProp()
              _elem44.read(iprot)
              self.vertex_props.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype48, _size45) = iprot.readListBegin()
          if _size45 >= 0:
            for _i49 in six.moves.range(_size45):
              _elem50 = EdgeProp()
              _elem50.read(iprot)
              self.edge_props.append(_elem50)
          else: 
            while iprot.peekList():
              _elem51 = EdgeProp()
              _elem51.read(iprot)
              self.edge_props.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype55, _size52) = iprot.readListBegin()
          if _size52 >= 0:
            for _i56 in six.moves.range(_size52):
              _elem57 = Expr()
              _elem57.read(iprot)
              self.expressions.append(_elem57)
          else: 
            while iprot.peekList():
              _elem58 = Expr()
              _elem58.read(iprot)
              self.expressions.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype62, _size59) = iprot.readListBegin()
          if _size59 >= 0:
            for _i63 in six.moves.range(_size59):
              _elem64 = OrderBy()
              _elem64.read(iprot)
              self.order_by.append(_elem64)
          else: 
            while iprot.peekList():
              _elem65 = OrderBy()
              _elem65.read(iprot)
              self.order_by.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.random = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TraverseSpec')
    if self.edge_types != None:
      oprot.writeFieldBegin('edge_types', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.edge_types))
      for iter66 in self.edge_types:
        oprot.writeI32(iter66)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_direction != None:
      oprot.writeFieldBegin('edge_direction', TType.I32, 2)
      oprot.writeI32(self.edge_direction)
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 3)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.stat_props != None:
      oprot.writeFieldBegin('stat_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.stat_props))
      for iter67 in self.stat_props:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter68 in self.vertex_props:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter69 in self.edge_props:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter70 in self.expressions:
        iter70.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter71 in self.order_by:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.random != None:
      oprot.writeFieldBegin('random', TType.BOOL, 9)
      oprot.writeBool(self.random)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 10)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 11)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.edge_types is not None:
      value = pprint.pformat(self.edge_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_types=%s' % (value))
    if self.edge_direction is not None:
      value = pprint.pformat(self.edge_direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_direction=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.stat_props is not None:
      value = pprint.pformat(self.stat_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat_props=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.random is not None:
      value = pprint.pformat(self.random, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    random=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetNeighborsRequest:
  """
  Attributes:
   - space_id
   - column_names
   - parts
   - traverse_spec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype75, _size72) = iprot.readListBegin()
          if _size72 >= 0:
            for _i76 in six.moves.range(_size72):
              _elem77 = iprot.readString()
              self.column_names.append(_elem77)
          else: 
            while iprot.peekList():
              _elem78 = iprot.readString()
              self.column_names.append(_elem78)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin() 
          if _size79 >= 0:
            for _i83 in six.moves.range(_size79):
              _key84 = iprot.readI32()
              _val85 = []
              (_etype89, _size86) = iprot.readListBegin()
              if _size86 >= 0:
                for _i90 in six.moves.range(_size86):
                  _elem91 = nebula2.common.ttypes.Row()
                  _elem91.read(iprot)
                  _val85.append(_elem91)
              else: 
                while iprot.peekList():
                  _elem92 = nebula2.common.ttypes.Row()
                  _elem92.read(iprot)
                  _val85.append(_elem92)
              iprot.readListEnd()
              self.parts[_key84] = _val85
          else: 
            while iprot.peekMap():
              _key93 = iprot.readI32()
              _val94 = []
              (_etype98, _size95) = iprot.readListBegin()
              if _size95 >= 0:
                for _i99 in six.moves.range(_size95):
                  _elem100 = nebula2.common.ttypes.Row()
                  _elem100.read(iprot)
                  _val94.append(_elem100)
              else: 
                while iprot.peekList():
                  _elem101 = nebula2.common.ttypes.Row()
                  _elem101.read(iprot)
                  _val94.append(_elem101)
              iprot.readListEnd()
              self.parts[_key93] = _val94
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter102 in self.column_names:
        oprot.writeString(iter102)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter103,viter104 in self.parts.items():
        oprot.writeI32(kiter103)
        oprot.writeListBegin(TType.STRUCT, len(viter104))
        for iter105 in viter104:
          iter105.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetNeighborsResponse:
  """
  Attributes:
   - result
   - vertices
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vertices = nebula2.common.ttypes.DataSet()
          self.vertices.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetNeighborsResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertices != None:
      oprot.writeFieldBegin('vertices', TType.STRUCT, 2)
      self.vertices.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertices is not None:
      value = pprint.pformat(self.vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertices=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ExecResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ExecResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetPropRequest:
  """
  Attributes:
   - space_id
   - parts
   - vertex_props
   - edge_props
   - expressions
   - dedup
   - order_by
   - limit
   - filter
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype107, _vtype108, _size106 ) = iprot.readMapBegin() 
          if _size106 >= 0:
            for _i110 in six.moves.range(_size106):
              _key111 = iprot.readI32()
              _val112 = []
              (_etype116, _size113) = iprot.readListBegin()
              if _size113 >= 0:
                for _i117 in six.moves.range(_size113):
                  _elem118 = nebula2.common.ttypes.Row()
                  _elem118.read(iprot)
                  _val112.append(_elem118)
              else: 
                while iprot.peekList():
                  _elem119 = nebula2.common.ttypes.Row()
                  _elem119.read(iprot)
                  _val112.append(_elem119)
              iprot.readListEnd()
              self.parts[_key111] = _val112
          else: 
            while iprot.peekMap():
              _key120 = iprot.readI32()
              _val121 = []
              (_etype125, _size122) = iprot.readListBegin()
              if _size122 >= 0:
                for _i126 in six.moves.range(_size122):
                  _elem127 = nebula2.common.ttypes.Row()
                  _elem127.read(iprot)
                  _val121.append(_elem127)
              else: 
                while iprot.peekList():
                  _elem128 = nebula2.common.ttypes.Row()
                  _elem128.read(iprot)
                  _val121.append(_elem128)
              iprot.readListEnd()
              self.parts[_key120] = _val121
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype132, _size129) = iprot.readListBegin()
          if _size129 >= 0:
            for _i133 in six.moves.range(_size129):
              _elem134 = VertexProp()
              _elem134.read(iprot)
              self.vertex_props.append(_elem134)
          else: 
            while iprot.peekList():
              _elem135 = VertexProp()
              _elem135.read(iprot)
              self.vertex_props.append(_elem135)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype139, _size136) = iprot.readListBegin()
          if _size136 >= 0:
            for _i140 in six.moves.range(_size136):
              _elem141 = EdgeProp()
              _elem141.read(iprot)
              self.edge_props.append(_elem141)
          else: 
            while iprot.peekList():
              _elem142 = EdgeProp()
              _elem142.read(iprot)
              self.edge_props.append(_elem142)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype146, _size143) = iprot.readListBegin()
          if _size143 >= 0:
            for _i147 in six.moves.range(_size143):
              _elem148 = Expr()
              _elem148.read(iprot)
              self.expressions.append(_elem148)
          else: 
            while iprot.peekList():
              _elem149 = Expr()
              _elem149.read(iprot)
              self.expressions.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype153, _size150) = iprot.readListBegin()
          if _size150 >= 0:
            for _i154 in six.moves.range(_size150):
              _elem155 = OrderBy()
              _elem155.read(iprot)
              self.order_by.append(_elem155)
          else: 
            while iprot.peekList():
              _elem156 = OrderBy()
              _elem156.read(iprot)
              self.order_by.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter157,viter158 in self.parts.items():
        oprot.writeI32(kiter157)
        oprot.writeListBegin(TType.STRUCT, len(viter158))
        for iter159 in viter158:
          iter159.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter160 in self.vertex_props:
        iter160.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter161 in self.edge_props:
        iter161.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter162 in self.expressions:
        iter162.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 6)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter163 in self.order_by:
        iter163.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 8)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 9)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetPropResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewTag:
  """
  Attributes:
   - tag_id
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype167, _size164) = iprot.readListBegin()
          if _size164 >= 0:
            for _i168 in six.moves.range(_size164):
              _elem169 = nebula2.common.ttypes.Value()
              _elem169.read(iprot)
              self.props.append(_elem169)
          else: 
            while iprot.peekList():
              _elem170 = nebula2.common.ttypes.Value()
              _elem170.read(iprot)
              self.props.append(_elem170)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewTag')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter171 in self.props:
        iter171.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewVertex:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = nebula2.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype175, _size172) = iprot.readListBegin()
          if _size172 >= 0:
            for _i176 in six.moves.range(_size172):
              _elem177 = NewTag()
              _elem177.read(iprot)
              self.tags.append(_elem177)
          else: 
            while iprot.peekList():
              _elem178 = NewTag()
              _elem178.read(iprot)
              self.tags.append(_elem178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewVertex')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter179 in self.tags:
        iter179.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeKey:
  """
  Attributes:
   - src
   - edge_type
   - ranking
   - dst
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = nebula2.common.ttypes.Value()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.dst = nebula2.common.ttypes.Value()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeKey')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 3)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 4)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewEdge:
  """
  Attributes:
   - key
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = EdgeKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype183, _size180) = iprot.readListBegin()
          if _size180 >= 0:
            for _i184 in six.moves.range(_size180):
              _elem185 = nebula2.common.ttypes.Value()
              _elem185.read(iprot)
              self.props.append(_elem185)
          else: 
            while iprot.peekList():
              _elem186 = nebula2.common.ttypes.Value()
              _elem186.read(iprot)
              self.props.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewEdge')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter187 in self.props:
        iter187.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - overwritable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype189, _vtype190, _size188 ) = iprot.readMapBegin() 
          if _size188 >= 0:
            for _i192 in six.moves.range(_size188):
              _key193 = iprot.readI32()
              _val194 = []
              (_etype198, _size195) = iprot.readListBegin()
              if _size195 >= 0:
                for _i199 in six.moves.range(_size195):
                  _elem200 = NewVertex()
                  _elem200.read(iprot)
                  _val194.append(_elem200)
              else: 
                while iprot.peekList():
                  _elem201 = NewVertex()
                  _elem201.read(iprot)
                  _val194.append(_elem201)
              iprot.readListEnd()
              self.parts[_key193] = _val194
          else: 
            while iprot.peekMap():
              _key202 = iprot.readI32()
              _val203 = []
              (_etype207, _size204) = iprot.readListBegin()
              if _size204 >= 0:
                for _i208 in six.moves.range(_size204):
                  _elem209 = NewVertex()
                  _elem209.read(iprot)
                  _val203.append(_elem209)
              else: 
                while iprot.peekList():
                  _elem210 = NewVertex()
                  _elem210.read(iprot)
                  _val203.append(_elem210)
              iprot.readListEnd()
              self.parts[_key202] = _val203
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.prop_names = {}
          (_ktype212, _vtype213, _size211 ) = iprot.readMapBegin() 
          if _size211 >= 0:
            for _i215 in six.moves.range(_size211):
              _key216 = iprot.readI32()
              _val217 = []
              (_etype221, _size218) = iprot.readListBegin()
              if _size218 >= 0:
                for _i222 in six.moves.range(_size218):
                  _elem223 = iprot.readString()
                  _val217.append(_elem223)
              else: 
                while iprot.peekList():
                  _elem224 = iprot.readString()
                  _val217.append(_elem224)
              iprot.readListEnd()
              self.prop_names[_key216] = _val217
          else: 
            while iprot.peekMap():
              _key225 = iprot.readI32()
              _val226 = []
              (_etype230, _size227) = iprot.readListBegin()
              if _size227 >= 0:
                for _i231 in six.moves.range(_size227):
                  _elem232 = iprot.readString()
                  _val226.append(_elem232)
              else: 
                while iprot.peekList():
                  _elem233 = iprot.readString()
                  _val226.append(_elem233)
              iprot.readListEnd()
              self.prop_names[_key225] = _val226
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.overwritable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter234,viter235 in self.parts.items():
        oprot.writeI32(kiter234)
        oprot.writeListBegin(TType.STRUCT, len(viter235))
        for iter236 in viter235:
          iter236.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.prop_names))
      for kiter237,viter238 in self.prop_names.items():
        oprot.writeI32(kiter237)
        oprot.writeListBegin(TType.STRING, len(viter238))
        for iter239 in viter238:
          oprot.writeString(iter239)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.overwritable != None:
      oprot.writeFieldBegin('overwritable', TType.BOOL, 4)
      oprot.writeBool(self.overwritable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.overwritable is not None:
      value = pprint.pformat(self.overwritable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    overwritable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - overwritable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype241, _vtype242, _size240 ) = iprot.readMapBegin() 
          if _size240 >= 0:
            for _i244 in six.moves.range(_size240):
              _key245 = iprot.readI32()
              _val246 = []
              (_etype250, _size247) = iprot.readListBegin()
              if _size247 >= 0:
                for _i251 in six.moves.range(_size247):
                  _elem252 = NewEdge()
                  _elem252.read(iprot)
                  _val246.append(_elem252)
              else: 
                while iprot.peekList():
                  _elem253 = NewEdge()
                  _elem253.read(iprot)
                  _val246.append(_elem253)
              iprot.readListEnd()
              self.parts[_key245] = _val246
          else: 
            while iprot.peekMap():
              _key254 = iprot.readI32()
              _val255 = []
              (_etype259, _size256) = iprot.readListBegin()
              if _size256 >= 0:
                for _i260 in six.moves.range(_size256):
                  _elem261 = NewEdge()
                  _elem261.read(iprot)
                  _val255.append(_elem261)
              else: 
                while iprot.peekList():
                  _elem262 = NewEdge()
                  _elem262.read(iprot)
                  _val255.append(_elem262)
              iprot.readListEnd()
              self.parts[_key254] = _val255
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prop_names = []
          (_etype266, _size263) = iprot.readListBegin()
          if _size263 >= 0:
            for _i267 in six.moves.range(_size263):
              _elem268 = iprot.readString()
              self.prop_names.append(_elem268)
          else: 
            while iprot.peekList():
              _elem269 = iprot.readString()
              self.prop_names.append(_elem269)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.overwritable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter270,viter271 in self.parts.items():
        oprot.writeI32(kiter270)
        oprot.writeListBegin(TType.STRUCT, len(viter271))
        for iter272 in viter271:
          iter272.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.prop_names))
      for iter273 in self.prop_names:
        oprot.writeString(iter273)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.overwritable != None:
      oprot.writeFieldBegin('overwritable', TType.BOOL, 4)
      oprot.writeBool(self.overwritable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.overwritable is not None:
      value = pprint.pformat(self.overwritable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    overwritable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DeleteVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype275, _vtype276, _size274 ) = iprot.readMapBegin() 
          if _size274 >= 0:
            for _i278 in six.moves.range(_size274):
              _key279 = iprot.readI32()
              _val280 = []
              (_etype284, _size281) = iprot.readListBegin()
              if _size281 >= 0:
                for _i285 in six.moves.range(_size281):
                  _elem286 = nebula2.common.ttypes.Value()
                  _elem286.read(iprot)
                  _val280.append(_elem286)
              else: 
                while iprot.peekList():
                  _elem287 = nebula2.common.ttypes.Value()
                  _elem287.read(iprot)
                  _val280.append(_elem287)
              iprot.readListEnd()
              self.parts[_key279] = _val280
          else: 
            while iprot.peekMap():
              _key288 = iprot.readI32()
              _val289 = []
              (_etype293, _size290) = iprot.readListBegin()
              if _size290 >= 0:
                for _i294 in six.moves.range(_size290):
                  _elem295 = nebula2.common.ttypes.Value()
                  _elem295.read(iprot)
                  _val289.append(_elem295)
              else: 
                while iprot.peekList():
                  _elem296 = nebula2.common.ttypes.Value()
                  _elem296.read(iprot)
                  _val289.append(_elem296)
              iprot.readListEnd()
              self.parts[_key288] = _val289
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter297,viter298 in self.parts.items():
        oprot.writeI32(kiter297)
        oprot.writeListBegin(TType.STRUCT, len(viter298))
        for iter299 in viter298:
          iter299.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DeleteEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype301, _vtype302, _size300 ) = iprot.readMapBegin() 
          if _size300 >= 0:
            for _i304 in six.moves.range(_size300):
              _key305 = iprot.readI32()
              _val306 = []
              (_etype310, _size307) = iprot.readListBegin()
              if _size307 >= 0:
                for _i311 in six.moves.range(_size307):
                  _elem312 = EdgeKey()
                  _elem312.read(iprot)
                  _val306.append(_elem312)
              else: 
                while iprot.peekList():
                  _elem313 = EdgeKey()
                  _elem313.read(iprot)
                  _val306.append(_elem313)
              iprot.readListEnd()
              self.parts[_key305] = _val306
          else: 
            while iprot.peekMap():
              _key314 = iprot.readI32()
              _val315 = []
              (_etype319, _size316) = iprot.readListBegin()
              if _size316 >= 0:
                for _i320 in six.moves.range(_size316):
                  _elem321 = EdgeKey()
                  _elem321.read(iprot)
                  _val315.append(_elem321)
              else: 
                while iprot.peekList():
                  _elem322 = EdgeKey()
                  _elem322.read(iprot)
                  _val315.append(_elem322)
              iprot.readListEnd()
              self.parts[_key314] = _val315
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter323,viter324 in self.parts.items():
        oprot.writeI32(kiter323)
        oprot.writeListBegin(TType.STRUCT, len(viter324))
        for iter325 in viter324:
          iter325.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: UpdateResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdatedProp:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.name == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'name' was not found in serialized data! Struct: UpdatedProp")

    if self.value == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'value' was not found in serialized data! Struct: UpdatedProp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdatedProp')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateVertexRequest:
  """
  Attributes:
   - space_id
   - part_id
   - vertex_id
   - tag_id
   - updated_props
   - insertable
   - return_props
   - condition
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.vertex_id = nebula2.common.ttypes.Value()
          self.vertex_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype329, _size326) = iprot.readListBegin()
          if _size326 >= 0:
            for _i330 in six.moves.range(_size326):
              _elem331 = UpdatedProp()
              _elem331.read(iprot)
              self.updated_props.append(_elem331)
          else: 
            while iprot.peekList():
              _elem332 = UpdatedProp()
              _elem332.read(iprot)
              self.updated_props.append(_elem332)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype336, _size333) = iprot.readListBegin()
          if _size333 >= 0:
            for _i337 in six.moves.range(_size333):
              _elem338 = iprot.readString()
              self.return_props.append(_elem338)
          else: 
            while iprot.peekList():
              _elem339 = iprot.readString()
              self.return_props.append(_elem339)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.tag_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'tag_id' was not found in serialized data! Struct: UpdateVertexRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.STRUCT, 3)
      self.vertex_id.write(oprot)
      oprot.writeFieldEnd()
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 4)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter340 in self.updated_props:
        iter340.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[6][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 6)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter341 in self.return_props:
        oprot.writeString(iter341)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 8)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateEdgeRequest:
  """
  Attributes:
   - space_id
   - part_id
   - edge_key
   - updated_props
   - insertable
   - return_props
   - condition
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.edge_key = EdgeKey()
          self.edge_key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype345, _size342) = iprot.readListBegin()
          if _size342 >= 0:
            for _i346 in six.moves.range(_size342):
              _elem347 = UpdatedProp()
              _elem347.read(iprot)
              self.updated_props.append(_elem347)
          else: 
            while iprot.peekList():
              _elem348 = UpdatedProp()
              _elem348.read(iprot)
              self.updated_props.append(_elem348)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype352, _size349) = iprot.readListBegin()
          if _size349 >= 0:
            for _i353 in six.moves.range(_size349):
              _elem354 = iprot.readString()
              self.return_props.append(_elem354)
          else: 
            while iprot.peekList():
              _elem355 = iprot.readString()
              self.return_props.append(_elem355)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.edge_key != None:
      oprot.writeFieldBegin('edge_key', TType.STRUCT, 3)
      self.edge_key.write(oprot)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter356 in self.updated_props:
        iter356.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[5][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 5)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter357 in self.return_props:
        oprot.writeString(iter357)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 7)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.edge_key is not None:
      value = pprint.pformat(self.edge_key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_key=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUUIDReq:
  """
  Attributes:
   - space_id
   - part_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUUIDResp:
  """
  Attributes:
   - result
   - id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.id = nebula2.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetUUIDResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 2)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookupIndexResp:
  """
  Attributes:
   - result
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = nebula2.common.ttypes.DataSet()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: LookupIndexResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexColumnHint:
  """
  Attributes:
   - column_name
   - scan_type
   - begin_value
   - end_value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.scan_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.begin_value = nebula2.common.ttypes.Value()
          self.begin_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.end_value = nebula2.common.ttypes.Value()
          self.end_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexColumnHint')
    if self.column_name != None:
      oprot.writeFieldBegin('column_name', TType.STRING, 1)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.scan_type != None:
      oprot.writeFieldBegin('scan_type', TType.I32, 2)
      oprot.writeI32(self.scan_type)
      oprot.writeFieldEnd()
    if self.begin_value != None:
      oprot.writeFieldBegin('begin_value', TType.STRUCT, 3)
      self.begin_value.write(oprot)
      oprot.writeFieldEnd()
    if self.end_value != None:
      oprot.writeFieldBegin('end_value', TType.STRUCT, 4)
      self.end_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_name is not None:
      value = pprint.pformat(self.column_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_name=%s' % (value))
    if self.scan_type is not None:
      value = pprint.pformat(self.scan_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    scan_type=%s' % (value))
    if self.begin_value is not None:
      value = pprint.pformat(self.begin_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    begin_value=%s' % (value))
    if self.end_value is not None:
      value = pprint.pformat(self.end_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexQueryContext:
  """
  Attributes:
   - index_id
   - filter
   - column_hints
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.column_hints = []
          (_etype361, _size358) = iprot.readListBegin()
          if _size358 >= 0:
            for _i362 in six.moves.range(_size358):
              _elem363 = IndexColumnHint()
              _elem363.read(iprot)
              self.column_hints.append(_elem363)
          else: 
            while iprot.peekList():
              _elem364 = IndexColumnHint()
              _elem364.read(iprot)
              self.column_hints.append(_elem364)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexQueryContext')
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 1)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.column_hints != None:
      oprot.writeFieldBegin('column_hints', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.column_hints))
      for iter365 in self.column_hints:
        iter365.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.column_hints is not None:
      value = pprint.pformat(self.column_hints, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_hints=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexSpec:
  """
  Attributes:
   - contexts
   - is_edge
   - tag_or_edge_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.contexts = []
          (_etype369, _size366) = iprot.readListBegin()
          if _size366 >= 0:
            for _i370 in six.moves.range(_size366):
              _elem371 = IndexQueryContext()
              _elem371.read(iprot)
              self.contexts.append(_elem371)
          else: 
            while iprot.peekList():
              _elem372 = IndexQueryContext()
              _elem372.read(iprot)
              self.contexts.append(_elem372)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_edge = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.tag_or_edge_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.contexts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'contexts' was not found in serialized data! Struct: IndexSpec")

    if self.is_edge == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'is_edge' was not found in serialized data! Struct: IndexSpec")

    if self.tag_or_edge_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'tag_or_edge_id' was not found in serialized data! Struct: IndexSpec")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexSpec')
    if self.contexts != None:
      oprot.writeFieldBegin('contexts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.contexts))
      for iter373 in self.contexts:
        iter373.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_edge != None:
      oprot.writeFieldBegin('is_edge', TType.BOOL, 2)
      oprot.writeBool(self.is_edge)
      oprot.writeFieldEnd()
    if self.tag_or_edge_id != None:
      oprot.writeFieldBegin('tag_or_edge_id', TType.I32, 3)
      oprot.writeI32(self.tag_or_edge_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.contexts is not None:
      value = pprint.pformat(self.contexts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    contexts=%s' % (value))
    if self.is_edge is not None:
      value = pprint.pformat(self.is_edge, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_edge=%s' % (value))
    if self.tag_or_edge_id is not None:
      value = pprint.pformat(self.tag_or_edge_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_or_edge_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookupIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - return_columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype377, _size374) = iprot.readListBegin()
          if _size374 >= 0:
            for _i378 in six.moves.range(_size374):
              _elem379 = iprot.readI32()
              self.parts.append(_elem379)
          else: 
            while iprot.peekList():
              _elem380 = iprot.readI32()
              self.parts.append(_elem380)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype384, _size381) = iprot.readListBegin()
          if _size381 >= 0:
            for _i385 in six.moves.range(_size381):
              _elem386 = iprot.readString()
              self.return_columns.append(_elem386)
          else: 
            while iprot.peekList():
              _elem387 = iprot.readString()
              self.return_columns.append(_elem387)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.space_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'space_id' was not found in serialized data! Struct: LookupIndexRequest")

    if self.parts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'parts' was not found in serialized data! Struct: LookupIndexRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter388 in self.parts:
        oprot.writeI32(iter388)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter389 in self.return_columns:
        oprot.writeString(iter389)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookupAndTraverseRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - traverse_spec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype393, _size390) = iprot.readListBegin()
          if _size390 >= 0:
            for _i394 in six.moves.range(_size390):
              _elem395 = iprot.readI32()
              self.parts.append(_elem395)
          else: 
            while iprot.peekList():
              _elem396 = iprot.readI32()
              self.parts.append(_elem396)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.space_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'space_id' was not found in serialized data! Struct: LookupAndTraverseRequest")

    if self.parts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'parts' was not found in serialized data! Struct: LookupAndTraverseRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupAndTraverseRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter397 in self.parts:
        oprot.writeI32(iter397)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanVertexRequest:
  """
  Attributes:
   - space_id
   - part_id
   - cursor
   - return_columns
   - limit
   - start_time
   - end_time
   - filter
   - only_latest_version
   - enable_read_from_follower
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.return_columns = VertexProp()
          self.return_columns.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.only_latest_version = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.enable_read_from_follower = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.cursor != None:
      oprot.writeFieldBegin('cursor', TType.STRING, 3)
      oprot.writeString(self.cursor)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.STRUCT, 4)
      self.return_columns.write(oprot)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 5)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 6)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 7)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 8)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.only_latest_version != None:
      oprot.writeFieldBegin('only_latest_version', TType.BOOL, 9)
      oprot.writeBool(self.only_latest_version)
      oprot.writeFieldEnd()
    if self.enable_read_from_follower != None:
      oprot.writeFieldBegin('enable_read_from_follower', TType.BOOL, 10)
      oprot.writeBool(self.enable_read_from_follower)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.cursor is not None:
      value = pprint.pformat(self.cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cursor=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.only_latest_version is not None:
      value = pprint.pformat(self.only_latest_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    only_latest_version=%s' % (value))
    if self.enable_read_from_follower is not None:
      value = pprint.pformat(self.enable_read_from_follower, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_read_from_follower=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanVertexResponse:
  """
  Attributes:
   - result
   - vertex_data
   - has_next
   - next_cursor
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vertex_data = nebula2.common.ttypes.DataSet()
          self.vertex_data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_next = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.next_cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ScanVertexResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertexResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertex_data != None:
      oprot.writeFieldBegin('vertex_data', TType.STRUCT, 2)
      self.vertex_data.write(oprot)
      oprot.writeFieldEnd()
    if self.has_next != None:
      oprot.writeFieldBegin('has_next', TType.BOOL, 3)
      oprot.writeBool(self.has_next)
      oprot.writeFieldEnd()
    if self.next_cursor != None:
      oprot.writeFieldBegin('next_cursor', TType.STRING, 4)
      oprot.writeString(self.next_cursor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertex_data is not None:
      value = pprint.pformat(self.vertex_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_data=%s' % (value))
    if self.has_next is not None:
      value = pprint.pformat(self.has_next, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    has_next=%s' % (value))
    if self.next_cursor is not None:
      value = pprint.pformat(self.next_cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    next_cursor=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanEdgeRequest:
  """
  Attributes:
   - space_id
   - part_id
   - cursor
   - return_columns
   - limit
   - start_time
   - end_time
   - filter
   - only_latest_version
   - enable_read_from_follower
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.return_columns = EdgeProp()
          self.return_columns.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.only_latest_version = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.enable_read_from_follower = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.cursor != None:
      oprot.writeFieldBegin('cursor', TType.STRING, 3)
      oprot.writeString(self.cursor)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.STRUCT, 4)
      self.return_columns.write(oprot)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 5)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 6)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 7)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 8)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.only_latest_version != None:
      oprot.writeFieldBegin('only_latest_version', TType.BOOL, 9)
      oprot.writeBool(self.only_latest_version)
      oprot.writeFieldEnd()
    if self.enable_read_from_follower != None:
      oprot.writeFieldBegin('enable_read_from_follower', TType.BOOL, 10)
      oprot.writeBool(self.enable_read_from_follower)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.cursor is not None:
      value = pprint.pformat(self.cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cursor=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.only_latest_version is not None:
      value = pprint.pformat(self.only_latest_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    only_latest_version=%s' % (value))
    if self.enable_read_from_follower is not None:
      value = pprint.pformat(self.enable_read_from_follower, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_read_from_follower=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanEdgeResponse:
  """
  Attributes:
   - result
   - edge_data
   - has_next
   - next_cursor
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.edge_data = nebula2.common.ttypes.DataSet()
          self.edge_data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_next = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.next_cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ScanEdgeResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdgeResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.edge_data != None:
      oprot.writeFieldBegin('edge_data', TType.STRUCT, 2)
      self.edge_data.write(oprot)
      oprot.writeFieldEnd()
    if self.has_next != None:
      oprot.writeFieldBegin('has_next', TType.BOOL, 3)
      oprot.writeBool(self.has_next)
      oprot.writeFieldEnd()
    if self.next_cursor != None:
      oprot.writeFieldBegin('next_cursor', TType.STRING, 4)
      oprot.writeString(self.next_cursor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.edge_data is not None:
      value = pprint.pformat(self.edge_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_data=%s' % (value))
    if self.has_next is not None:
      value = pprint.pformat(self.has_next, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    has_next=%s' % (value))
    if self.next_cursor is not None:
      value = pprint.pformat(self.next_cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    next_cursor=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TaskPara:
  """
  Attributes:
   - space_id
   - parts
   - task_specfic_paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype401, _size398) = iprot.readListBegin()
          if _size398 >= 0:
            for _i402 in six.moves.range(_size398):
              _elem403 = iprot.readI32()
              self.parts.append(_elem403)
          else: 
            while iprot.peekList():
              _elem404 = iprot.readI32()
              self.parts.append(_elem404)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.task_specfic_paras = []
          (_etype408, _size405) = iprot.readListBegin()
          if _size405 >= 0:
            for _i409 in six.moves.range(_size405):
              _elem410 = iprot.readString()
              self.task_specfic_paras.append(_elem410)
          else: 
            while iprot.peekList():
              _elem411 = iprot.readString()
              self.task_specfic_paras.append(_elem411)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TaskPara')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter412 in self.parts:
        oprot.writeI32(iter412)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.task_specfic_paras != None:
      oprot.writeFieldBegin('task_specfic_paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.task_specfic_paras))
      for iter413 in self.task_specfic_paras:
        oprot.writeString(iter413)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.task_specfic_paras is not None:
      value = pprint.pformat(self.task_specfic_paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_specfic_paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddAdminTaskRequest:
  """
  Attributes:
   - cmd
   - job_id
   - task_id
   - para
   - concurrency
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.para = TaskPara()
          self.para.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.concurrency = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddAdminTaskRequest')
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 1)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 2)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 3)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.para != None:
      oprot.writeFieldBegin('para', TType.STRUCT, 4)
      self.para.write(oprot)
      oprot.writeFieldEnd()
    if self.concurrency != None:
      oprot.writeFieldBegin('concurrency', TType.I32, 5)
      oprot.writeI32(self.concurrency)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.para is not None:
      value = pprint.pformat(self.para, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    para=%s' % (value))
    if self.concurrency is not None:
      value = pprint.pformat(self.concurrency, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    concurrency=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class StopAdminTaskRequest:
  """
  Attributes:
   - job_id
   - task_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StopAdminTaskRequest')
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 1)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 2)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdminExecResp:
  """
  Attributes:
   - result
   - statis
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.statis = nebula2.meta.ttypes.StatisItem()
          self.statis.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: AdminExecResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminExecResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.statis != None:
      oprot.writeFieldBegin('statis', TType.STRUCT, 2)
      self.statis.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.statis is not None:
      value = pprint.pformat(self.statis, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    statis=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TransLeaderReq:
  """
  Attributes:
   - space_id
   - part_id
   - new_leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_leader = nebula2.common.ttypes.HostAddr()
          self.new_leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TransLeaderReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.new_leader != None:
      oprot.writeFieldBegin('new_leader', TType.STRUCT, 3)
      self.new_leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.new_leader is not None:
      value = pprint.pformat(self.new_leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddPartReq:
  """
  Attributes:
   - space_id
   - part_id
   - as_learner
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.as_learner = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.peers = []
          (_etype417, _size414) = iprot.readListBegin()
          if _size414 >= 0:
            for _i418 in six.moves.range(_size414):
              _elem419 = nebula2.common.ttypes.HostAddr()
              _elem419.read(iprot)
              self.peers.append(_elem419)
          else: 
            while iprot.peekList():
              _elem420 = nebula2.common.ttypes.HostAddr()
              _elem420.read(iprot)
              self.peers.append(_elem420)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddPartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.as_learner != None:
      oprot.writeFieldBegin('as_learner', TType.BOOL, 3)
      oprot.writeBool(self.as_learner)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter421 in self.peers:
        iter421.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.as_learner is not None:
      value = pprint.pformat(self.as_learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    as_learner=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddLearnerReq:
  """
  Attributes:
   - space_id
   - part_id
   - learner
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.learner = nebula2.common.ttypes.HostAddr()
          self.learner.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddLearnerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.learner != None:
      oprot.writeFieldBegin('learner', TType.STRUCT, 3)
      self.learner.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.learner is not None:
      value = pprint.pformat(self.learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    learner=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemovePartReq:
  """
  Attributes:
   - space_id
   - part_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemovePartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MemberChangeReq:
  """
  Attributes:
   - space_id
   - part_id
   - peer
   - add
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.peer = nebula2.common.ttypes.HostAddr()
          self.peer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.add = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MemberChangeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peer != None:
      oprot.writeFieldBegin('peer', TType.STRUCT, 3)
      self.peer.write(oprot)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BOOL, 4)
      oprot.writeBool(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peer is not None:
      value = pprint.pformat(self.peer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peer=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CatchUpDataReq:
  """
  Attributes:
   - space_id
   - part_id
   - target
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.target = nebula2.common.ttypes.HostAddr()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CatchUpDataReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.target != None:
      oprot.writeFieldBegin('target', TType.STRUCT, 3)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.target is not None:
      value = pprint.pformat(self.target, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    target=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetLeaderReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateCPRequest:
  """
  Attributes:
   - space_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropCPRequest:
  """
  Attributes:
   - space_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropCPRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BlockingSignRequest:
  """
  Attributes:
   - space_id
   - sign
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sign = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.sign == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'sign' was not found in serialized data! Struct: BlockingSignRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BlockingSignRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.sign != None:
      oprot.writeFieldBegin('sign', TType.I32, 2)
      oprot.writeI32(self.sign)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.sign is not None:
      value = pprint.pformat(self.sign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sign=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetLeaderPartsResp:
  """
  Attributes:
   - result
   - leader_parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype423, _vtype424, _size422 ) = iprot.readMapBegin() 
          if _size422 >= 0:
            for _i426 in six.moves.range(_size422):
              _key427 = iprot.readI32()
              _val428 = []
              (_etype432, _size429) = iprot.readListBegin()
              if _size429 >= 0:
                for _i433 in six.moves.range(_size429):
                  _elem434 = iprot.readI32()
                  _val428.append(_elem434)
              else: 
                while iprot.peekList():
                  _elem435 = iprot.readI32()
                  _val428.append(_elem435)
              iprot.readListEnd()
              self.leader_parts[_key427] = _val428
          else: 
            while iprot.peekMap():
              _key436 = iprot.readI32()
              _val437 = []
              (_etype441, _size438) = iprot.readListBegin()
              if _size438 >= 0:
                for _i442 in six.moves.range(_size438):
                  _elem443 = iprot.readI32()
                  _val437.append(_elem443)
              else: 
                while iprot.peekList():
                  _elem444 = iprot.readI32()
                  _val437.append(_elem444)
              iprot.readListEnd()
              self.leader_parts[_key436] = _val437
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetLeaderPartsResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderPartsResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_parts))
      for kiter445,viter446 in self.leader_parts.items():
        oprot.writeI32(kiter445)
        oprot.writeListBegin(TType.I32, len(viter446))
        for iter447 in viter446:
          oprot.writeI32(iter447)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CheckPeersReq:
  """
  Attributes:
   - space_id
   - part_id
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype451, _size448) = iprot.readListBegin()
          if _size448 >= 0:
            for _i452 in six.moves.range(_size448):
              _elem453 = nebula2.common.ttypes.HostAddr()
              _elem453.read(iprot)
              self.peers.append(_elem453)
          else: 
            while iprot.peekList():
              _elem454 = nebula2.common.ttypes.HostAddr()
              _elem454.read(iprot)
              self.peers.append(_elem454)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckPeersReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter455 in self.peers:
        iter455.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RebuildIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - index_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype459, _size456) = iprot.readListBegin()
          if _size456 >= 0:
            for _i460 in six.moves.range(_size456):
              _elem461 = iprot.readI32()
              self.parts.append(_elem461)
          else: 
            while iprot.peekList():
              _elem462 = iprot.readI32()
              self.parts.append(_elem462)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter463 in self.parts:
        oprot.writeI32(iter463)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 3)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateCPResp:
  """
  Attributes:
   - result
   - path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: CreateCPResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PartitionInfoResp:
  """
  Attributes:
   - result
   - backup_name
   - partition_info
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.backup_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.partition_info = nebula2.common.ttypes.PartitionBackupInfo()
          self.partition_info.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: PartitionInfoResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionInfoResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.backup_name != None:
      oprot.writeFieldBegin('backup_name', TType.STRING, 2)
      oprot.writeString(self.backup_name)
      oprot.writeFieldEnd()
    if self.partition_info != None:
      oprot.writeFieldBegin('partition_info', TType.STRUCT, 3)
      self.partition_info.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.backup_name is not None:
      value = pprint.pformat(self.backup_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    backup_name=%s' % (value))
    if self.partition_info is not None:
      value = pprint.pformat(self.partition_info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    partition_info=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PartitionInfoRequest:
  """
  Attributes:
   - space_id
   - backup_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.backup_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionInfoRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.backup_name != None:
      oprot.writeFieldBegin('backup_name', TType.STRING, 2)
      oprot.writeString(self.backup_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.backup_name is not None:
      value = pprint.pformat(self.backup_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    backup_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVGetRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_partly
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype465, _vtype466, _size464 ) = iprot.readMapBegin() 
          if _size464 >= 0:
            for _i468 in six.moves.range(_size464):
              _key469 = iprot.readI32()
              _val470 = []
              (_etype474, _size471) = iprot.readListBegin()
              if _size471 >= 0:
                for _i475 in six.moves.range(_size471):
                  _elem476 = iprot.readString()
                  _val470.append(_elem476)
              else: 
                while iprot.peekList():
                  _elem477 = iprot.readString()
                  _val470.append(_elem477)
              iprot.readListEnd()
              self.parts[_key469] = _val470
          else: 
            while iprot.peekMap():
              _key478 = iprot.readI32()
              _val479 = []
              (_etype483, _size480) = iprot.readListBegin()
              if _size480 >= 0:
                for _i484 in six.moves.range(_size480):
                  _elem485 = iprot.readString()
                  _val479.append(_elem485)
              else: 
                while iprot.peekList():
                  _elem486 = iprot.readString()
                  _val479.append(_elem486)
              iprot.readListEnd()
              self.parts[_key478] = _val479
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.return_partly = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter487,viter488 in self.parts.items():
        oprot.writeI32(kiter487)
        oprot.writeListBegin(TType.STRING, len(viter488))
        for iter489 in viter488:
          oprot.writeString(iter489)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_partly != None:
      oprot.writeFieldBegin('return_partly', TType.BOOL, 3)
      oprot.writeBool(self.return_partly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_partly is not None:
      value = pprint.pformat(self.return_partly, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_partly=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVGetResponse:
  """
  Attributes:
   - result
   - key_values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.key_values = {}
          (_ktype491, _vtype492, _size490 ) = iprot.readMapBegin() 
          if _size490 >= 0:
            for _i494 in six.moves.range(_size490):
              _key495 = iprot.readString()
              _val496 = iprot.readString()
              self.key_values[_key495] = _val496
          else: 
            while iprot.peekMap():
              _key497 = iprot.readString()
              _val498 = iprot.readString()
              self.key_values[_key497] = _val498
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: KVGetResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.key_values != None:
      oprot.writeFieldBegin('key_values', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.key_values))
      for kiter499,viter500 in self.key_values.items():
        oprot.writeString(kiter499)
        oprot.writeString(viter500)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.key_values is not None:
      value = pprint.pformat(self.key_values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key_values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVPutRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype502, _vtype503, _size501 ) = iprot.readMapBegin() 
          if _size501 >= 0:
            for _i505 in six.moves.range(_size501):
              _key506 = iprot.readI32()
              _val507 = []
              (_etype511, _size508) = iprot.readListBegin()
              if _size508 >= 0:
                for _i512 in six.moves.range(_size508):
                  _elem513 = nebula2.common.ttypes.KeyValue()
                  _elem513.read(iprot)
                  _val507.append(_elem513)
              else: 
                while iprot.peekList():
                  _elem514 = nebula2.common.ttypes.KeyValue()
                  _elem514.read(iprot)
                  _val507.append(_elem514)
              iprot.readListEnd()
              self.parts[_key506] = _val507
          else: 
            while iprot.peekMap():
              _key515 = iprot.readI32()
              _val516 = []
              (_etype520, _size517) = iprot.readListBegin()
              if _size517 >= 0:
                for _i521 in six.moves.range(_size517):
                  _elem522 = nebula2.common.ttypes.KeyValue()
                  _elem522.read(iprot)
                  _val516.append(_elem522)
              else: 
                while iprot.peekList():
                  _elem523 = nebula2.common.ttypes.KeyValue()
                  _elem523.read(iprot)
                  _val516.append(_elem523)
              iprot.readListEnd()
              self.parts[_key515] = _val516
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVPutRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter524,viter525 in self.parts.items():
        oprot.writeI32(kiter524)
        oprot.writeListBegin(TType.STRUCT, len(viter525))
        for iter526 in viter525:
          iter526.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVRemoveRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype528, _vtype529, _size527 ) = iprot.readMapBegin() 
          if _size527 >= 0:
            for _i531 in six.moves.range(_size527):
              _key532 = iprot.readI32()
              _val533 = []
              (_etype537, _size534) = iprot.readListBegin()
              if _size534 >= 0:
                for _i538 in six.moves.range(_size534):
                  _elem539 = iprot.readString()
                  _val533.append(_elem539)
              else: 
                while iprot.peekList():
                  _elem540 = iprot.readString()
                  _val533.append(_elem540)
              iprot.readListEnd()
              self.parts[_key532] = _val533
          else: 
            while iprot.peekMap():
              _key541 = iprot.readI32()
              _val542 = []
              (_etype546, _size543) = iprot.readListBegin()
              if _size543 >= 0:
                for _i547 in six.moves.range(_size543):
                  _elem548 = iprot.readString()
                  _val542.append(_elem548)
              else: 
                while iprot.peekList():
                  _elem549 = iprot.readString()
                  _val542.append(_elem549)
              iprot.readListEnd()
              self.parts[_key541] = _val542
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVRemoveRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter550,viter551 in self.parts.items():
        oprot.writeI32(kiter550)
        oprot.writeListBegin(TType.STRING, len(viter551))
        for iter552 in viter551:
          oprot.writeString(iter552)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class InternalTxnRequest:
  """
  Attributes:
   - txn_id
   - space_id
   - part_id
   - position
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.txn_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.position = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.data = []
          (_etype556, _size553) = iprot.readListBegin()
          if _size553 >= 0:
            for _i557 in six.moves.range(_size553):
              _elem558 = []
              (_etype562, _size559) = iprot.readListBegin()
              if _size559 >= 0:
                for _i563 in six.moves.range(_size559):
                  _elem564 = iprot.readString()
                  _elem558.append(_elem564)
              else: 
                while iprot.peekList():
                  _elem565 = iprot.readString()
                  _elem558.append(_elem565)
              iprot.readListEnd()
              self.data.append(_elem558)
          else: 
            while iprot.peekList():
              _elem566 = []
              (_etype570, _size567) = iprot.readListBegin()
              if _size567 >= 0:
                for _i571 in six.moves.range(_size567):
                  _elem572 = iprot.readString()
                  _elem566.append(_elem572)
              else: 
                while iprot.peekList():
                  _elem573 = iprot.readString()
                  _elem566.append(_elem573)
              iprot.readListEnd()
              self.data.append(_elem566)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InternalTxnRequest')
    if self.txn_id != None:
      oprot.writeFieldBegin('txn_id', TType.I64, 1)
      oprot.writeI64(self.txn_id)
      oprot.writeFieldEnd()
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 2)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 3)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.position != None:
      oprot.writeFieldBegin('position', TType.I32, 4)
      oprot.writeI32(self.position)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.LIST, 5)
      oprot.writeListBegin(TType.LIST, len(self.data))
      for iter574 in self.data:
        oprot.writeListBegin(TType.STRING, len(iter574))
        for iter575 in iter574:
          oprot.writeString(iter575)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.txn_id is not None:
      value = pprint.pformat(self.txn_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    txn_id=%s' % (value))
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.position is not None:
      value = pprint.pformat(self.position, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    position=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetValueRequest:
  """
  Attributes:
   - space_id
   - part_id
   - key
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetValueRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 3)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetValueResponse:
  """
  Attributes:
   - result
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetValueResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetValueResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(PartitionResult)
PartitionResult.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 0, ), # 1
  (2, TType.I32, 'part_id', None, None, 0, ), # 2
  (3, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 3
)

PartitionResult.thrift_struct_annotations = {
}
PartitionResult.thrift_field_annotations = {
}

def PartitionResult__init__(self, code=None, part_id=None, leader=None,):
  self.code = code
  self.part_id = part_id
  self.leader = leader

PartitionResult.__init__ = PartitionResult__init__

def PartitionResult__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

PartitionResult.__getstate__ = lambda self: self.__dict__.copy()
PartitionResult.__setstate__ = PartitionResult__setstate__

all_structs.append(ResponseCommon)
ResponseCommon.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'failed_parts', (TType.STRUCT,[PartitionResult, PartitionResult.thrift_spec, False]), None, 0, ), # 1
  (2, TType.I32, 'latency_in_us', None, None, 0, ), # 2
)

ResponseCommon.thrift_struct_annotations = {
}
ResponseCommon.thrift_field_annotations = {
}

def ResponseCommon__init__(self, failed_parts=None, latency_in_us=None,):
  self.failed_parts = failed_parts
  self.latency_in_us = latency_in_us

ResponseCommon.__init__ = ResponseCommon__init__

def ResponseCommon__setstate__(self, state):
  state.setdefault('failed_parts', None)
  state.setdefault('latency_in_us', None)
  self.__dict__ = state

ResponseCommon.__getstate__ = lambda self: self.__dict__.copy()
ResponseCommon.__setstate__ = ResponseCommon__setstate__

all_structs.append(StatProp)
StatProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'prop', False, None, 2, ), # 2
  (3, TType.I32, 'stat', StatType, None, 2, ), # 3
)

StatProp.thrift_struct_annotations = {
}
StatProp.thrift_field_annotations = {
}

def StatProp__init__(self, alias=None, prop=None, stat=None,):
  self.alias = alias
  self.prop = prop
  self.stat = stat

StatProp.__init__ = StatProp__init__

def StatProp__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('prop', None)
  state.setdefault('stat', None)
  self.__dict__ = state

StatProp.__getstate__ = lambda self: self.__dict__.copy()
StatProp.__setstate__ = StatProp__setstate__

all_structs.append(Expr)
Expr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'expr', False, None, 2, ), # 2
)

Expr.thrift_struct_annotations = {
}
Expr.thrift_field_annotations = {
}

def Expr__init__(self, alias=None, expr=None,):
  self.alias = alias
  self.expr = expr

Expr.__init__ = Expr__init__

def Expr__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('expr', None)
  self.__dict__ = state

Expr.__getstate__ = lambda self: self.__dict__.copy()
Expr.__setstate__ = Expr__setstate__

all_structs.append(EdgeProp)
EdgeProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

EdgeProp.thrift_struct_annotations = {
}
EdgeProp.thrift_field_annotations = {
}

def EdgeProp__init__(self, type=None, props=None,):
  self.type = type
  self.props = props

EdgeProp.__init__ = EdgeProp__init__

def EdgeProp__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('props', None)
  self.__dict__ = state

EdgeProp.__getstate__ = lambda self: self.__dict__.copy()
EdgeProp.__setstate__ = EdgeProp__setstate__

all_structs.append(VertexProp)
VertexProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

VertexProp.thrift_struct_annotations = {
}
VertexProp.thrift_field_annotations = {
}

def VertexProp__init__(self, tag=None, props=None,):
  self.tag = tag
  self.props = props

VertexProp.__init__ = VertexProp__init__

def VertexProp__setstate__(self, state):
  state.setdefault('tag', None)
  state.setdefault('props', None)
  self.__dict__ = state

VertexProp.__getstate__ = lambda self: self.__dict__.copy()
VertexProp.__setstate__ = VertexProp__setstate__

all_structs.append(OrderBy)
OrderBy.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'prop', False, None, 2, ), # 1
  (2, TType.I32, 'direction', OrderDirection, None, 2, ), # 2
)

OrderBy.thrift_struct_annotations = {
}
OrderBy.thrift_field_annotations = {
}

def OrderBy__init__(self, prop=None, direction=None,):
  self.prop = prop
  self.direction = direction

OrderBy.__init__ = OrderBy__init__

def OrderBy__setstate__(self, state):
  state.setdefault('prop', None)
  state.setdefault('direction', None)
  self.__dict__ = state

OrderBy.__getstate__ = lambda self: self.__dict__.copy()
OrderBy.__setstate__ = OrderBy__setstate__

all_structs.append(TraverseSpec)
TraverseSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'edge_types', (TType.I32,None), None, 2, ), # 1
  (2, TType.I32, 'edge_direction', EdgeDirection,   1, 2, ), # 2
  (3, TType.BOOL, 'dedup', None, False, 2, ), # 3
  (4, TType.LIST, 'stat_props', (TType.STRUCT,[StatProp, StatProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 5
  (6, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 6
  (7, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 7
  (8, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 8
  (9, TType.BOOL, 'random', None, None, 1, ), # 9
  (10, TType.I64, 'limit', None, None, 1, ), # 10
  (11, TType.STRING, 'filter', False, None, 1, ), # 11
)

TraverseSpec.thrift_struct_annotations = {
}
TraverseSpec.thrift_field_annotations = {
}

def TraverseSpec__init__(self, edge_types=None, edge_direction=TraverseSpec.thrift_spec[2][4], dedup=TraverseSpec.thrift_spec[3][4], stat_props=None, vertex_props=None, edge_props=None, expressions=None, order_by=None, random=None, limit=None, filter=None,):
  self.edge_types = edge_types
  self.edge_direction = edge_direction
  self.dedup = dedup
  self.stat_props = stat_props
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.order_by = order_by
  self.random = random
  self.limit = limit
  self.filter = filter

TraverseSpec.__init__ = TraverseSpec__init__

def TraverseSpec__setstate__(self, state):
  state.setdefault('edge_types', None)
  state.setdefault('edge_direction',   1)
  state.setdefault('dedup', False)
  state.setdefault('stat_props', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('order_by', None)
  state.setdefault('random', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  self.__dict__ = state

TraverseSpec.__getstate__ = lambda self: self.__dict__.copy()
TraverseSpec.__setstate__ = TraverseSpec__setstate__

all_structs.append(GetNeighborsRequest)
GetNeighborsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Row, nebula2.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
)

GetNeighborsRequest.thrift_struct_annotations = {
}
GetNeighborsRequest.thrift_field_annotations = {
}

def GetNeighborsRequest__init__(self, space_id=None, column_names=None, parts=None, traverse_spec=None,):
  self.space_id = space_id
  self.column_names = column_names
  self.parts = parts
  self.traverse_spec = traverse_spec

GetNeighborsRequest.__init__ = GetNeighborsRequest__init__

def GetNeighborsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('column_names', None)
  state.setdefault('parts', None)
  state.setdefault('traverse_spec', None)
  self.__dict__ = state

GetNeighborsRequest.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsRequest.__setstate__ = GetNeighborsRequest__setstate__

all_structs.append(GetNeighborsResponse)
GetNeighborsResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'vertices', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetNeighborsResponse.thrift_struct_annotations = {
}
GetNeighborsResponse.thrift_field_annotations = {
}

def GetNeighborsResponse__init__(self, result=None, vertices=None,):
  self.result = result
  self.vertices = vertices

GetNeighborsResponse.__init__ = GetNeighborsResponse__init__

def GetNeighborsResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertices', None)
  self.__dict__ = state

GetNeighborsResponse.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsResponse.__setstate__ = GetNeighborsResponse__setstate__

all_structs.append(ExecResponse)
ExecResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

ExecResponse.thrift_struct_annotations = {
}
ExecResponse.thrift_field_annotations = {
}

def ExecResponse__init__(self, result=None,):
  self.result = result

ExecResponse.__init__ = ExecResponse__init__

def ExecResponse__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

ExecResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecResponse.__setstate__ = ExecResponse__setstate__

all_structs.append(GetPropRequest)
GetPropRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Row, nebula2.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 3
  (4, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 5
  (6, TType.BOOL, 'dedup', None, False, 2, ), # 6
  (7, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 7
  (8, TType.I64, 'limit', None, None, 1, ), # 8
  (9, TType.STRING, 'filter', False, None, 1, ), # 9
)

GetPropRequest.thrift_struct_annotations = {
}
GetPropRequest.thrift_field_annotations = {
}

def GetPropRequest__init__(self, space_id=None, parts=None, vertex_props=None, edge_props=None, expressions=None, dedup=GetPropRequest.thrift_spec[6][4], order_by=None, limit=None, filter=None,):
  self.space_id = space_id
  self.parts = parts
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.dedup = dedup
  self.order_by = order_by
  self.limit = limit
  self.filter = filter

GetPropRequest.__init__ = GetPropRequest__init__

def GetPropRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('dedup', False)
  state.setdefault('order_by', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  self.__dict__ = state

GetPropRequest.__getstate__ = lambda self: self.__dict__.copy()
GetPropRequest.__setstate__ = GetPropRequest__setstate__

all_structs.append(GetPropResponse)
GetPropResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetPropResponse.thrift_struct_annotations = {
}
GetPropResponse.thrift_field_annotations = {
}

def GetPropResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

GetPropResponse.__init__ = GetPropResponse__init__

def GetPropResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

GetPropResponse.__getstate__ = lambda self: self.__dict__.copy()
GetPropResponse.__setstate__ = GetPropResponse__setstate__

all_structs.append(NewTag)
NewTag.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewTag.thrift_struct_annotations = {
}
NewTag.thrift_field_annotations = {
}

def NewTag__init__(self, tag_id=None, props=None,):
  self.tag_id = tag_id
  self.props = props

NewTag.__init__ = NewTag__init__

def NewTag__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewTag.__getstate__ = lambda self: self.__dict__.copy()
NewTag.__setstate__ = NewTag__setstate__

all_structs.append(NewVertex)
NewVertex.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[NewTag, NewTag.thrift_spec, False]), None, 2, ), # 2
)

NewVertex.thrift_struct_annotations = {
}
NewVertex.thrift_field_annotations = {
}

def NewVertex__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

NewVertex.__init__ = NewVertex__init__

def NewVertex__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

NewVertex.__getstate__ = lambda self: self.__dict__.copy()
NewVertex.__setstate__ = NewVertex__setstate__

all_structs.append(EdgeKey)
EdgeKey.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
  (3, TType.I64, 'ranking', None, None, 2, ), # 3
  (4, TType.STRUCT, 'dst', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

EdgeKey.thrift_struct_annotations = {
}
EdgeKey.thrift_field_annotations = {
}

def EdgeKey__init__(self, src=None, edge_type=None, ranking=None, dst=None,):
  self.src = src
  self.edge_type = edge_type
  self.ranking = ranking
  self.dst = dst

EdgeKey.__init__ = EdgeKey__init__

def EdgeKey__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('edge_type', None)
  state.setdefault('ranking', None)
  state.setdefault('dst', None)
  self.__dict__ = state

EdgeKey.__getstate__ = lambda self: self.__dict__.copy()
EdgeKey.__setstate__ = EdgeKey__setstate__

all_structs.append(NewEdge)
NewEdge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewEdge.thrift_struct_annotations = {
}
NewEdge.thrift_field_annotations = {
}

def NewEdge__init__(self, key=None, props=None,):
  self.key = key
  self.props = props

NewEdge.__init__ = NewEdge__init__

def NewEdge__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewEdge.__getstate__ = lambda self: self.__dict__.copy()
NewEdge.__setstate__ = NewEdge__setstate__

all_structs.append(AddVerticesRequest)
AddVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewVertex, NewVertex.thrift_spec, False])), None, 2, ), # 2
  (3, TType.MAP, 'prop_names', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 3
  (4, TType.BOOL, 'overwritable', None, True, 2, ), # 4
)

AddVerticesRequest.thrift_struct_annotations = {
}
AddVerticesRequest.thrift_field_annotations = {
}

def AddVerticesRequest__init__(self, space_id=None, parts=None, prop_names=None, overwritable=AddVerticesRequest.thrift_spec[4][4],):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.overwritable = overwritable

AddVerticesRequest.__init__ = AddVerticesRequest__init__

def AddVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('overwritable', True)
  self.__dict__ = state

AddVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddVerticesRequest.__setstate__ = AddVerticesRequest__setstate__

all_structs.append(AddEdgesRequest)
AddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewEdge, NewEdge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'prop_names', (TType.STRING,False), None, 2, ), # 3
  (4, TType.BOOL, 'overwritable', None, True, 2, ), # 4
)

AddEdgesRequest.thrift_struct_annotations = {
}
AddEdgesRequest.thrift_field_annotations = {
}

def AddEdgesRequest__init__(self, space_id=None, parts=None, prop_names=None, overwritable=AddEdgesRequest.thrift_spec[4][4],):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.overwritable = overwritable

AddEdgesRequest.__init__ = AddEdgesRequest__init__

def AddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('overwritable', True)
  self.__dict__ = state

AddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddEdgesRequest.__setstate__ = AddEdgesRequest__setstate__

all_structs.append(DeleteVerticesRequest)
DeleteVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True])), None, 2, ), # 2
)

DeleteVerticesRequest.thrift_struct_annotations = {
}
DeleteVerticesRequest.thrift_field_annotations = {
}

def DeleteVerticesRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

DeleteVerticesRequest.__init__ = DeleteVerticesRequest__init__

def DeleteVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

DeleteVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteVerticesRequest.__setstate__ = DeleteVerticesRequest__setstate__

all_structs.append(DeleteEdgesRequest)
DeleteEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
)

DeleteEdgesRequest.thrift_struct_annotations = {
}
DeleteEdgesRequest.thrift_field_annotations = {
}

def DeleteEdgesRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

DeleteEdgesRequest.__init__ = DeleteEdgesRequest__init__

def DeleteEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

DeleteEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteEdgesRequest.__setstate__ = DeleteEdgesRequest__setstate__

all_structs.append(UpdateResponse)
UpdateResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

UpdateResponse.thrift_struct_annotations = {
}
UpdateResponse.thrift_field_annotations = {
}

def UpdateResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

UpdateResponse.__init__ = UpdateResponse__init__

def UpdateResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

UpdateResponse.__getstate__ = lambda self: self.__dict__.copy()
UpdateResponse.__setstate__ = UpdateResponse__setstate__

all_structs.append(UpdatedProp)
UpdatedProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRING, 'value', False, None, 0, ), # 2
)

UpdatedProp.thrift_struct_annotations = {
}
UpdatedProp.thrift_field_annotations = {
}

def UpdatedProp__init__(self, name=None, value=None,):
  self.name = name
  self.value = value

UpdatedProp.__init__ = UpdatedProp__init__

def UpdatedProp__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('value', None)
  self.__dict__ = state

UpdatedProp.__getstate__ = lambda self: self.__dict__.copy()
UpdatedProp.__setstate__ = UpdatedProp__setstate__

all_structs.append(UpdateVertexRequest)
UpdateVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'vertex_id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.I32, 'tag_id', None, None, 0, ), # 4
  (5, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 5
  (6, TType.BOOL, 'insertable', None, False, 1, ), # 6
  (7, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 7
  (8, TType.STRING, 'condition', False, None, 1, ), # 8
)

UpdateVertexRequest.thrift_struct_annotations = {
}
UpdateVertexRequest.thrift_field_annotations = {
}

def UpdateVertexRequest__init__(self, space_id=None, part_id=None, vertex_id=None, tag_id=None, updated_props=None, insertable=UpdateVertexRequest.thrift_spec[6][4], return_props=None, condition=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.vertex_id = vertex_id
  self.tag_id = tag_id
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition

UpdateVertexRequest.__init__ = UpdateVertexRequest__init__

def UpdateVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('vertex_id', None)
  state.setdefault('tag_id', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  self.__dict__ = state

UpdateVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateVertexRequest.__setstate__ = UpdateVertexRequest__setstate__

all_structs.append(UpdateEdgeRequest)
UpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'edge_key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'insertable', None, False, 1, ), # 5
  (6, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 6
  (7, TType.STRING, 'condition', False, None, 1, ), # 7
)

UpdateEdgeRequest.thrift_struct_annotations = {
}
UpdateEdgeRequest.thrift_field_annotations = {
}

def UpdateEdgeRequest__init__(self, space_id=None, part_id=None, edge_key=None, updated_props=None, insertable=UpdateEdgeRequest.thrift_spec[5][4], return_props=None, condition=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.edge_key = edge_key
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition

UpdateEdgeRequest.__init__ = UpdateEdgeRequest__init__

def UpdateEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('edge_key', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  self.__dict__ = state

UpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateEdgeRequest.__setstate__ = UpdateEdgeRequest__setstate__

all_structs.append(GetUUIDReq)
GetUUIDReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
)

GetUUIDReq.thrift_struct_annotations = {
}
GetUUIDReq.thrift_field_annotations = {
}

def GetUUIDReq__init__(self, space_id=None, part_id=None, name=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.name = name

GetUUIDReq.__init__ = GetUUIDReq__init__

def GetUUIDReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

GetUUIDReq.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDReq.__setstate__ = GetUUIDReq__setstate__

all_structs.append(GetUUIDResp)
GetUUIDResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'id', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 2
)

GetUUIDResp.thrift_struct_annotations = {
}
GetUUIDResp.thrift_field_annotations = {
}

def GetUUIDResp__init__(self, result=None, id=None,):
  self.result = result
  self.id = id

GetUUIDResp.__init__ = GetUUIDResp__init__

def GetUUIDResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('id', None)
  self.__dict__ = state

GetUUIDResp.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDResp.__setstate__ = GetUUIDResp__setstate__

all_structs.append(LookupIndexResp)
LookupIndexResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'data', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

LookupIndexResp.thrift_struct_annotations = {
}
LookupIndexResp.thrift_field_annotations = {
}

def LookupIndexResp__init__(self, result=None, data=None,):
  self.result = result
  self.data = data

LookupIndexResp.__init__ = LookupIndexResp__init__

def LookupIndexResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('data', None)
  self.__dict__ = state

LookupIndexResp.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexResp.__setstate__ = LookupIndexResp__setstate__

all_structs.append(IndexColumnHint)
IndexColumnHint.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'column_name', False, None, 2, ), # 1
  (2, TType.I32, 'scan_type', ScanType, None, 2, ), # 2
  (3, TType.STRUCT, 'begin_value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.STRUCT, 'end_value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

IndexColumnHint.thrift_struct_annotations = {
}
IndexColumnHint.thrift_field_annotations = {
}

def IndexColumnHint__init__(self, column_name=None, scan_type=None, begin_value=None, end_value=None,):
  self.column_name = column_name
  self.scan_type = scan_type
  self.begin_value = begin_value
  self.end_value = end_value

IndexColumnHint.__init__ = IndexColumnHint__init__

def IndexColumnHint__setstate__(self, state):
  state.setdefault('column_name', None)
  state.setdefault('scan_type', None)
  state.setdefault('begin_value', None)
  state.setdefault('end_value', None)
  self.__dict__ = state

IndexColumnHint.__getstate__ = lambda self: self.__dict__.copy()
IndexColumnHint.__setstate__ = IndexColumnHint__setstate__

all_structs.append(IndexQueryContext)
IndexQueryContext.thrift_spec = (
  None, # 0
  (1, TType.I32, 'index_id', None, None, 2, ), # 1
  (2, TType.STRING, 'filter', False, None, 2, ), # 2
  (3, TType.LIST, 'column_hints', (TType.STRUCT,[IndexColumnHint, IndexColumnHint.thrift_spec, False]), None, 2, ), # 3
)

IndexQueryContext.thrift_struct_annotations = {
}
IndexQueryContext.thrift_field_annotations = {
}

def IndexQueryContext__init__(self, index_id=None, filter=None, column_hints=None,):
  self.index_id = index_id
  self.filter = filter
  self.column_hints = column_hints

IndexQueryContext.__init__ = IndexQueryContext__init__

def IndexQueryContext__setstate__(self, state):
  state.setdefault('index_id', None)
  state.setdefault('filter', None)
  state.setdefault('column_hints', None)
  self.__dict__ = state

IndexQueryContext.__getstate__ = lambda self: self.__dict__.copy()
IndexQueryContext.__setstate__ = IndexQueryContext__setstate__

all_structs.append(IndexSpec)
IndexSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'contexts', (TType.STRUCT,[IndexQueryContext, IndexQueryContext.thrift_spec, False]), None, 0, ), # 1
  (2, TType.BOOL, 'is_edge', None, None, 0, ), # 2
  (3, TType.I32, 'tag_or_edge_id', None, None, 0, ), # 3
)

IndexSpec.thrift_struct_annotations = {
}
IndexSpec.thrift_field_annotations = {
}

def IndexSpec__init__(self, contexts=None, is_edge=None, tag_or_edge_id=None,):
  self.contexts = contexts
  self.is_edge = is_edge
  self.tag_or_edge_id = tag_or_edge_id

IndexSpec.__init__ = IndexSpec__init__

def IndexSpec__setstate__(self, state):
  state.setdefault('contexts', None)
  state.setdefault('is_edge', None)
  state.setdefault('tag_or_edge_id', None)
  self.__dict__ = state

IndexSpec.__getstate__ = lambda self: self.__dict__.copy()
IndexSpec.__setstate__ = IndexSpec__setstate__

all_structs.append(LookupIndexRequest)
LookupIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'return_columns', (TType.STRING,False), None, 1, ), # 4
)

LookupIndexRequest.thrift_struct_annotations = {
}
LookupIndexRequest.thrift_field_annotations = {
}

def LookupIndexRequest__init__(self, space_id=None, parts=None, indices=None, return_columns=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.return_columns = return_columns

LookupIndexRequest.__init__ = LookupIndexRequest__init__

def LookupIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('return_columns', None)
  self.__dict__ = state

LookupIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexRequest.__setstate__ = LookupIndexRequest__setstate__

all_structs.append(LookupAndTraverseRequest)
LookupAndTraverseRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
)

LookupAndTraverseRequest.thrift_struct_annotations = {
}
LookupAndTraverseRequest.thrift_field_annotations = {
}

def LookupAndTraverseRequest__init__(self, space_id=None, parts=None, indices=None, traverse_spec=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.traverse_spec = traverse_spec

LookupAndTraverseRequest.__init__ = LookupAndTraverseRequest__init__

def LookupAndTraverseRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('traverse_spec', None)
  self.__dict__ = state

LookupAndTraverseRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupAndTraverseRequest.__setstate__ = LookupAndTraverseRequest__setstate__

all_structs.append(ScanVertexRequest)
ScanVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'cursor', False, None, 1, ), # 3
  (4, TType.STRUCT, 'return_columns', [VertexProp, VertexProp.thrift_spec, False], None, 2, ), # 4
  (5, TType.I64, 'limit', None, None, 2, ), # 5
  (6, TType.I64, 'start_time', None, None, 1, ), # 6
  (7, TType.I64, 'end_time', None, None, 1, ), # 7
  (8, TType.STRING, 'filter', False, None, 1, ), # 8
  (9, TType.BOOL, 'only_latest_version', None, False, 2, ), # 9
  (10, TType.BOOL, 'enable_read_from_follower', None, True, 2, ), # 10
)

ScanVertexRequest.thrift_struct_annotations = {
}
ScanVertexRequest.thrift_field_annotations = {
}

def ScanVertexRequest__init__(self, space_id=None, part_id=None, cursor=None, return_columns=None, limit=None, start_time=None, end_time=None, filter=None, only_latest_version=ScanVertexRequest.thrift_spec[9][4], enable_read_from_follower=ScanVertexRequest.thrift_spec[10][4],):
  self.space_id = space_id
  self.part_id = part_id
  self.cursor = cursor
  self.return_columns = return_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time
  self.filter = filter
  self.only_latest_version = only_latest_version
  self.enable_read_from_follower = enable_read_from_follower

ScanVertexRequest.__init__ = ScanVertexRequest__init__

def ScanVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('cursor', None)
  state.setdefault('return_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  state.setdefault('filter', None)
  state.setdefault('only_latest_version', False)
  state.setdefault('enable_read_from_follower', True)
  self.__dict__ = state

ScanVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanVertexRequest.__setstate__ = ScanVertexRequest__setstate__

all_structs.append(ScanVertexResponse)
ScanVertexResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'vertex_data', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 2, ), # 2
  (3, TType.BOOL, 'has_next', None, None, 2, ), # 3
  (4, TType.STRING, 'next_cursor', False, None, 1, ), # 4
)

ScanVertexResponse.thrift_struct_annotations = {
}
ScanVertexResponse.thrift_field_annotations = {
}

def ScanVertexResponse__init__(self, result=None, vertex_data=None, has_next=None, next_cursor=None,):
  self.result = result
  self.vertex_data = vertex_data
  self.has_next = has_next
  self.next_cursor = next_cursor

ScanVertexResponse.__init__ = ScanVertexResponse__init__

def ScanVertexResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertex_data', None)
  state.setdefault('has_next', None)
  state.setdefault('next_cursor', None)
  self.__dict__ = state

ScanVertexResponse.__getstate__ = lambda self: self.__dict__.copy()
ScanVertexResponse.__setstate__ = ScanVertexResponse__setstate__

all_structs.append(ScanEdgeRequest)
ScanEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'cursor', False, None, 1, ), # 3
  (4, TType.STRUCT, 'return_columns', [EdgeProp, EdgeProp.thrift_spec, False], None, 2, ), # 4
  (5, TType.I64, 'limit', None, None, 2, ), # 5
  (6, TType.I64, 'start_time', None, None, 1, ), # 6
  (7, TType.I64, 'end_time', None, None, 1, ), # 7
  (8, TType.STRING, 'filter', False, None, 1, ), # 8
  (9, TType.BOOL, 'only_latest_version', None, False, 2, ), # 9
  (10, TType.BOOL, 'enable_read_from_follower', None, True, 2, ), # 10
)

ScanEdgeRequest.thrift_struct_annotations = {
}
ScanEdgeRequest.thrift_field_annotations = {
}

def ScanEdgeRequest__init__(self, space_id=None, part_id=None, cursor=None, return_columns=None, limit=None, start_time=None, end_time=None, filter=None, only_latest_version=ScanEdgeRequest.thrift_spec[9][4], enable_read_from_follower=ScanEdgeRequest.thrift_spec[10][4],):
  self.space_id = space_id
  self.part_id = part_id
  self.cursor = cursor
  self.return_columns = return_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time
  self.filter = filter
  self.only_latest_version = only_latest_version
  self.enable_read_from_follower = enable_read_from_follower

ScanEdgeRequest.__init__ = ScanEdgeRequest__init__

def ScanEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('cursor', None)
  state.setdefault('return_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  state.setdefault('filter', None)
  state.setdefault('only_latest_version', False)
  state.setdefault('enable_read_from_follower', True)
  self.__dict__ = state

ScanEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanEdgeRequest.__setstate__ = ScanEdgeRequest__setstate__

all_structs.append(ScanEdgeResponse)
ScanEdgeResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'edge_data', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 2, ), # 2
  (3, TType.BOOL, 'has_next', None, None, 2, ), # 3
  (4, TType.STRING, 'next_cursor', False, None, 1, ), # 4
)

ScanEdgeResponse.thrift_struct_annotations = {
}
ScanEdgeResponse.thrift_field_annotations = {
}

def ScanEdgeResponse__init__(self, result=None, edge_data=None, has_next=None, next_cursor=None,):
  self.result = result
  self.edge_data = edge_data
  self.has_next = has_next
  self.next_cursor = next_cursor

ScanEdgeResponse.__init__ = ScanEdgeResponse__init__

def ScanEdgeResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('edge_data', None)
  state.setdefault('has_next', None)
  state.setdefault('next_cursor', None)
  self.__dict__ = state

ScanEdgeResponse.__getstate__ = lambda self: self.__dict__.copy()
ScanEdgeResponse.__setstate__ = ScanEdgeResponse__setstate__

all_structs.append(TaskPara)
TaskPara.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 1, ), # 2
  (3, TType.LIST, 'task_specfic_paras', (TType.STRING,False), None, 1, ), # 3
)

TaskPara.thrift_struct_annotations = {
}
TaskPara.thrift_field_annotations = {
}

def TaskPara__init__(self, space_id=None, parts=None, task_specfic_paras=None,):
  self.space_id = space_id
  self.parts = parts
  self.task_specfic_paras = task_specfic_paras

TaskPara.__init__ = TaskPara__init__

def TaskPara__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('task_specfic_paras', None)
  self.__dict__ = state

TaskPara.__getstate__ = lambda self: self.__dict__.copy()
TaskPara.__setstate__ = TaskPara__setstate__

all_structs.append(AddAdminTaskRequest)
AddAdminTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'cmd', nebula2.meta.ttypes.AdminCmd, None, 2, ), # 1
  (2, TType.I32, 'job_id', None, None, 2, ), # 2
  (3, TType.I32, 'task_id', None, None, 2, ), # 3
  (4, TType.STRUCT, 'para', [TaskPara, TaskPara.thrift_spec, False], None, 2, ), # 4
  (5, TType.I32, 'concurrency', None, None, 1, ), # 5
)

AddAdminTaskRequest.thrift_struct_annotations = {
}
AddAdminTaskRequest.thrift_field_annotations = {
}

def AddAdminTaskRequest__init__(self, cmd=None, job_id=None, task_id=None, para=None, concurrency=None,):
  self.cmd = cmd
  self.job_id = job_id
  self.task_id = task_id
  self.para = para
  self.concurrency = concurrency

AddAdminTaskRequest.__init__ = AddAdminTaskRequest__init__

def AddAdminTaskRequest__setstate__(self, state):
  state.setdefault('cmd', None)
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  state.setdefault('para', None)
  state.setdefault('concurrency', None)
  self.__dict__ = state

AddAdminTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
AddAdminTaskRequest.__setstate__ = AddAdminTaskRequest__setstate__

all_structs.append(StopAdminTaskRequest)
StopAdminTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_id', None, None, 2, ), # 1
  (2, TType.I32, 'task_id', None, None, 2, ), # 2
)

StopAdminTaskRequest.thrift_struct_annotations = {
}
StopAdminTaskRequest.thrift_field_annotations = {
}

def StopAdminTaskRequest__init__(self, job_id=None, task_id=None,):
  self.job_id = job_id
  self.task_id = task_id

StopAdminTaskRequest.__init__ = StopAdminTaskRequest__init__

def StopAdminTaskRequest__setstate__(self, state):
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  self.__dict__ = state

StopAdminTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
StopAdminTaskRequest.__setstate__ = StopAdminTaskRequest__setstate__

all_structs.append(AdminExecResp)
AdminExecResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'statis', [nebula2.meta.ttypes.StatisItem, nebula2.meta.ttypes.StatisItem.thrift_spec, False], None, 1, ), # 2
)

AdminExecResp.thrift_struct_annotations = {
}
AdminExecResp.thrift_field_annotations = {
}

def AdminExecResp__init__(self, result=None, statis=None,):
  self.result = result
  self.statis = statis

AdminExecResp.__init__ = AdminExecResp__init__

def AdminExecResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('statis', None)
  self.__dict__ = state

AdminExecResp.__getstate__ = lambda self: self.__dict__.copy()
AdminExecResp.__setstate__ = AdminExecResp__setstate__

all_structs.append(TransLeaderReq)
TransLeaderReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'new_leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

TransLeaderReq.thrift_struct_annotations = {
}
TransLeaderReq.thrift_field_annotations = {
}

def TransLeaderReq__init__(self, space_id=None, part_id=None, new_leader=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.new_leader = new_leader

TransLeaderReq.__init__ = TransLeaderReq__init__

def TransLeaderReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('new_leader', None)
  self.__dict__ = state

TransLeaderReq.__getstate__ = lambda self: self.__dict__.copy()
TransLeaderReq.__setstate__ = TransLeaderReq__setstate__

all_structs.append(AddPartReq)
AddPartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.BOOL, 'as_learner', None, None, 2, ), # 3
  (4, TType.LIST, 'peers', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 4
)

AddPartReq.thrift_struct_annotations = {
}
AddPartReq.thrift_field_annotations = {
}

def AddPartReq__init__(self, space_id=None, part_id=None, as_learner=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.as_learner = as_learner
  self.peers = peers

AddPartReq.__init__ = AddPartReq__init__

def AddPartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('as_learner', None)
  state.setdefault('peers', None)
  self.__dict__ = state

AddPartReq.__getstate__ = lambda self: self.__dict__.copy()
AddPartReq.__setstate__ = AddPartReq__setstate__

all_structs.append(AddLearnerReq)
AddLearnerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'learner', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

AddLearnerReq.thrift_struct_annotations = {
}
AddLearnerReq.thrift_field_annotations = {
}

def AddLearnerReq__init__(self, space_id=None, part_id=None, learner=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.learner = learner

AddLearnerReq.__init__ = AddLearnerReq__init__

def AddLearnerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('learner', None)
  self.__dict__ = state

AddLearnerReq.__getstate__ = lambda self: self.__dict__.copy()
AddLearnerReq.__setstate__ = AddLearnerReq__setstate__

all_structs.append(RemovePartReq)
RemovePartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
)

RemovePartReq.thrift_struct_annotations = {
}
RemovePartReq.thrift_field_annotations = {
}

def RemovePartReq__init__(self, space_id=None, part_id=None,):
  self.space_id = space_id
  self.part_id = part_id

RemovePartReq.__init__ = RemovePartReq__init__

def RemovePartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  self.__dict__ = state

RemovePartReq.__getstate__ = lambda self: self.__dict__.copy()
RemovePartReq.__setstate__ = RemovePartReq__setstate__

all_structs.append(MemberChangeReq)
MemberChangeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'peer', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'add', None, None, 2, ), # 4
)

MemberChangeReq.thrift_struct_annotations = {
}
MemberChangeReq.thrift_field_annotations = {
}

def MemberChangeReq__init__(self, space_id=None, part_id=None, peer=None, add=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peer = peer
  self.add = add

MemberChangeReq.__init__ = MemberChangeReq__init__

def MemberChangeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peer', None)
  state.setdefault('add', None)
  self.__dict__ = state

MemberChangeReq.__getstate__ = lambda self: self.__dict__.copy()
MemberChangeReq.__setstate__ = MemberChangeReq__setstate__

all_structs.append(CatchUpDataReq)
CatchUpDataReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'target', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

CatchUpDataReq.thrift_struct_annotations = {
}
CatchUpDataReq.thrift_field_annotations = {
}

def CatchUpDataReq__init__(self, space_id=None, part_id=None, target=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.target = target

CatchUpDataReq.__init__ = CatchUpDataReq__init__

def CatchUpDataReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('target', None)
  self.__dict__ = state

CatchUpDataReq.__getstate__ = lambda self: self.__dict__.copy()
CatchUpDataReq.__setstate__ = CatchUpDataReq__setstate__

all_structs.append(GetLeaderReq)
GetLeaderReq.thrift_spec = (
)

GetLeaderReq.thrift_struct_annotations = {
}
GetLeaderReq.thrift_field_annotations = {
}

all_structs.append(CreateCPRequest)
CreateCPRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

CreateCPRequest.thrift_struct_annotations = {
}
CreateCPRequest.thrift_field_annotations = {
}

def CreateCPRequest__init__(self, space_id=None, name=None,):
  self.space_id = space_id
  self.name = name

CreateCPRequest.__init__ = CreateCPRequest__init__

def CreateCPRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

CreateCPRequest.__getstate__ = lambda self: self.__dict__.copy()
CreateCPRequest.__setstate__ = CreateCPRequest__setstate__

all_structs.append(DropCPRequest)
DropCPRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

DropCPRequest.thrift_struct_annotations = {
}
DropCPRequest.thrift_field_annotations = {
}

def DropCPRequest__init__(self, space_id=None, name=None,):
  self.space_id = space_id
  self.name = name

DropCPRequest.__init__ = DropCPRequest__init__

def DropCPRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

DropCPRequest.__getstate__ = lambda self: self.__dict__.copy()
DropCPRequest.__setstate__ = DropCPRequest__setstate__

all_structs.append(BlockingSignRequest)
BlockingSignRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'sign', EngineSignType, None, 0, ), # 2
)

BlockingSignRequest.thrift_struct_annotations = {
}
BlockingSignRequest.thrift_field_annotations = {
}

def BlockingSignRequest__init__(self, space_id=None, sign=None,):
  self.space_id = space_id
  self.sign = sign

BlockingSignRequest.__init__ = BlockingSignRequest__init__

def BlockingSignRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('sign', None)
  self.__dict__ = state

BlockingSignRequest.__getstate__ = lambda self: self.__dict__.copy()
BlockingSignRequest.__setstate__ = BlockingSignRequest__setstate__

all_structs.append(GetLeaderPartsResp)
GetLeaderPartsResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'leader_parts', (TType.I32,None,TType.LIST,(TType.I32,None)), None, 2, ), # 2
)

GetLeaderPartsResp.thrift_struct_annotations = {
}
GetLeaderPartsResp.thrift_field_annotations = {
}

def GetLeaderPartsResp__init__(self, result=None, leader_parts=None,):
  self.result = result
  self.leader_parts = leader_parts

GetLeaderPartsResp.__init__ = GetLeaderPartsResp__init__

def GetLeaderPartsResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('leader_parts', None)
  self.__dict__ = state

GetLeaderPartsResp.__getstate__ = lambda self: self.__dict__.copy()
GetLeaderPartsResp.__setstate__ = GetLeaderPartsResp__setstate__

all_structs.append(CheckPeersReq)
CheckPeersReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

CheckPeersReq.thrift_struct_annotations = {
}
CheckPeersReq.thrift_field_annotations = {
}

def CheckPeersReq__init__(self, space_id=None, part_id=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peers = peers

CheckPeersReq.__init__ = CheckPeersReq__init__

def CheckPeersReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peers', None)
  self.__dict__ = state

CheckPeersReq.__getstate__ = lambda self: self.__dict__.copy()
CheckPeersReq.__setstate__ = CheckPeersReq__setstate__

all_structs.append(RebuildIndexRequest)
RebuildIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 2, ), # 2
  (3, TType.I32, 'index_id', None, None, 2, ), # 3
)

RebuildIndexRequest.thrift_struct_annotations = {
}
RebuildIndexRequest.thrift_field_annotations = {
}

def RebuildIndexRequest__init__(self, space_id=None, parts=None, index_id=None,):
  self.space_id = space_id
  self.parts = parts
  self.index_id = index_id

RebuildIndexRequest.__init__ = RebuildIndexRequest__init__

def RebuildIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('index_id', None)
  self.__dict__ = state

RebuildIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexRequest.__setstate__ = RebuildIndexRequest__setstate__

all_structs.append(CreateCPResp)
CreateCPResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'path', False, None, 2, ), # 2
)

CreateCPResp.thrift_struct_annotations = {
}
CreateCPResp.thrift_field_annotations = {
}

def CreateCPResp__init__(self, result=None, path=None,):
  self.result = result
  self.path = path

CreateCPResp.__init__ = CreateCPResp__init__

def CreateCPResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('path', None)
  self.__dict__ = state

CreateCPResp.__getstate__ = lambda self: self.__dict__.copy()
CreateCPResp.__setstate__ = CreateCPResp__setstate__

all_structs.append(PartitionInfoResp)
PartitionInfoResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'backup_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'partition_info', [nebula2.common.ttypes.PartitionBackupInfo, nebula2.common.ttypes.PartitionBackupInfo.thrift_spec, False], None, 2, ), # 3
)

PartitionInfoResp.thrift_struct_annotations = {
}
PartitionInfoResp.thrift_field_annotations = {
}

def PartitionInfoResp__init__(self, result=None, backup_name=None, partition_info=None,):
  self.result = result
  self.backup_name = backup_name
  self.partition_info = partition_info

PartitionInfoResp.__init__ = PartitionInfoResp__init__

def PartitionInfoResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('backup_name', None)
  state.setdefault('partition_info', None)
  self.__dict__ = state

PartitionInfoResp.__getstate__ = lambda self: self.__dict__.copy()
PartitionInfoResp.__setstate__ = PartitionInfoResp__setstate__

all_structs.append(PartitionInfoRequest)
PartitionInfoRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'backup_name', False, None, 2, ), # 2
)

PartitionInfoRequest.thrift_struct_annotations = {
}
PartitionInfoRequest.thrift_field_annotations = {
}

def PartitionInfoRequest__init__(self, space_id=None, backup_name=None,):
  self.space_id = space_id
  self.backup_name = backup_name

PartitionInfoRequest.__init__ = PartitionInfoRequest__init__

def PartitionInfoRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('backup_name', None)
  self.__dict__ = state

PartitionInfoRequest.__getstate__ = lambda self: self.__dict__.copy()
PartitionInfoRequest.__setstate__ = PartitionInfoRequest__setstate__

all_structs.append(KVGetRequest)
KVGetRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
  (3, TType.BOOL, 'return_partly', None, None, 2, ), # 3
)

KVGetRequest.thrift_struct_annotations = {
}
KVGetRequest.thrift_field_annotations = {
}

def KVGetRequest__init__(self, space_id=None, parts=None, return_partly=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_partly = return_partly

KVGetRequest.__init__ = KVGetRequest__init__

def KVGetRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_partly', None)
  self.__dict__ = state

KVGetRequest.__getstate__ = lambda self: self.__dict__.copy()
KVGetRequest.__setstate__ = KVGetRequest__setstate__

all_structs.append(KVGetResponse)
KVGetResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'key_values', (TType.STRING,False,TType.STRING,False), None, 2, ), # 2
)

KVGetResponse.thrift_struct_annotations = {
}
KVGetResponse.thrift_field_annotations = {
}

def KVGetResponse__init__(self, result=None, key_values=None,):
  self.result = result
  self.key_values = key_values

KVGetResponse.__init__ = KVGetResponse__init__

def KVGetResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('key_values', None)
  self.__dict__ = state

KVGetResponse.__getstate__ = lambda self: self.__dict__.copy()
KVGetResponse.__setstate__ = KVGetResponse__setstate__

all_structs.append(KVPutRequest)
KVPutRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.KeyValue, nebula2.common.ttypes.KeyValue.thrift_spec, False])), None, 2, ), # 2
)

KVPutRequest.thrift_struct_annotations = {
}
KVPutRequest.thrift_field_annotations = {
}

def KVPutRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVPutRequest.__init__ = KVPutRequest__init__

def KVPutRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVPutRequest.__getstate__ = lambda self: self.__dict__.copy()
KVPutRequest.__setstate__ = KVPutRequest__setstate__

all_structs.append(KVRemoveRequest)
KVRemoveRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
)

KVRemoveRequest.thrift_struct_annotations = {
}
KVRemoveRequest.thrift_field_annotations = {
}

def KVRemoveRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVRemoveRequest.__init__ = KVRemoveRequest__init__

def KVRemoveRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVRemoveRequest.__getstate__ = lambda self: self.__dict__.copy()
KVRemoveRequest.__setstate__ = KVRemoveRequest__setstate__

all_structs.append(InternalTxnRequest)
InternalTxnRequest.thrift_spec = (
  None, # 0
  (1, TType.I64, 'txn_id', None, None, 2, ), # 1
  (2, TType.I32, 'space_id', None, None, 2, ), # 2
  (3, TType.I32, 'part_id', None, None, 2, ), # 3
  (4, TType.I32, 'position', None, None, 2, ), # 4
  (5, TType.LIST, 'data', (TType.LIST,(TType.STRING,False)), None, 2, ), # 5
)

InternalTxnRequest.thrift_struct_annotations = {
}
InternalTxnRequest.thrift_field_annotations = {
}

def InternalTxnRequest__init__(self, txn_id=None, space_id=None, part_id=None, position=None, data=None,):
  self.txn_id = txn_id
  self.space_id = space_id
  self.part_id = part_id
  self.position = position
  self.data = data

InternalTxnRequest.__init__ = InternalTxnRequest__init__

def InternalTxnRequest__setstate__(self, state):
  state.setdefault('txn_id', None)
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('position', None)
  state.setdefault('data', None)
  self.__dict__ = state

InternalTxnRequest.__getstate__ = lambda self: self.__dict__.copy()
InternalTxnRequest.__setstate__ = InternalTxnRequest__setstate__

all_structs.append(GetValueRequest)
GetValueRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'key', False, None, 2, ), # 3
)

GetValueRequest.thrift_struct_annotations = {
}
GetValueRequest.thrift_field_annotations = {
}

def GetValueRequest__init__(self, space_id=None, part_id=None, key=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.key = key

GetValueRequest.__init__ = GetValueRequest__init__

def GetValueRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('key', None)
  self.__dict__ = state

GetValueRequest.__getstate__ = lambda self: self.__dict__.copy()
GetValueRequest.__setstate__ = GetValueRequest__setstate__

all_structs.append(GetValueResponse)
GetValueResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'value', False, None, 2, ), # 2
)

GetValueResponse.thrift_struct_annotations = {
}
GetValueResponse.thrift_field_annotations = {
}

def GetValueResponse__init__(self, result=None, value=None,):
  self.result = result
  self.value = value

GetValueResponse.__init__ = GetValueResponse__init__

def GetValueResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('value', None)
  self.__dict__ = state

GetValueResponse.__getstate__ = lambda self: self.__dict__.copy()
GetValueResponse.__setstate__ = GetValueResponse__setstate__

fix_spec(all_structs)
del all_structs
