#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import nebula2.common.ttypes
import nebula2.meta.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ErrorCode', 'StatType', 'OrderDirection', 'EdgeDirection', 'ScanType', 'EngineSignType', 'PartitionResult', 'ResponseCommon', 'StatProp', 'Expr', 'EdgeProp', 'VertexProp', 'OrderBy', 'TraverseSpec', 'GetNeighborsRequest', 'GetNeighborsResponse', 'ExecResponse', 'GetPropRequest', 'GetPropResponse', 'NewTag', 'NewVertex', 'EdgeKey', 'NewEdge', 'AddVerticesRequest', 'AddEdgesRequest', 'DeleteVerticesRequest', 'DeleteEdgesRequest', 'UpdateResponse', 'UpdatedProp', 'UpdateVertexRequest', 'UpdateEdgeRequest', 'GetUUIDReq', 'GetUUIDResp', 'LookupIndexResp', 'IndexColumnHint', 'IndexQueryContext', 'IndexSpec', 'LookupIndexRequest', 'LookupAndTraverseRequest', 'TaskPara', 'AddAdminTaskRequest', 'StopAdminTaskRequest', 'AdminExecResp', 'TransLeaderReq', 'AddPartReq', 'AddLearnerReq', 'RemovePartReq', 'MemberChangeReq', 'CatchUpDataReq', 'GetLeaderReq', 'CreateCPRequest', 'DropCPRequest', 'BlockingSignRequest', 'GetLeaderPartsResp', 'CheckPeersReq', 'RebuildIndexRequest', 'KVGetRequest', 'KVGetResponse', 'KVPutRequest', 'KVRemoveRequest']

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAILED_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_LEADER_CHANGED = -11
  E_KEY_HAS_EXISTS = -12
  E_SPACE_NOT_FOUND = -13
  E_PART_NOT_FOUND = -14
  E_KEY_NOT_FOUND = -15
  E_CONSENSUS_ERROR = -16
  E_DATA_TYPE_MISMATCH = -17
  E_INVALID_FIELD_VALUE = -18
  E_REBUILD_INDEX_FAILED = -19
  E_INVALID_OPERATION = -20
  E_NOT_NULLABLE = -21
  E_FIELD_UNSET = -22
  E_OUT_OF_RANGE = -23
  E_ATOMIC_OP_FAILED = -24
  E_EDGE_PROP_NOT_FOUND = -31
  E_TAG_PROP_NOT_FOUND = -32
  E_IMPROPER_DATA_TYPE = -33
  E_EDGE_NOT_FOUND = -34
  E_TAG_NOT_FOUND = -35
  E_INVALID_SPACEVIDLEN = -36
  E_INDEX_NOT_FOUND = -37
  E_INVALID_FILTER = -41
  E_INVALID_UPDATER = -42
  E_INVALID_STORE = -43
  E_INVALID_PEER = -44
  E_RETRY_EXHAUSTED = -45
  E_TRANSFER_LEADER_FAILED = -46
  E_INVALID_STAT_TYPE = -47
  E_INVALID_VID = -48
  E_LOAD_META_FAILED = -51
  E_FAILED_TO_CHECKPOINT = -60
  E_CHECKPOINT_BLOCKED = -61
  E_PARTIAL_RESULT = -71
  E_FILTER_OUT = -81
  E_INVALID_DATA = -82
  E_INVALID_TASK_PARA = -90
  E_USER_CANCEL = -99
  E_UNKNOWN = -100

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAILED_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -11: "E_LEADER_CHANGED",
    -12: "E_KEY_HAS_EXISTS",
    -13: "E_SPACE_NOT_FOUND",
    -14: "E_PART_NOT_FOUND",
    -15: "E_KEY_NOT_FOUND",
    -16: "E_CONSENSUS_ERROR",
    -17: "E_DATA_TYPE_MISMATCH",
    -18: "E_INVALID_FIELD_VALUE",
    -19: "E_REBUILD_INDEX_FAILED",
    -20: "E_INVALID_OPERATION",
    -21: "E_NOT_NULLABLE",
    -22: "E_FIELD_UNSET",
    -23: "E_OUT_OF_RANGE",
    -24: "E_ATOMIC_OP_FAILED",
    -31: "E_EDGE_PROP_NOT_FOUND",
    -32: "E_TAG_PROP_NOT_FOUND",
    -33: "E_IMPROPER_DATA_TYPE",
    -34: "E_EDGE_NOT_FOUND",
    -35: "E_TAG_NOT_FOUND",
    -36: "E_INVALID_SPACEVIDLEN",
    -37: "E_INDEX_NOT_FOUND",
    -41: "E_INVALID_FILTER",
    -42: "E_INVALID_UPDATER",
    -43: "E_INVALID_STORE",
    -44: "E_INVALID_PEER",
    -45: "E_RETRY_EXHAUSTED",
    -46: "E_TRANSFER_LEADER_FAILED",
    -47: "E_INVALID_STAT_TYPE",
    -48: "E_INVALID_VID",
    -51: "E_LOAD_META_FAILED",
    -60: "E_FAILED_TO_CHECKPOINT",
    -61: "E_CHECKPOINT_BLOCKED",
    -71: "E_PARTIAL_RESULT",
    -81: "E_FILTER_OUT",
    -82: "E_INVALID_DATA",
    -90: "E_INVALID_TASK_PARA",
    -99: "E_USER_CANCEL",
    -100: "E_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAILED_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_LEADER_CHANGED": -11,
    "E_KEY_HAS_EXISTS": -12,
    "E_SPACE_NOT_FOUND": -13,
    "E_PART_NOT_FOUND": -14,
    "E_KEY_NOT_FOUND": -15,
    "E_CONSENSUS_ERROR": -16,
    "E_DATA_TYPE_MISMATCH": -17,
    "E_INVALID_FIELD_VALUE": -18,
    "E_REBUILD_INDEX_FAILED": -19,
    "E_INVALID_OPERATION": -20,
    "E_NOT_NULLABLE": -21,
    "E_FIELD_UNSET": -22,
    "E_OUT_OF_RANGE": -23,
    "E_ATOMIC_OP_FAILED": -24,
    "E_EDGE_PROP_NOT_FOUND": -31,
    "E_TAG_PROP_NOT_FOUND": -32,
    "E_IMPROPER_DATA_TYPE": -33,
    "E_EDGE_NOT_FOUND": -34,
    "E_TAG_NOT_FOUND": -35,
    "E_INVALID_SPACEVIDLEN": -36,
    "E_INDEX_NOT_FOUND": -37,
    "E_INVALID_FILTER": -41,
    "E_INVALID_UPDATER": -42,
    "E_INVALID_STORE": -43,
    "E_INVALID_PEER": -44,
    "E_RETRY_EXHAUSTED": -45,
    "E_TRANSFER_LEADER_FAILED": -46,
    "E_INVALID_STAT_TYPE": -47,
    "E_INVALID_VID": -48,
    "E_LOAD_META_FAILED": -51,
    "E_FAILED_TO_CHECKPOINT": -60,
    "E_CHECKPOINT_BLOCKED": -61,
    "E_PARTIAL_RESULT": -71,
    "E_FILTER_OUT": -81,
    "E_INVALID_DATA": -82,
    "E_INVALID_TASK_PARA": -90,
    "E_USER_CANCEL": -99,
    "E_UNKNOWN": -100,
  }

class StatType:
  SUM = 1
  COUNT = 2
  AVG = 3
  MAX = 4
  MIN = 5

  _VALUES_TO_NAMES = {
    1: "SUM",
    2: "COUNT",
    3: "AVG",
    4: "MAX",
    5: "MIN",
  }

  _NAMES_TO_VALUES = {
    "SUM": 1,
    "COUNT": 2,
    "AVG": 3,
    "MAX": 4,
    "MIN": 5,
  }

class OrderDirection:
  ASCENDING = 1
  DESCENDING = 2

  _VALUES_TO_NAMES = {
    1: "ASCENDING",
    2: "DESCENDING",
  }

  _NAMES_TO_VALUES = {
    "ASCENDING": 1,
    "DESCENDING": 2,
  }

class EdgeDirection:
  BOTH = 1
  IN_EDGE = 2
  OUT_EDGE = 3

  _VALUES_TO_NAMES = {
    1: "BOTH",
    2: "IN_EDGE",
    3: "OUT_EDGE",
  }

  _NAMES_TO_VALUES = {
    "BOTH": 1,
    "IN_EDGE": 2,
    "OUT_EDGE": 3,
  }

class ScanType:
  PREFIX = 1
  RANGE = 2

  _VALUES_TO_NAMES = {
    1: "PREFIX",
    2: "RANGE",
  }

  _NAMES_TO_VALUES = {
    "PREFIX": 1,
    "RANGE": 2,
  }

class EngineSignType:
  BLOCK_ON = 1
  BLOCK_OFF = 2

  _VALUES_TO_NAMES = {
    1: "BLOCK_ON",
    2: "BLOCK_OFF",
  }

  _NAMES_TO_VALUES = {
    "BLOCK_ON": 1,
    "BLOCK_OFF": 2,
  }

class PartitionResult:
  """
  Attributes:
   - code
   - part_id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.code == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'code' was not found in serialized data! Struct: PartitionResult")

    if self.part_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'part_id' was not found in serialized data! Struct: PartitionResult")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionResult')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ResponseCommon:
  """
  Attributes:
   - failed_parts
   - latency_in_us
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.failed_parts = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = PartitionResult()
              _elem5.read(iprot)
              self.failed_parts.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = PartitionResult()
              _elem6.read(iprot)
              self.failed_parts.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.latency_in_us = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.failed_parts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'failed_parts' was not found in serialized data! Struct: ResponseCommon")

    if self.latency_in_us == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'latency_in_us' was not found in serialized data! Struct: ResponseCommon")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ResponseCommon')
    if self.failed_parts != None:
      oprot.writeFieldBegin('failed_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.failed_parts))
      for iter7 in self.failed_parts:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I32, 2)
      oprot.writeI32(self.latency_in_us)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.failed_parts is not None:
      value = pprint.pformat(self.failed_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    failed_parts=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class StatProp:
  """
  Attributes:
   - alias
   - prop
   - stat
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.stat = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StatProp')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 2)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.stat != None:
      oprot.writeFieldBegin('stat', TType.I32, 3)
      oprot.writeI32(self.stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.stat is not None:
      value = pprint.pformat(self.stat, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Expr:
  """
  Attributes:
   - alias
   - expr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Expr')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.expr != None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.expr is not None:
      value = pprint.pformat(self.expr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeProp:
  """
  Attributes:
   - type
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = iprot.readString()
              self.props.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = iprot.readString()
              self.props.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeProp')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter15 in self.props:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class VertexProp:
  """
  Attributes:
   - tag
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = iprot.readString()
              self.props.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = iprot.readString()
              self.props.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexProp')
    if self.tag != None:
      oprot.writeFieldBegin('tag', TType.I32, 1)
      oprot.writeI32(self.tag)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter23 in self.props:
        oprot.writeString(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag is not None:
      value = pprint.pformat(self.tag, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class OrderBy:
  """
  Attributes:
   - prop
   - direction
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OrderBy')
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 1)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, 2)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.direction is not None:
      value = pprint.pformat(self.direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    direction=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TraverseSpec:
  """
  Attributes:
   - edge_types
   - edge_direction
   - dedup
   - stat_props
   - vertex_props
   - edge_props
   - expressions
   - order_by
   - random
   - limit
   - filter
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.edge_types = []
          (_etype27, _size24) = iprot.readListBegin()
          if _size24 >= 0:
            for _i28 in six.moves.range(_size24):
              _elem29 = iprot.readI32()
              self.edge_types.append(_elem29)
          else: 
            while iprot.peekList():
              _elem30 = iprot.readI32()
              self.edge_types.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stat_props = []
          (_etype34, _size31) = iprot.readListBegin()
          if _size31 >= 0:
            for _i35 in six.moves.range(_size31):
              _elem36 = StatProp()
              _elem36.read(iprot)
              self.stat_props.append(_elem36)
          else: 
            while iprot.peekList():
              _elem37 = StatProp()
              _elem37.read(iprot)
              self.stat_props.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype41, _size38) = iprot.readListBegin()
          if _size38 >= 0:
            for _i42 in six.moves.range(_size38):
              _elem43 = VertexProp()
              _elem43.read(iprot)
              self.vertex_props.append(_elem43)
          else: 
            while iprot.peekList():
              _elem44 = VertexProp()
              _elem44.read(iprot)
              self.vertex_props.append(_elem44)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype48, _size45) = iprot.readListBegin()
          if _size45 >= 0:
            for _i49 in six.moves.range(_size45):
              _elem50 = EdgeProp()
              _elem50.read(iprot)
              self.edge_props.append(_elem50)
          else: 
            while iprot.peekList():
              _elem51 = EdgeProp()
              _elem51.read(iprot)
              self.edge_props.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype55, _size52) = iprot.readListBegin()
          if _size52 >= 0:
            for _i56 in six.moves.range(_size52):
              _elem57 = Expr()
              _elem57.read(iprot)
              self.expressions.append(_elem57)
          else: 
            while iprot.peekList():
              _elem58 = Expr()
              _elem58.read(iprot)
              self.expressions.append(_elem58)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype62, _size59) = iprot.readListBegin()
          if _size59 >= 0:
            for _i63 in six.moves.range(_size59):
              _elem64 = OrderBy()
              _elem64.read(iprot)
              self.order_by.append(_elem64)
          else: 
            while iprot.peekList():
              _elem65 = OrderBy()
              _elem65.read(iprot)
              self.order_by.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.random = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TraverseSpec')
    if self.edge_types != None:
      oprot.writeFieldBegin('edge_types', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.edge_types))
      for iter66 in self.edge_types:
        oprot.writeI32(iter66)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_direction != None:
      oprot.writeFieldBegin('edge_direction', TType.I32, 2)
      oprot.writeI32(self.edge_direction)
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 3)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.stat_props != None:
      oprot.writeFieldBegin('stat_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.stat_props))
      for iter67 in self.stat_props:
        iter67.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter68 in self.vertex_props:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter69 in self.edge_props:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter70 in self.expressions:
        iter70.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter71 in self.order_by:
        iter71.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.random != None:
      oprot.writeFieldBegin('random', TType.BOOL, 9)
      oprot.writeBool(self.random)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 10)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 11)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.edge_types is not None:
      value = pprint.pformat(self.edge_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_types=%s' % (value))
    if self.edge_direction is not None:
      value = pprint.pformat(self.edge_direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_direction=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.stat_props is not None:
      value = pprint.pformat(self.stat_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat_props=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.random is not None:
      value = pprint.pformat(self.random, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    random=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetNeighborsRequest:
  """
  Attributes:
   - space_id
   - column_names
   - parts
   - traverse_spec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype75, _size72) = iprot.readListBegin()
          if _size72 >= 0:
            for _i76 in six.moves.range(_size72):
              _elem77 = iprot.readString()
              self.column_names.append(_elem77)
          else: 
            while iprot.peekList():
              _elem78 = iprot.readString()
              self.column_names.append(_elem78)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype80, _vtype81, _size79 ) = iprot.readMapBegin() 
          if _size79 >= 0:
            for _i83 in six.moves.range(_size79):
              _key84 = iprot.readI32()
              _val85 = []
              (_etype89, _size86) = iprot.readListBegin()
              if _size86 >= 0:
                for _i90 in six.moves.range(_size86):
                  _elem91 = nebula2.common.ttypes.Row()
                  _elem91.read(iprot)
                  _val85.append(_elem91)
              else: 
                while iprot.peekList():
                  _elem92 = nebula2.common.ttypes.Row()
                  _elem92.read(iprot)
                  _val85.append(_elem92)
              iprot.readListEnd()
              self.parts[_key84] = _val85
          else: 
            while iprot.peekMap():
              _key93 = iprot.readI32()
              _val94 = []
              (_etype98, _size95) = iprot.readListBegin()
              if _size95 >= 0:
                for _i99 in six.moves.range(_size95):
                  _elem100 = nebula2.common.ttypes.Row()
                  _elem100.read(iprot)
                  _val94.append(_elem100)
              else: 
                while iprot.peekList():
                  _elem101 = nebula2.common.ttypes.Row()
                  _elem101.read(iprot)
                  _val94.append(_elem101)
              iprot.readListEnd()
              self.parts[_key93] = _val94
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter102 in self.column_names:
        oprot.writeString(iter102)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter103,viter104 in self.parts.items():
        oprot.writeI32(kiter103)
        oprot.writeListBegin(TType.STRUCT, len(viter104))
        for iter105 in viter104:
          iter105.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetNeighborsResponse:
  """
  Attributes:
   - result
   - vertices
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vertices = nebula2.common.ttypes.DataSet()
          self.vertices.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetNeighborsResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertices != None:
      oprot.writeFieldBegin('vertices', TType.STRUCT, 2)
      self.vertices.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertices is not None:
      value = pprint.pformat(self.vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertices=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ExecResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: ExecResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetPropRequest:
  """
  Attributes:
   - space_id
   - column_names
   - parts
   - vertex_props
   - edge_props
   - expressions
   - dedup
   - order_by
   - limit
   - filter
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype109, _size106) = iprot.readListBegin()
          if _size106 >= 0:
            for _i110 in six.moves.range(_size106):
              _elem111 = iprot.readString()
              self.column_names.append(_elem111)
          else: 
            while iprot.peekList():
              _elem112 = iprot.readString()
              self.column_names.append(_elem112)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype114, _vtype115, _size113 ) = iprot.readMapBegin() 
          if _size113 >= 0:
            for _i117 in six.moves.range(_size113):
              _key118 = iprot.readI32()
              _val119 = []
              (_etype123, _size120) = iprot.readListBegin()
              if _size120 >= 0:
                for _i124 in six.moves.range(_size120):
                  _elem125 = nebula2.common.ttypes.Row()
                  _elem125.read(iprot)
                  _val119.append(_elem125)
              else: 
                while iprot.peekList():
                  _elem126 = nebula2.common.ttypes.Row()
                  _elem126.read(iprot)
                  _val119.append(_elem126)
              iprot.readListEnd()
              self.parts[_key118] = _val119
          else: 
            while iprot.peekMap():
              _key127 = iprot.readI32()
              _val128 = []
              (_etype132, _size129) = iprot.readListBegin()
              if _size129 >= 0:
                for _i133 in six.moves.range(_size129):
                  _elem134 = nebula2.common.ttypes.Row()
                  _elem134.read(iprot)
                  _val128.append(_elem134)
              else: 
                while iprot.peekList():
                  _elem135 = nebula2.common.ttypes.Row()
                  _elem135.read(iprot)
                  _val128.append(_elem135)
              iprot.readListEnd()
              self.parts[_key127] = _val128
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype139, _size136) = iprot.readListBegin()
          if _size136 >= 0:
            for _i140 in six.moves.range(_size136):
              _elem141 = VertexProp()
              _elem141.read(iprot)
              self.vertex_props.append(_elem141)
          else: 
            while iprot.peekList():
              _elem142 = VertexProp()
              _elem142.read(iprot)
              self.vertex_props.append(_elem142)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype146, _size143) = iprot.readListBegin()
          if _size143 >= 0:
            for _i147 in six.moves.range(_size143):
              _elem148 = EdgeProp()
              _elem148.read(iprot)
              self.edge_props.append(_elem148)
          else: 
            while iprot.peekList():
              _elem149 = EdgeProp()
              _elem149.read(iprot)
              self.edge_props.append(_elem149)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype153, _size150) = iprot.readListBegin()
          if _size150 >= 0:
            for _i154 in six.moves.range(_size150):
              _elem155 = Expr()
              _elem155.read(iprot)
              self.expressions.append(_elem155)
          else: 
            while iprot.peekList():
              _elem156 = Expr()
              _elem156.read(iprot)
              self.expressions.append(_elem156)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype160, _size157) = iprot.readListBegin()
          if _size157 >= 0:
            for _i161 in six.moves.range(_size157):
              _elem162 = OrderBy()
              _elem162.read(iprot)
              self.order_by.append(_elem162)
          else: 
            while iprot.peekList():
              _elem163 = OrderBy()
              _elem163.read(iprot)
              self.order_by.append(_elem163)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter164 in self.column_names:
        oprot.writeString(iter164)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter165,viter166 in self.parts.items():
        oprot.writeI32(kiter165)
        oprot.writeListBegin(TType.STRUCT, len(viter166))
        for iter167 in viter166:
          iter167.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter168 in self.vertex_props:
        iter168.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter169 in self.edge_props:
        iter169.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter170 in self.expressions:
        iter170.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 7)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter171 in self.order_by:
        iter171.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 9)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 10)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetPropResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewTag:
  """
  Attributes:
   - tag_id
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype175, _size172) = iprot.readListBegin()
          if _size172 >= 0:
            for _i176 in six.moves.range(_size172):
              _elem177 = nebula2.common.ttypes.Value()
              _elem177.read(iprot)
              self.props.append(_elem177)
          else: 
            while iprot.peekList():
              _elem178 = nebula2.common.ttypes.Value()
              _elem178.read(iprot)
              self.props.append(_elem178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewTag')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter179 in self.props:
        iter179.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewVertex:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype183, _size180) = iprot.readListBegin()
          if _size180 >= 0:
            for _i184 in six.moves.range(_size180):
              _elem185 = NewTag()
              _elem185.read(iprot)
              self.tags.append(_elem185)
          else: 
            while iprot.peekList():
              _elem186 = NewTag()
              _elem186.read(iprot)
              self.tags.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewVertex')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter187 in self.tags:
        iter187.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeKey:
  """
  Attributes:
   - src
   - edge_type
   - ranking
   - dst
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.src = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dst = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeKey')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRING, 1)
      oprot.writeString(self.src)
      oprot.writeFieldEnd()
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 3)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRING, 4)
      oprot.writeString(self.dst)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NewEdge:
  """
  Attributes:
   - key
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = EdgeKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype191, _size188) = iprot.readListBegin()
          if _size188 >= 0:
            for _i192 in six.moves.range(_size188):
              _elem193 = nebula2.common.ttypes.Value()
              _elem193.read(iprot)
              self.props.append(_elem193)
          else: 
            while iprot.peekList():
              _elem194 = nebula2.common.ttypes.Value()
              _elem194.read(iprot)
              self.props.append(_elem194)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewEdge')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter195 in self.props:
        iter195.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - overwritable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype197, _vtype198, _size196 ) = iprot.readMapBegin() 
          if _size196 >= 0:
            for _i200 in six.moves.range(_size196):
              _key201 = iprot.readI32()
              _val202 = []
              (_etype206, _size203) = iprot.readListBegin()
              if _size203 >= 0:
                for _i207 in six.moves.range(_size203):
                  _elem208 = NewVertex()
                  _elem208.read(iprot)
                  _val202.append(_elem208)
              else: 
                while iprot.peekList():
                  _elem209 = NewVertex()
                  _elem209.read(iprot)
                  _val202.append(_elem209)
              iprot.readListEnd()
              self.parts[_key201] = _val202
          else: 
            while iprot.peekMap():
              _key210 = iprot.readI32()
              _val211 = []
              (_etype215, _size212) = iprot.readListBegin()
              if _size212 >= 0:
                for _i216 in six.moves.range(_size212):
                  _elem217 = NewVertex()
                  _elem217.read(iprot)
                  _val211.append(_elem217)
              else: 
                while iprot.peekList():
                  _elem218 = NewVertex()
                  _elem218.read(iprot)
                  _val211.append(_elem218)
              iprot.readListEnd()
              self.parts[_key210] = _val211
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.prop_names = {}
          (_ktype220, _vtype221, _size219 ) = iprot.readMapBegin() 
          if _size219 >= 0:
            for _i223 in six.moves.range(_size219):
              _key224 = iprot.readI32()
              _val225 = []
              (_etype229, _size226) = iprot.readListBegin()
              if _size226 >= 0:
                for _i230 in six.moves.range(_size226):
                  _elem231 = iprot.readString()
                  _val225.append(_elem231)
              else: 
                while iprot.peekList():
                  _elem232 = iprot.readString()
                  _val225.append(_elem232)
              iprot.readListEnd()
              self.prop_names[_key224] = _val225
          else: 
            while iprot.peekMap():
              _key233 = iprot.readI32()
              _val234 = []
              (_etype238, _size235) = iprot.readListBegin()
              if _size235 >= 0:
                for _i239 in six.moves.range(_size235):
                  _elem240 = iprot.readString()
                  _val234.append(_elem240)
              else: 
                while iprot.peekList():
                  _elem241 = iprot.readString()
                  _val234.append(_elem241)
              iprot.readListEnd()
              self.prop_names[_key233] = _val234
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.overwritable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter242,viter243 in self.parts.items():
        oprot.writeI32(kiter242)
        oprot.writeListBegin(TType.STRUCT, len(viter243))
        for iter244 in viter243:
          iter244.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.prop_names))
      for kiter245,viter246 in self.prop_names.items():
        oprot.writeI32(kiter245)
        oprot.writeListBegin(TType.STRING, len(viter246))
        for iter247 in viter246:
          oprot.writeString(iter247)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.overwritable != None:
      oprot.writeFieldBegin('overwritable', TType.BOOL, 4)
      oprot.writeBool(self.overwritable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.overwritable is not None:
      value = pprint.pformat(self.overwritable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    overwritable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - overwritable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype249, _vtype250, _size248 ) = iprot.readMapBegin() 
          if _size248 >= 0:
            for _i252 in six.moves.range(_size248):
              _key253 = iprot.readI32()
              _val254 = []
              (_etype258, _size255) = iprot.readListBegin()
              if _size255 >= 0:
                for _i259 in six.moves.range(_size255):
                  _elem260 = NewEdge()
                  _elem260.read(iprot)
                  _val254.append(_elem260)
              else: 
                while iprot.peekList():
                  _elem261 = NewEdge()
                  _elem261.read(iprot)
                  _val254.append(_elem261)
              iprot.readListEnd()
              self.parts[_key253] = _val254
          else: 
            while iprot.peekMap():
              _key262 = iprot.readI32()
              _val263 = []
              (_etype267, _size264) = iprot.readListBegin()
              if _size264 >= 0:
                for _i268 in six.moves.range(_size264):
                  _elem269 = NewEdge()
                  _elem269.read(iprot)
                  _val263.append(_elem269)
              else: 
                while iprot.peekList():
                  _elem270 = NewEdge()
                  _elem270.read(iprot)
                  _val263.append(_elem270)
              iprot.readListEnd()
              self.parts[_key262] = _val263
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prop_names = []
          (_etype274, _size271) = iprot.readListBegin()
          if _size271 >= 0:
            for _i275 in six.moves.range(_size271):
              _elem276 = iprot.readString()
              self.prop_names.append(_elem276)
          else: 
            while iprot.peekList():
              _elem277 = iprot.readString()
              self.prop_names.append(_elem277)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.overwritable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter278,viter279 in self.parts.items():
        oprot.writeI32(kiter278)
        oprot.writeListBegin(TType.STRUCT, len(viter279))
        for iter280 in viter279:
          iter280.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.prop_names))
      for iter281 in self.prop_names:
        oprot.writeString(iter281)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.overwritable != None:
      oprot.writeFieldBegin('overwritable', TType.BOOL, 4)
      oprot.writeBool(self.overwritable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.overwritable is not None:
      value = pprint.pformat(self.overwritable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    overwritable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DeleteVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype283, _vtype284, _size282 ) = iprot.readMapBegin() 
          if _size282 >= 0:
            for _i286 in six.moves.range(_size282):
              _key287 = iprot.readI32()
              _val288 = []
              (_etype292, _size289) = iprot.readListBegin()
              if _size289 >= 0:
                for _i293 in six.moves.range(_size289):
                  _elem294 = iprot.readString()
                  _val288.append(_elem294)
              else: 
                while iprot.peekList():
                  _elem295 = iprot.readString()
                  _val288.append(_elem295)
              iprot.readListEnd()
              self.parts[_key287] = _val288
          else: 
            while iprot.peekMap():
              _key296 = iprot.readI32()
              _val297 = []
              (_etype301, _size298) = iprot.readListBegin()
              if _size298 >= 0:
                for _i302 in six.moves.range(_size298):
                  _elem303 = iprot.readString()
                  _val297.append(_elem303)
              else: 
                while iprot.peekList():
                  _elem304 = iprot.readString()
                  _val297.append(_elem304)
              iprot.readListEnd()
              self.parts[_key296] = _val297
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter305,viter306 in self.parts.items():
        oprot.writeI32(kiter305)
        oprot.writeListBegin(TType.STRING, len(viter306))
        for iter307 in viter306:
          oprot.writeString(iter307)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DeleteEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype309, _vtype310, _size308 ) = iprot.readMapBegin() 
          if _size308 >= 0:
            for _i312 in six.moves.range(_size308):
              _key313 = iprot.readI32()
              _val314 = []
              (_etype318, _size315) = iprot.readListBegin()
              if _size315 >= 0:
                for _i319 in six.moves.range(_size315):
                  _elem320 = EdgeKey()
                  _elem320.read(iprot)
                  _val314.append(_elem320)
              else: 
                while iprot.peekList():
                  _elem321 = EdgeKey()
                  _elem321.read(iprot)
                  _val314.append(_elem321)
              iprot.readListEnd()
              self.parts[_key313] = _val314
          else: 
            while iprot.peekMap():
              _key322 = iprot.readI32()
              _val323 = []
              (_etype327, _size324) = iprot.readListBegin()
              if _size324 >= 0:
                for _i328 in six.moves.range(_size324):
                  _elem329 = EdgeKey()
                  _elem329.read(iprot)
                  _val323.append(_elem329)
              else: 
                while iprot.peekList():
                  _elem330 = EdgeKey()
                  _elem330.read(iprot)
                  _val323.append(_elem330)
              iprot.readListEnd()
              self.parts[_key322] = _val323
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter331,viter332 in self.parts.items():
        oprot.writeI32(kiter331)
        oprot.writeListBegin(TType.STRUCT, len(viter332))
        for iter333 in viter332:
          iter333.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula2.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: UpdateResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdatedProp:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.name == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'name' was not found in serialized data! Struct: UpdatedProp")

    if self.value == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'value' was not found in serialized data! Struct: UpdatedProp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdatedProp')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateVertexRequest:
  """
  Attributes:
   - space_id
   - part_id
   - vertex_id
   - tag_id
   - updated_props
   - insertable
   - return_props
   - condition
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.vertex_id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype337, _size334) = iprot.readListBegin()
          if _size334 >= 0:
            for _i338 in six.moves.range(_size334):
              _elem339 = UpdatedProp()
              _elem339.read(iprot)
              self.updated_props.append(_elem339)
          else: 
            while iprot.peekList():
              _elem340 = UpdatedProp()
              _elem340.read(iprot)
              self.updated_props.append(_elem340)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype344, _size341) = iprot.readListBegin()
          if _size341 >= 0:
            for _i345 in six.moves.range(_size341):
              _elem346 = iprot.readString()
              self.return_props.append(_elem346)
          else: 
            while iprot.peekList():
              _elem347 = iprot.readString()
              self.return_props.append(_elem347)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.tag_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'tag_id' was not found in serialized data! Struct: UpdateVertexRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.STRING, 3)
      oprot.writeString(self.vertex_id)
      oprot.writeFieldEnd()
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 4)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter348 in self.updated_props:
        iter348.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[6][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 6)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter349 in self.return_props:
        oprot.writeString(iter349)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 8)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateEdgeRequest:
  """
  Attributes:
   - space_id
   - part_id
   - edge_key
   - updated_props
   - insertable
   - return_props
   - condition
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.edge_key = EdgeKey()
          self.edge_key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype353, _size350) = iprot.readListBegin()
          if _size350 >= 0:
            for _i354 in six.moves.range(_size350):
              _elem355 = UpdatedProp()
              _elem355.read(iprot)
              self.updated_props.append(_elem355)
          else: 
            while iprot.peekList():
              _elem356 = UpdatedProp()
              _elem356.read(iprot)
              self.updated_props.append(_elem356)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype360, _size357) = iprot.readListBegin()
          if _size357 >= 0:
            for _i361 in six.moves.range(_size357):
              _elem362 = iprot.readString()
              self.return_props.append(_elem362)
          else: 
            while iprot.peekList():
              _elem363 = iprot.readString()
              self.return_props.append(_elem363)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.edge_key != None:
      oprot.writeFieldBegin('edge_key', TType.STRUCT, 3)
      self.edge_key.write(oprot)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter364 in self.updated_props:
        iter364.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[5][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 5)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter365 in self.return_props:
        oprot.writeString(iter365)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 7)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.edge_key is not None:
      value = pprint.pformat(self.edge_key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_key=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUUIDReq:
  """
  Attributes:
   - space_id
   - part_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUUIDResp:
  """
  Attributes:
   - result
   - id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetUUIDResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 2)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookupIndexResp:
  """
  Attributes:
   - result
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = nebula2.common.ttypes.DataSet()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: LookupIndexResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexColumnHint:
  """
  Attributes:
   - column_name
   - scan_type
   - begin_value
   - end_value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.scan_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.begin_value = nebula2.common.ttypes.Value()
          self.begin_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.end_value = nebula2.common.ttypes.Value()
          self.end_value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexColumnHint')
    if self.column_name != None:
      oprot.writeFieldBegin('column_name', TType.STRING, 1)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.scan_type != None:
      oprot.writeFieldBegin('scan_type', TType.I32, 2)
      oprot.writeI32(self.scan_type)
      oprot.writeFieldEnd()
    if self.begin_value != None:
      oprot.writeFieldBegin('begin_value', TType.STRUCT, 3)
      self.begin_value.write(oprot)
      oprot.writeFieldEnd()
    if self.end_value != None:
      oprot.writeFieldBegin('end_value', TType.STRUCT, 4)
      self.end_value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_name is not None:
      value = pprint.pformat(self.column_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_name=%s' % (value))
    if self.scan_type is not None:
      value = pprint.pformat(self.scan_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    scan_type=%s' % (value))
    if self.begin_value is not None:
      value = pprint.pformat(self.begin_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    begin_value=%s' % (value))
    if self.end_value is not None:
      value = pprint.pformat(self.end_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexQueryContext:
  """
  Attributes:
   - index_id
   - filter
   - column_hints
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.column_hints = []
          (_etype369, _size366) = iprot.readListBegin()
          if _size366 >= 0:
            for _i370 in six.moves.range(_size366):
              _elem371 = IndexColumnHint()
              _elem371.read(iprot)
              self.column_hints.append(_elem371)
          else: 
            while iprot.peekList():
              _elem372 = IndexColumnHint()
              _elem372.read(iprot)
              self.column_hints.append(_elem372)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexQueryContext')
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 1)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.column_hints != None:
      oprot.writeFieldBegin('column_hints', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.column_hints))
      for iter373 in self.column_hints:
        iter373.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.column_hints is not None:
      value = pprint.pformat(self.column_hints, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_hints=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexSpec:
  """
  Attributes:
   - contexts
   - is_edge
   - tag_or_edge_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.contexts = []
          (_etype377, _size374) = iprot.readListBegin()
          if _size374 >= 0:
            for _i378 in six.moves.range(_size374):
              _elem379 = IndexQueryContext()
              _elem379.read(iprot)
              self.contexts.append(_elem379)
          else: 
            while iprot.peekList():
              _elem380 = IndexQueryContext()
              _elem380.read(iprot)
              self.contexts.append(_elem380)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_edge = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.tag_or_edge_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.contexts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'contexts' was not found in serialized data! Struct: IndexSpec")

    if self.is_edge == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'is_edge' was not found in serialized data! Struct: IndexSpec")

    if self.tag_or_edge_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'tag_or_edge_id' was not found in serialized data! Struct: IndexSpec")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexSpec')
    if self.contexts != None:
      oprot.writeFieldBegin('contexts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.contexts))
      for iter381 in self.contexts:
        iter381.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.is_edge != None:
      oprot.writeFieldBegin('is_edge', TType.BOOL, 2)
      oprot.writeBool(self.is_edge)
      oprot.writeFieldEnd()
    if self.tag_or_edge_id != None:
      oprot.writeFieldBegin('tag_or_edge_id', TType.I32, 3)
      oprot.writeI32(self.tag_or_edge_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.contexts is not None:
      value = pprint.pformat(self.contexts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    contexts=%s' % (value))
    if self.is_edge is not None:
      value = pprint.pformat(self.is_edge, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_edge=%s' % (value))
    if self.tag_or_edge_id is not None:
      value = pprint.pformat(self.tag_or_edge_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_or_edge_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookupIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - return_columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype385, _size382) = iprot.readListBegin()
          if _size382 >= 0:
            for _i386 in six.moves.range(_size382):
              _elem387 = iprot.readI32()
              self.parts.append(_elem387)
          else: 
            while iprot.peekList():
              _elem388 = iprot.readI32()
              self.parts.append(_elem388)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype392, _size389) = iprot.readListBegin()
          if _size389 >= 0:
            for _i393 in six.moves.range(_size389):
              _elem394 = iprot.readString()
              self.return_columns.append(_elem394)
          else: 
            while iprot.peekList():
              _elem395 = iprot.readString()
              self.return_columns.append(_elem395)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.space_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'space_id' was not found in serialized data! Struct: LookupIndexRequest")

    if self.parts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'parts' was not found in serialized data! Struct: LookupIndexRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter396 in self.parts:
        oprot.writeI32(iter396)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter397 in self.return_columns:
        oprot.writeString(iter397)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LookupAndTraverseRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - traverse_spec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype401, _size398) = iprot.readListBegin()
          if _size398 >= 0:
            for _i402 in six.moves.range(_size398):
              _elem403 = iprot.readI32()
              self.parts.append(_elem403)
          else: 
            while iprot.peekList():
              _elem404 = iprot.readI32()
              self.parts.append(_elem404)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.space_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'space_id' was not found in serialized data! Struct: LookupAndTraverseRequest")

    if self.parts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'parts' was not found in serialized data! Struct: LookupAndTraverseRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupAndTraverseRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter405 in self.parts:
        oprot.writeI32(iter405)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TaskPara:
  """
  Attributes:
   - space_id
   - parts
   - task_specfic_paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype409, _size406) = iprot.readListBegin()
          if _size406 >= 0:
            for _i410 in six.moves.range(_size406):
              _elem411 = iprot.readI32()
              self.parts.append(_elem411)
          else: 
            while iprot.peekList():
              _elem412 = iprot.readI32()
              self.parts.append(_elem412)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.task_specfic_paras = []
          (_etype416, _size413) = iprot.readListBegin()
          if _size413 >= 0:
            for _i417 in six.moves.range(_size413):
              _elem418 = iprot.readString()
              self.task_specfic_paras.append(_elem418)
          else: 
            while iprot.peekList():
              _elem419 = iprot.readString()
              self.task_specfic_paras.append(_elem419)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TaskPara')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter420 in self.parts:
        oprot.writeI32(iter420)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.task_specfic_paras != None:
      oprot.writeFieldBegin('task_specfic_paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.task_specfic_paras))
      for iter421 in self.task_specfic_paras:
        oprot.writeString(iter421)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.task_specfic_paras is not None:
      value = pprint.pformat(self.task_specfic_paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_specfic_paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddAdminTaskRequest:
  """
  Attributes:
   - cmd
   - job_id
   - task_id
   - para
   - concurrency
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.para = TaskPara()
          self.para.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.concurrency = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddAdminTaskRequest')
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 1)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 2)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 3)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.para != None:
      oprot.writeFieldBegin('para', TType.STRUCT, 4)
      self.para.write(oprot)
      oprot.writeFieldEnd()
    if self.concurrency != None:
      oprot.writeFieldBegin('concurrency', TType.I32, 5)
      oprot.writeI32(self.concurrency)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.para is not None:
      value = pprint.pformat(self.para, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    para=%s' % (value))
    if self.concurrency is not None:
      value = pprint.pformat(self.concurrency, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    concurrency=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class StopAdminTaskRequest:
  """
  Attributes:
   - job_id
   - task_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StopAdminTaskRequest')
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 1)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 2)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdminExecResp:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: AdminExecResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminExecResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TransLeaderReq:
  """
  Attributes:
   - space_id
   - part_id
   - new_leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_leader = nebula2.common.ttypes.HostAddr()
          self.new_leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TransLeaderReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.new_leader != None:
      oprot.writeFieldBegin('new_leader', TType.STRUCT, 3)
      self.new_leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.new_leader is not None:
      value = pprint.pformat(self.new_leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddPartReq:
  """
  Attributes:
   - space_id
   - part_id
   - as_learner
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.as_learner = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddPartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.as_learner != None:
      oprot.writeFieldBegin('as_learner', TType.BOOL, 3)
      oprot.writeBool(self.as_learner)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.as_learner is not None:
      value = pprint.pformat(self.as_learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    as_learner=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddLearnerReq:
  """
  Attributes:
   - space_id
   - part_id
   - learner
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.learner = nebula2.common.ttypes.HostAddr()
          self.learner.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddLearnerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.learner != None:
      oprot.writeFieldBegin('learner', TType.STRUCT, 3)
      self.learner.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.learner is not None:
      value = pprint.pformat(self.learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    learner=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemovePartReq:
  """
  Attributes:
   - space_id
   - part_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemovePartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MemberChangeReq:
  """
  Attributes:
   - space_id
   - part_id
   - peer
   - add
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.peer = nebula2.common.ttypes.HostAddr()
          self.peer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.add = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MemberChangeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peer != None:
      oprot.writeFieldBegin('peer', TType.STRUCT, 3)
      self.peer.write(oprot)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BOOL, 4)
      oprot.writeBool(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peer is not None:
      value = pprint.pformat(self.peer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peer=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CatchUpDataReq:
  """
  Attributes:
   - space_id
   - part_id
   - target
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.target = nebula2.common.ttypes.HostAddr()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CatchUpDataReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.target != None:
      oprot.writeFieldBegin('target', TType.STRUCT, 3)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.target is not None:
      value = pprint.pformat(self.target, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    target=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetLeaderReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateCPRequest:
  """
  Attributes:
   - space_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropCPRequest:
  """
  Attributes:
   - space_id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropCPRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BlockingSignRequest:
  """
  Attributes:
   - space_id
   - sign
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sign = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.sign == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'sign' was not found in serialized data! Struct: BlockingSignRequest")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BlockingSignRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.sign != None:
      oprot.writeFieldBegin('sign', TType.I32, 2)
      oprot.writeI32(self.sign)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.sign is not None:
      value = pprint.pformat(self.sign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sign=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetLeaderPartsResp:
  """
  Attributes:
   - result
   - leader_parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype423, _vtype424, _size422 ) = iprot.readMapBegin() 
          if _size422 >= 0:
            for _i426 in six.moves.range(_size422):
              _key427 = iprot.readI32()
              _val428 = []
              (_etype432, _size429) = iprot.readListBegin()
              if _size429 >= 0:
                for _i433 in six.moves.range(_size429):
                  _elem434 = iprot.readI32()
                  _val428.append(_elem434)
              else: 
                while iprot.peekList():
                  _elem435 = iprot.readI32()
                  _val428.append(_elem435)
              iprot.readListEnd()
              self.leader_parts[_key427] = _val428
          else: 
            while iprot.peekMap():
              _key436 = iprot.readI32()
              _val437 = []
              (_etype441, _size438) = iprot.readListBegin()
              if _size438 >= 0:
                for _i442 in six.moves.range(_size438):
                  _elem443 = iprot.readI32()
                  _val437.append(_elem443)
              else: 
                while iprot.peekList():
                  _elem444 = iprot.readI32()
                  _val437.append(_elem444)
              iprot.readListEnd()
              self.leader_parts[_key436] = _val437
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: GetLeaderPartsResp")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderPartsResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_parts))
      for kiter445,viter446 in self.leader_parts.items():
        oprot.writeI32(kiter445)
        oprot.writeListBegin(TType.I32, len(viter446))
        for iter447 in viter446:
          oprot.writeI32(iter447)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CheckPeersReq:
  """
  Attributes:
   - space_id
   - part_id
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype451, _size448) = iprot.readListBegin()
          if _size448 >= 0:
            for _i452 in six.moves.range(_size448):
              _elem453 = nebula2.common.ttypes.HostAddr()
              _elem453.read(iprot)
              self.peers.append(_elem453)
          else: 
            while iprot.peekList():
              _elem454 = nebula2.common.ttypes.HostAddr()
              _elem454.read(iprot)
              self.peers.append(_elem454)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckPeersReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter455 in self.peers:
        iter455.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RebuildIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - index_id
   - is_offline
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype459, _size456) = iprot.readListBegin()
          if _size456 >= 0:
            for _i460 in six.moves.range(_size456):
              _elem461 = iprot.readI32()
              self.parts.append(_elem461)
          else: 
            while iprot.peekList():
              _elem462 = iprot.readI32()
              self.parts.append(_elem462)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.is_offline = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter463 in self.parts:
        oprot.writeI32(iter463)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 3)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.is_offline != None:
      oprot.writeFieldBegin('is_offline', TType.BOOL, 4)
      oprot.writeBool(self.is_offline)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.is_offline is not None:
      value = pprint.pformat(self.is_offline, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_offline=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVGetRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_partly
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype465, _vtype466, _size464 ) = iprot.readMapBegin() 
          if _size464 >= 0:
            for _i468 in six.moves.range(_size464):
              _key469 = iprot.readI32()
              _val470 = []
              (_etype474, _size471) = iprot.readListBegin()
              if _size471 >= 0:
                for _i475 in six.moves.range(_size471):
                  _elem476 = iprot.readString()
                  _val470.append(_elem476)
              else: 
                while iprot.peekList():
                  _elem477 = iprot.readString()
                  _val470.append(_elem477)
              iprot.readListEnd()
              self.parts[_key469] = _val470
          else: 
            while iprot.peekMap():
              _key478 = iprot.readI32()
              _val479 = []
              (_etype483, _size480) = iprot.readListBegin()
              if _size480 >= 0:
                for _i484 in six.moves.range(_size480):
                  _elem485 = iprot.readString()
                  _val479.append(_elem485)
              else: 
                while iprot.peekList():
                  _elem486 = iprot.readString()
                  _val479.append(_elem486)
              iprot.readListEnd()
              self.parts[_key478] = _val479
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.return_partly = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter487,viter488 in self.parts.items():
        oprot.writeI32(kiter487)
        oprot.writeListBegin(TType.STRING, len(viter488))
        for iter489 in viter488:
          oprot.writeString(iter489)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_partly != None:
      oprot.writeFieldBegin('return_partly', TType.BOOL, 3)
      oprot.writeBool(self.return_partly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_partly is not None:
      value = pprint.pformat(self.return_partly, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_partly=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVGetResponse:
  """
  Attributes:
   - result
   - key_values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.key_values = {}
          (_ktype491, _vtype492, _size490 ) = iprot.readMapBegin() 
          if _size490 >= 0:
            for _i494 in six.moves.range(_size490):
              _key495 = iprot.readString()
              _val496 = iprot.readString()
              self.key_values[_key495] = _val496
          else: 
            while iprot.peekMap():
              _key497 = iprot.readString()
              _val498 = iprot.readString()
              self.key_values[_key497] = _val498
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.result == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'result' was not found in serialized data! Struct: KVGetResponse")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.key_values != None:
      oprot.writeFieldBegin('key_values', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.key_values))
      for kiter499,viter500 in self.key_values.items():
        oprot.writeString(kiter499)
        oprot.writeString(viter500)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.key_values is not None:
      value = pprint.pformat(self.key_values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key_values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVPutRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype502, _vtype503, _size501 ) = iprot.readMapBegin() 
          if _size501 >= 0:
            for _i505 in six.moves.range(_size501):
              _key506 = iprot.readI32()
              _val507 = []
              (_etype511, _size508) = iprot.readListBegin()
              if _size508 >= 0:
                for _i512 in six.moves.range(_size508):
                  _elem513 = nebula2.common.ttypes.KeyValue()
                  _elem513.read(iprot)
                  _val507.append(_elem513)
              else: 
                while iprot.peekList():
                  _elem514 = nebula2.common.ttypes.KeyValue()
                  _elem514.read(iprot)
                  _val507.append(_elem514)
              iprot.readListEnd()
              self.parts[_key506] = _val507
          else: 
            while iprot.peekMap():
              _key515 = iprot.readI32()
              _val516 = []
              (_etype520, _size517) = iprot.readListBegin()
              if _size517 >= 0:
                for _i521 in six.moves.range(_size517):
                  _elem522 = nebula2.common.ttypes.KeyValue()
                  _elem522.read(iprot)
                  _val516.append(_elem522)
              else: 
                while iprot.peekList():
                  _elem523 = nebula2.common.ttypes.KeyValue()
                  _elem523.read(iprot)
                  _val516.append(_elem523)
              iprot.readListEnd()
              self.parts[_key515] = _val516
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVPutRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter524,viter525 in self.parts.items():
        oprot.writeI32(kiter524)
        oprot.writeListBegin(TType.STRUCT, len(viter525))
        for iter526 in viter525:
          iter526.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KVRemoveRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype528, _vtype529, _size527 ) = iprot.readMapBegin() 
          if _size527 >= 0:
            for _i531 in six.moves.range(_size527):
              _key532 = iprot.readI32()
              _val533 = []
              (_etype537, _size534) = iprot.readListBegin()
              if _size534 >= 0:
                for _i538 in six.moves.range(_size534):
                  _elem539 = iprot.readString()
                  _val533.append(_elem539)
              else: 
                while iprot.peekList():
                  _elem540 = iprot.readString()
                  _val533.append(_elem540)
              iprot.readListEnd()
              self.parts[_key532] = _val533
          else: 
            while iprot.peekMap():
              _key541 = iprot.readI32()
              _val542 = []
              (_etype546, _size543) = iprot.readListBegin()
              if _size543 >= 0:
                for _i547 in six.moves.range(_size543):
                  _elem548 = iprot.readString()
                  _val542.append(_elem548)
              else: 
                while iprot.peekList():
                  _elem549 = iprot.readString()
                  _val542.append(_elem549)
              iprot.readListEnd()
              self.parts[_key541] = _val542
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVRemoveRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter550,viter551 in self.parts.items():
        oprot.writeI32(kiter550)
        oprot.writeListBegin(TType.STRING, len(viter551))
        for iter552 in viter551:
          oprot.writeString(iter552)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(PartitionResult)
PartitionResult.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 0, ), # 1
  (2, TType.I32, 'part_id', None, None, 0, ), # 2
  (3, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 3
)

PartitionResult.thrift_struct_annotations = {
}
PartitionResult.thrift_field_annotations = {
}

def PartitionResult__init__(self, code=None, part_id=None, leader=None,):
  self.code = code
  self.part_id = part_id
  self.leader = leader

PartitionResult.__init__ = PartitionResult__init__

def PartitionResult__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

PartitionResult.__getstate__ = lambda self: self.__dict__.copy()
PartitionResult.__setstate__ = PartitionResult__setstate__

all_structs.append(ResponseCommon)
ResponseCommon.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'failed_parts', (TType.STRUCT,[PartitionResult, PartitionResult.thrift_spec, False]), None, 0, ), # 1
  (2, TType.I32, 'latency_in_us', None, None, 0, ), # 2
)

ResponseCommon.thrift_struct_annotations = {
}
ResponseCommon.thrift_field_annotations = {
}

def ResponseCommon__init__(self, failed_parts=None, latency_in_us=None,):
  self.failed_parts = failed_parts
  self.latency_in_us = latency_in_us

ResponseCommon.__init__ = ResponseCommon__init__

def ResponseCommon__setstate__(self, state):
  state.setdefault('failed_parts', None)
  state.setdefault('latency_in_us', None)
  self.__dict__ = state

ResponseCommon.__getstate__ = lambda self: self.__dict__.copy()
ResponseCommon.__setstate__ = ResponseCommon__setstate__

all_structs.append(StatProp)
StatProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'prop', False, None, 2, ), # 2
  (3, TType.I32, 'stat', StatType, None, 2, ), # 3
)

StatProp.thrift_struct_annotations = {
}
StatProp.thrift_field_annotations = {
}

def StatProp__init__(self, alias=None, prop=None, stat=None,):
  self.alias = alias
  self.prop = prop
  self.stat = stat

StatProp.__init__ = StatProp__init__

def StatProp__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('prop', None)
  state.setdefault('stat', None)
  self.__dict__ = state

StatProp.__getstate__ = lambda self: self.__dict__.copy()
StatProp.__setstate__ = StatProp__setstate__

all_structs.append(Expr)
Expr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'expr', False, None, 2, ), # 2
)

Expr.thrift_struct_annotations = {
}
Expr.thrift_field_annotations = {
}

def Expr__init__(self, alias=None, expr=None,):
  self.alias = alias
  self.expr = expr

Expr.__init__ = Expr__init__

def Expr__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('expr', None)
  self.__dict__ = state

Expr.__getstate__ = lambda self: self.__dict__.copy()
Expr.__setstate__ = Expr__setstate__

all_structs.append(EdgeProp)
EdgeProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

EdgeProp.thrift_struct_annotations = {
}
EdgeProp.thrift_field_annotations = {
}

def EdgeProp__init__(self, type=None, props=None,):
  self.type = type
  self.props = props

EdgeProp.__init__ = EdgeProp__init__

def EdgeProp__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('props', None)
  self.__dict__ = state

EdgeProp.__getstate__ = lambda self: self.__dict__.copy()
EdgeProp.__setstate__ = EdgeProp__setstate__

all_structs.append(VertexProp)
VertexProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

VertexProp.thrift_struct_annotations = {
}
VertexProp.thrift_field_annotations = {
}

def VertexProp__init__(self, tag=None, props=None,):
  self.tag = tag
  self.props = props

VertexProp.__init__ = VertexProp__init__

def VertexProp__setstate__(self, state):
  state.setdefault('tag', None)
  state.setdefault('props', None)
  self.__dict__ = state

VertexProp.__getstate__ = lambda self: self.__dict__.copy()
VertexProp.__setstate__ = VertexProp__setstate__

all_structs.append(OrderBy)
OrderBy.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'prop', False, None, 2, ), # 1
  (2, TType.I32, 'direction', OrderDirection, None, 2, ), # 2
)

OrderBy.thrift_struct_annotations = {
}
OrderBy.thrift_field_annotations = {
}

def OrderBy__init__(self, prop=None, direction=None,):
  self.prop = prop
  self.direction = direction

OrderBy.__init__ = OrderBy__init__

def OrderBy__setstate__(self, state):
  state.setdefault('prop', None)
  state.setdefault('direction', None)
  self.__dict__ = state

OrderBy.__getstate__ = lambda self: self.__dict__.copy()
OrderBy.__setstate__ = OrderBy__setstate__

all_structs.append(TraverseSpec)
TraverseSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'edge_types', (TType.I32,None), None, 2, ), # 1
  (2, TType.I32, 'edge_direction', EdgeDirection,   1, 2, ), # 2
  (3, TType.BOOL, 'dedup', None, False, 2, ), # 3
  (4, TType.LIST, 'stat_props', (TType.STRUCT,[StatProp, StatProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 5
  (6, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 6
  (7, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 7
  (8, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 8
  (9, TType.BOOL, 'random', None, None, 1, ), # 9
  (10, TType.I64, 'limit', None, None, 1, ), # 10
  (11, TType.STRING, 'filter', False, None, 1, ), # 11
)

TraverseSpec.thrift_struct_annotations = {
}
TraverseSpec.thrift_field_annotations = {
}

def TraverseSpec__init__(self, edge_types=None, edge_direction=TraverseSpec.thrift_spec[2][4], dedup=TraverseSpec.thrift_spec[3][4], stat_props=None, vertex_props=None, edge_props=None, expressions=None, order_by=None, random=None, limit=None, filter=None,):
  self.edge_types = edge_types
  self.edge_direction = edge_direction
  self.dedup = dedup
  self.stat_props = stat_props
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.order_by = order_by
  self.random = random
  self.limit = limit
  self.filter = filter

TraverseSpec.__init__ = TraverseSpec__init__

def TraverseSpec__setstate__(self, state):
  state.setdefault('edge_types', None)
  state.setdefault('edge_direction',   1)
  state.setdefault('dedup', False)
  state.setdefault('stat_props', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('order_by', None)
  state.setdefault('random', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  self.__dict__ = state

TraverseSpec.__getstate__ = lambda self: self.__dict__.copy()
TraverseSpec.__setstate__ = TraverseSpec__setstate__

all_structs.append(GetNeighborsRequest)
GetNeighborsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Row, nebula2.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
)

GetNeighborsRequest.thrift_struct_annotations = {
}
GetNeighborsRequest.thrift_field_annotations = {
}

def GetNeighborsRequest__init__(self, space_id=None, column_names=None, parts=None, traverse_spec=None,):
  self.space_id = space_id
  self.column_names = column_names
  self.parts = parts
  self.traverse_spec = traverse_spec

GetNeighborsRequest.__init__ = GetNeighborsRequest__init__

def GetNeighborsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('column_names', None)
  state.setdefault('parts', None)
  state.setdefault('traverse_spec', None)
  self.__dict__ = state

GetNeighborsRequest.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsRequest.__setstate__ = GetNeighborsRequest__setstate__

all_structs.append(GetNeighborsResponse)
GetNeighborsResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'vertices', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetNeighborsResponse.thrift_struct_annotations = {
}
GetNeighborsResponse.thrift_field_annotations = {
}

def GetNeighborsResponse__init__(self, result=None, vertices=None,):
  self.result = result
  self.vertices = vertices

GetNeighborsResponse.__init__ = GetNeighborsResponse__init__

def GetNeighborsResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertices', None)
  self.__dict__ = state

GetNeighborsResponse.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsResponse.__setstate__ = GetNeighborsResponse__setstate__

all_structs.append(ExecResponse)
ExecResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

ExecResponse.thrift_struct_annotations = {
}
ExecResponse.thrift_field_annotations = {
}

def ExecResponse__init__(self, result=None,):
  self.result = result

ExecResponse.__init__ = ExecResponse__init__

def ExecResponse__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

ExecResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecResponse.__setstate__ = ExecResponse__setstate__

all_structs.append(GetPropRequest)
GetPropRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.Row, nebula2.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 3
  (4, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 5
  (6, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 6
  (7, TType.BOOL, 'dedup', None, False, 2, ), # 7
  (8, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 8
  (9, TType.I64, 'limit', None, None, 1, ), # 9
  (10, TType.STRING, 'filter', False, None, 1, ), # 10
)

GetPropRequest.thrift_struct_annotations = {
}
GetPropRequest.thrift_field_annotations = {
}

def GetPropRequest__init__(self, space_id=None, column_names=None, parts=None, vertex_props=None, edge_props=None, expressions=None, dedup=GetPropRequest.thrift_spec[7][4], order_by=None, limit=None, filter=None,):
  self.space_id = space_id
  self.column_names = column_names
  self.parts = parts
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.dedup = dedup
  self.order_by = order_by
  self.limit = limit
  self.filter = filter

GetPropRequest.__init__ = GetPropRequest__init__

def GetPropRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('column_names', None)
  state.setdefault('parts', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('dedup', False)
  state.setdefault('order_by', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  self.__dict__ = state

GetPropRequest.__getstate__ = lambda self: self.__dict__.copy()
GetPropRequest.__setstate__ = GetPropRequest__setstate__

all_structs.append(GetPropResponse)
GetPropResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetPropResponse.thrift_struct_annotations = {
}
GetPropResponse.thrift_field_annotations = {
}

def GetPropResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

GetPropResponse.__init__ = GetPropResponse__init__

def GetPropResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

GetPropResponse.__getstate__ = lambda self: self.__dict__.copy()
GetPropResponse.__setstate__ = GetPropResponse__setstate__

all_structs.append(NewTag)
NewTag.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewTag.thrift_struct_annotations = {
}
NewTag.thrift_field_annotations = {
}

def NewTag__init__(self, tag_id=None, props=None,):
  self.tag_id = tag_id
  self.props = props

NewTag.__init__ = NewTag__init__

def NewTag__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewTag.__getstate__ = lambda self: self.__dict__.copy()
NewTag.__setstate__ = NewTag__setstate__

all_structs.append(NewVertex)
NewVertex.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'id', False, None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[NewTag, NewTag.thrift_spec, False]), None, 2, ), # 2
)

NewVertex.thrift_struct_annotations = {
}
NewVertex.thrift_field_annotations = {
}

def NewVertex__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

NewVertex.__init__ = NewVertex__init__

def NewVertex__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

NewVertex.__getstate__ = lambda self: self.__dict__.copy()
NewVertex.__setstate__ = NewVertex__setstate__

all_structs.append(EdgeKey)
EdgeKey.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'src', False, None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
  (3, TType.I64, 'ranking', None, None, 2, ), # 3
  (4, TType.STRING, 'dst', False, None, 2, ), # 4
)

EdgeKey.thrift_struct_annotations = {
}
EdgeKey.thrift_field_annotations = {
}

def EdgeKey__init__(self, src=None, edge_type=None, ranking=None, dst=None,):
  self.src = src
  self.edge_type = edge_type
  self.ranking = ranking
  self.dst = dst

EdgeKey.__init__ = EdgeKey__init__

def EdgeKey__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('edge_type', None)
  state.setdefault('ranking', None)
  state.setdefault('dst', None)
  self.__dict__ = state

EdgeKey.__getstate__ = lambda self: self.__dict__.copy()
EdgeKey.__setstate__ = EdgeKey__setstate__

all_structs.append(NewEdge)
NewEdge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewEdge.thrift_struct_annotations = {
}
NewEdge.thrift_field_annotations = {
}

def NewEdge__init__(self, key=None, props=None,):
  self.key = key
  self.props = props

NewEdge.__init__ = NewEdge__init__

def NewEdge__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewEdge.__getstate__ = lambda self: self.__dict__.copy()
NewEdge.__setstate__ = NewEdge__setstate__

all_structs.append(AddVerticesRequest)
AddVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewVertex, NewVertex.thrift_spec, False])), None, 2, ), # 2
  (3, TType.MAP, 'prop_names', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 3
  (4, TType.BOOL, 'overwritable', None, True, 2, ), # 4
)

AddVerticesRequest.thrift_struct_annotations = {
}
AddVerticesRequest.thrift_field_annotations = {
}

def AddVerticesRequest__init__(self, space_id=None, parts=None, prop_names=None, overwritable=AddVerticesRequest.thrift_spec[4][4],):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.overwritable = overwritable

AddVerticesRequest.__init__ = AddVerticesRequest__init__

def AddVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('overwritable', True)
  self.__dict__ = state

AddVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddVerticesRequest.__setstate__ = AddVerticesRequest__setstate__

all_structs.append(AddEdgesRequest)
AddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewEdge, NewEdge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'prop_names', (TType.STRING,False), None, 2, ), # 3
  (4, TType.BOOL, 'overwritable', None, True, 2, ), # 4
)

AddEdgesRequest.thrift_struct_annotations = {
}
AddEdgesRequest.thrift_field_annotations = {
}

def AddEdgesRequest__init__(self, space_id=None, parts=None, prop_names=None, overwritable=AddEdgesRequest.thrift_spec[4][4],):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.overwritable = overwritable

AddEdgesRequest.__init__ = AddEdgesRequest__init__

def AddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('overwritable', True)
  self.__dict__ = state

AddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddEdgesRequest.__setstate__ = AddEdgesRequest__setstate__

all_structs.append(DeleteVerticesRequest)
DeleteVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
)

DeleteVerticesRequest.thrift_struct_annotations = {
}
DeleteVerticesRequest.thrift_field_annotations = {
}

def DeleteVerticesRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

DeleteVerticesRequest.__init__ = DeleteVerticesRequest__init__

def DeleteVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

DeleteVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteVerticesRequest.__setstate__ = DeleteVerticesRequest__setstate__

all_structs.append(DeleteEdgesRequest)
DeleteEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
)

DeleteEdgesRequest.thrift_struct_annotations = {
}
DeleteEdgesRequest.thrift_field_annotations = {
}

def DeleteEdgesRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

DeleteEdgesRequest.__init__ = DeleteEdgesRequest__init__

def DeleteEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

DeleteEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteEdgesRequest.__setstate__ = DeleteEdgesRequest__setstate__

all_structs.append(UpdateResponse)
UpdateResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'props', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

UpdateResponse.thrift_struct_annotations = {
}
UpdateResponse.thrift_field_annotations = {
}

def UpdateResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

UpdateResponse.__init__ = UpdateResponse__init__

def UpdateResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

UpdateResponse.__getstate__ = lambda self: self.__dict__.copy()
UpdateResponse.__setstate__ = UpdateResponse__setstate__

all_structs.append(UpdatedProp)
UpdatedProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRING, 'value', False, None, 0, ), # 2
)

UpdatedProp.thrift_struct_annotations = {
}
UpdatedProp.thrift_field_annotations = {
}

def UpdatedProp__init__(self, name=None, value=None,):
  self.name = name
  self.value = value

UpdatedProp.__init__ = UpdatedProp__init__

def UpdatedProp__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('value', None)
  self.__dict__ = state

UpdatedProp.__getstate__ = lambda self: self.__dict__.copy()
UpdatedProp.__setstate__ = UpdatedProp__setstate__

all_structs.append(UpdateVertexRequest)
UpdateVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'vertex_id', False, None, 2, ), # 3
  (4, TType.I32, 'tag_id', None, None, 0, ), # 4
  (5, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 5
  (6, TType.BOOL, 'insertable', None, False, 1, ), # 6
  (7, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 7
  (8, TType.STRING, 'condition', False, None, 1, ), # 8
)

UpdateVertexRequest.thrift_struct_annotations = {
}
UpdateVertexRequest.thrift_field_annotations = {
}

def UpdateVertexRequest__init__(self, space_id=None, part_id=None, vertex_id=None, tag_id=None, updated_props=None, insertable=UpdateVertexRequest.thrift_spec[6][4], return_props=None, condition=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.vertex_id = vertex_id
  self.tag_id = tag_id
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition

UpdateVertexRequest.__init__ = UpdateVertexRequest__init__

def UpdateVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('vertex_id', None)
  state.setdefault('tag_id', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  self.__dict__ = state

UpdateVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateVertexRequest.__setstate__ = UpdateVertexRequest__setstate__

all_structs.append(UpdateEdgeRequest)
UpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'edge_key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'insertable', None, False, 1, ), # 5
  (6, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 6
  (7, TType.STRING, 'condition', False, None, 1, ), # 7
)

UpdateEdgeRequest.thrift_struct_annotations = {
}
UpdateEdgeRequest.thrift_field_annotations = {
}

def UpdateEdgeRequest__init__(self, space_id=None, part_id=None, edge_key=None, updated_props=None, insertable=UpdateEdgeRequest.thrift_spec[5][4], return_props=None, condition=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.edge_key = edge_key
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition

UpdateEdgeRequest.__init__ = UpdateEdgeRequest__init__

def UpdateEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('edge_key', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  self.__dict__ = state

UpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateEdgeRequest.__setstate__ = UpdateEdgeRequest__setstate__

all_structs.append(GetUUIDReq)
GetUUIDReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
)

GetUUIDReq.thrift_struct_annotations = {
}
GetUUIDReq.thrift_field_annotations = {
}

def GetUUIDReq__init__(self, space_id=None, part_id=None, name=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.name = name

GetUUIDReq.__init__ = GetUUIDReq__init__

def GetUUIDReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

GetUUIDReq.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDReq.__setstate__ = GetUUIDReq__setstate__

all_structs.append(GetUUIDResp)
GetUUIDResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'id', False, None, 2, ), # 2
)

GetUUIDResp.thrift_struct_annotations = {
}
GetUUIDResp.thrift_field_annotations = {
}

def GetUUIDResp__init__(self, result=None, id=None,):
  self.result = result
  self.id = id

GetUUIDResp.__init__ = GetUUIDResp__init__

def GetUUIDResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('id', None)
  self.__dict__ = state

GetUUIDResp.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDResp.__setstate__ = GetUUIDResp__setstate__

all_structs.append(LookupIndexResp)
LookupIndexResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'data', [nebula2.common.ttypes.DataSet, nebula2.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

LookupIndexResp.thrift_struct_annotations = {
}
LookupIndexResp.thrift_field_annotations = {
}

def LookupIndexResp__init__(self, result=None, data=None,):
  self.result = result
  self.data = data

LookupIndexResp.__init__ = LookupIndexResp__init__

def LookupIndexResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('data', None)
  self.__dict__ = state

LookupIndexResp.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexResp.__setstate__ = LookupIndexResp__setstate__

all_structs.append(IndexColumnHint)
IndexColumnHint.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'column_name', False, None, 2, ), # 1
  (2, TType.I32, 'scan_type', ScanType, None, 2, ), # 2
  (3, TType.STRUCT, 'begin_value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.STRUCT, 'end_value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

IndexColumnHint.thrift_struct_annotations = {
}
IndexColumnHint.thrift_field_annotations = {
}

def IndexColumnHint__init__(self, column_name=None, scan_type=None, begin_value=None, end_value=None,):
  self.column_name = column_name
  self.scan_type = scan_type
  self.begin_value = begin_value
  self.end_value = end_value

IndexColumnHint.__init__ = IndexColumnHint__init__

def IndexColumnHint__setstate__(self, state):
  state.setdefault('column_name', None)
  state.setdefault('scan_type', None)
  state.setdefault('begin_value', None)
  state.setdefault('end_value', None)
  self.__dict__ = state

IndexColumnHint.__getstate__ = lambda self: self.__dict__.copy()
IndexColumnHint.__setstate__ = IndexColumnHint__setstate__

all_structs.append(IndexQueryContext)
IndexQueryContext.thrift_spec = (
  None, # 0
  (1, TType.I32, 'index_id', None, None, 2, ), # 1
  (2, TType.STRING, 'filter', False, None, 2, ), # 2
  (3, TType.LIST, 'column_hints', (TType.STRUCT,[IndexColumnHint, IndexColumnHint.thrift_spec, False]), None, 2, ), # 3
)

IndexQueryContext.thrift_struct_annotations = {
}
IndexQueryContext.thrift_field_annotations = {
}

def IndexQueryContext__init__(self, index_id=None, filter=None, column_hints=None,):
  self.index_id = index_id
  self.filter = filter
  self.column_hints = column_hints

IndexQueryContext.__init__ = IndexQueryContext__init__

def IndexQueryContext__setstate__(self, state):
  state.setdefault('index_id', None)
  state.setdefault('filter', None)
  state.setdefault('column_hints', None)
  self.__dict__ = state

IndexQueryContext.__getstate__ = lambda self: self.__dict__.copy()
IndexQueryContext.__setstate__ = IndexQueryContext__setstate__

all_structs.append(IndexSpec)
IndexSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'contexts', (TType.STRUCT,[IndexQueryContext, IndexQueryContext.thrift_spec, False]), None, 0, ), # 1
  (2, TType.BOOL, 'is_edge', None, None, 0, ), # 2
  (3, TType.I32, 'tag_or_edge_id', None, None, 0, ), # 3
)

IndexSpec.thrift_struct_annotations = {
}
IndexSpec.thrift_field_annotations = {
}

def IndexSpec__init__(self, contexts=None, is_edge=None, tag_or_edge_id=None,):
  self.contexts = contexts
  self.is_edge = is_edge
  self.tag_or_edge_id = tag_or_edge_id

IndexSpec.__init__ = IndexSpec__init__

def IndexSpec__setstate__(self, state):
  state.setdefault('contexts', None)
  state.setdefault('is_edge', None)
  state.setdefault('tag_or_edge_id', None)
  self.__dict__ = state

IndexSpec.__getstate__ = lambda self: self.__dict__.copy()
IndexSpec.__setstate__ = IndexSpec__setstate__

all_structs.append(LookupIndexRequest)
LookupIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'return_columns', (TType.STRING,False), None, 1, ), # 4
)

LookupIndexRequest.thrift_struct_annotations = {
}
LookupIndexRequest.thrift_field_annotations = {
}

def LookupIndexRequest__init__(self, space_id=None, parts=None, indices=None, return_columns=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.return_columns = return_columns

LookupIndexRequest.__init__ = LookupIndexRequest__init__

def LookupIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('return_columns', None)
  self.__dict__ = state

LookupIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexRequest.__setstate__ = LookupIndexRequest__setstate__

all_structs.append(LookupAndTraverseRequest)
LookupAndTraverseRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
)

LookupAndTraverseRequest.thrift_struct_annotations = {
}
LookupAndTraverseRequest.thrift_field_annotations = {
}

def LookupAndTraverseRequest__init__(self, space_id=None, parts=None, indices=None, traverse_spec=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.traverse_spec = traverse_spec

LookupAndTraverseRequest.__init__ = LookupAndTraverseRequest__init__

def LookupAndTraverseRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('traverse_spec', None)
  self.__dict__ = state

LookupAndTraverseRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupAndTraverseRequest.__setstate__ = LookupAndTraverseRequest__setstate__

all_structs.append(TaskPara)
TaskPara.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 1, ), # 2
  (3, TType.LIST, 'task_specfic_paras', (TType.STRING,False), None, 1, ), # 3
)

TaskPara.thrift_struct_annotations = {
}
TaskPara.thrift_field_annotations = {
}

def TaskPara__init__(self, space_id=None, parts=None, task_specfic_paras=None,):
  self.space_id = space_id
  self.parts = parts
  self.task_specfic_paras = task_specfic_paras

TaskPara.__init__ = TaskPara__init__

def TaskPara__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('task_specfic_paras', None)
  self.__dict__ = state

TaskPara.__getstate__ = lambda self: self.__dict__.copy()
TaskPara.__setstate__ = TaskPara__setstate__

all_structs.append(AddAdminTaskRequest)
AddAdminTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'cmd', nebula2.meta.ttypes.AdminCmd, None, 2, ), # 1
  (2, TType.I32, 'job_id', None, None, 2, ), # 2
  (3, TType.I32, 'task_id', None, None, 2, ), # 3
  (4, TType.STRUCT, 'para', [TaskPara, TaskPara.thrift_spec, False], None, 2, ), # 4
  (5, TType.I32, 'concurrency', None, None, 1, ), # 5
)

AddAdminTaskRequest.thrift_struct_annotations = {
}
AddAdminTaskRequest.thrift_field_annotations = {
}

def AddAdminTaskRequest__init__(self, cmd=None, job_id=None, task_id=None, para=None, concurrency=None,):
  self.cmd = cmd
  self.job_id = job_id
  self.task_id = task_id
  self.para = para
  self.concurrency = concurrency

AddAdminTaskRequest.__init__ = AddAdminTaskRequest__init__

def AddAdminTaskRequest__setstate__(self, state):
  state.setdefault('cmd', None)
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  state.setdefault('para', None)
  state.setdefault('concurrency', None)
  self.__dict__ = state

AddAdminTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
AddAdminTaskRequest.__setstate__ = AddAdminTaskRequest__setstate__

all_structs.append(StopAdminTaskRequest)
StopAdminTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_id', None, None, 2, ), # 1
  (2, TType.I32, 'task_id', None, None, 2, ), # 2
)

StopAdminTaskRequest.thrift_struct_annotations = {
}
StopAdminTaskRequest.thrift_field_annotations = {
}

def StopAdminTaskRequest__init__(self, job_id=None, task_id=None,):
  self.job_id = job_id
  self.task_id = task_id

StopAdminTaskRequest.__init__ = StopAdminTaskRequest__init__

def StopAdminTaskRequest__setstate__(self, state):
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  self.__dict__ = state

StopAdminTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
StopAdminTaskRequest.__setstate__ = StopAdminTaskRequest__setstate__

all_structs.append(AdminExecResp)
AdminExecResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

AdminExecResp.thrift_struct_annotations = {
}
AdminExecResp.thrift_field_annotations = {
}

def AdminExecResp__init__(self, result=None,):
  self.result = result

AdminExecResp.__init__ = AdminExecResp__init__

def AdminExecResp__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

AdminExecResp.__getstate__ = lambda self: self.__dict__.copy()
AdminExecResp.__setstate__ = AdminExecResp__setstate__

all_structs.append(TransLeaderReq)
TransLeaderReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'new_leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

TransLeaderReq.thrift_struct_annotations = {
}
TransLeaderReq.thrift_field_annotations = {
}

def TransLeaderReq__init__(self, space_id=None, part_id=None, new_leader=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.new_leader = new_leader

TransLeaderReq.__init__ = TransLeaderReq__init__

def TransLeaderReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('new_leader', None)
  self.__dict__ = state

TransLeaderReq.__getstate__ = lambda self: self.__dict__.copy()
TransLeaderReq.__setstate__ = TransLeaderReq__setstate__

all_structs.append(AddPartReq)
AddPartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.BOOL, 'as_learner', None, None, 2, ), # 3
)

AddPartReq.thrift_struct_annotations = {
}
AddPartReq.thrift_field_annotations = {
}

def AddPartReq__init__(self, space_id=None, part_id=None, as_learner=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.as_learner = as_learner

AddPartReq.__init__ = AddPartReq__init__

def AddPartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('as_learner', None)
  self.__dict__ = state

AddPartReq.__getstate__ = lambda self: self.__dict__.copy()
AddPartReq.__setstate__ = AddPartReq__setstate__

all_structs.append(AddLearnerReq)
AddLearnerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'learner', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

AddLearnerReq.thrift_struct_annotations = {
}
AddLearnerReq.thrift_field_annotations = {
}

def AddLearnerReq__init__(self, space_id=None, part_id=None, learner=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.learner = learner

AddLearnerReq.__init__ = AddLearnerReq__init__

def AddLearnerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('learner', None)
  self.__dict__ = state

AddLearnerReq.__getstate__ = lambda self: self.__dict__.copy()
AddLearnerReq.__setstate__ = AddLearnerReq__setstate__

all_structs.append(RemovePartReq)
RemovePartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
)

RemovePartReq.thrift_struct_annotations = {
}
RemovePartReq.thrift_field_annotations = {
}

def RemovePartReq__init__(self, space_id=None, part_id=None,):
  self.space_id = space_id
  self.part_id = part_id

RemovePartReq.__init__ = RemovePartReq__init__

def RemovePartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  self.__dict__ = state

RemovePartReq.__getstate__ = lambda self: self.__dict__.copy()
RemovePartReq.__setstate__ = RemovePartReq__setstate__

all_structs.append(MemberChangeReq)
MemberChangeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'peer', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'add', None, None, 2, ), # 4
)

MemberChangeReq.thrift_struct_annotations = {
}
MemberChangeReq.thrift_field_annotations = {
}

def MemberChangeReq__init__(self, space_id=None, part_id=None, peer=None, add=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peer = peer
  self.add = add

MemberChangeReq.__init__ = MemberChangeReq__init__

def MemberChangeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peer', None)
  state.setdefault('add', None)
  self.__dict__ = state

MemberChangeReq.__getstate__ = lambda self: self.__dict__.copy()
MemberChangeReq.__setstate__ = MemberChangeReq__setstate__

all_structs.append(CatchUpDataReq)
CatchUpDataReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'target', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

CatchUpDataReq.thrift_struct_annotations = {
}
CatchUpDataReq.thrift_field_annotations = {
}

def CatchUpDataReq__init__(self, space_id=None, part_id=None, target=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.target = target

CatchUpDataReq.__init__ = CatchUpDataReq__init__

def CatchUpDataReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('target', None)
  self.__dict__ = state

CatchUpDataReq.__getstate__ = lambda self: self.__dict__.copy()
CatchUpDataReq.__setstate__ = CatchUpDataReq__setstate__

all_structs.append(GetLeaderReq)
GetLeaderReq.thrift_spec = (
)

GetLeaderReq.thrift_struct_annotations = {
}
GetLeaderReq.thrift_field_annotations = {
}

all_structs.append(CreateCPRequest)
CreateCPRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

CreateCPRequest.thrift_struct_annotations = {
}
CreateCPRequest.thrift_field_annotations = {
}

def CreateCPRequest__init__(self, space_id=None, name=None,):
  self.space_id = space_id
  self.name = name

CreateCPRequest.__init__ = CreateCPRequest__init__

def CreateCPRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

CreateCPRequest.__getstate__ = lambda self: self.__dict__.copy()
CreateCPRequest.__setstate__ = CreateCPRequest__setstate__

all_structs.append(DropCPRequest)
DropCPRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

DropCPRequest.thrift_struct_annotations = {
}
DropCPRequest.thrift_field_annotations = {
}

def DropCPRequest__init__(self, space_id=None, name=None,):
  self.space_id = space_id
  self.name = name

DropCPRequest.__init__ = DropCPRequest__init__

def DropCPRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('name', None)
  self.__dict__ = state

DropCPRequest.__getstate__ = lambda self: self.__dict__.copy()
DropCPRequest.__setstate__ = DropCPRequest__setstate__

all_structs.append(BlockingSignRequest)
BlockingSignRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'sign', EngineSignType, None, 0, ), # 2
)

BlockingSignRequest.thrift_struct_annotations = {
}
BlockingSignRequest.thrift_field_annotations = {
}

def BlockingSignRequest__init__(self, space_id=None, sign=None,):
  self.space_id = space_id
  self.sign = sign

BlockingSignRequest.__init__ = BlockingSignRequest__init__

def BlockingSignRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('sign', None)
  self.__dict__ = state

BlockingSignRequest.__getstate__ = lambda self: self.__dict__.copy()
BlockingSignRequest.__setstate__ = BlockingSignRequest__setstate__

all_structs.append(GetLeaderPartsResp)
GetLeaderPartsResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'leader_parts', (TType.I32,None,TType.LIST,(TType.I32,None)), None, 2, ), # 2
)

GetLeaderPartsResp.thrift_struct_annotations = {
}
GetLeaderPartsResp.thrift_field_annotations = {
}

def GetLeaderPartsResp__init__(self, result=None, leader_parts=None,):
  self.result = result
  self.leader_parts = leader_parts

GetLeaderPartsResp.__init__ = GetLeaderPartsResp__init__

def GetLeaderPartsResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('leader_parts', None)
  self.__dict__ = state

GetLeaderPartsResp.__getstate__ = lambda self: self.__dict__.copy()
GetLeaderPartsResp.__setstate__ = GetLeaderPartsResp__setstate__

all_structs.append(CheckPeersReq)
CheckPeersReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

CheckPeersReq.thrift_struct_annotations = {
}
CheckPeersReq.thrift_field_annotations = {
}

def CheckPeersReq__init__(self, space_id=None, part_id=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peers = peers

CheckPeersReq.__init__ = CheckPeersReq__init__

def CheckPeersReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peers', None)
  self.__dict__ = state

CheckPeersReq.__getstate__ = lambda self: self.__dict__.copy()
CheckPeersReq.__setstate__ = CheckPeersReq__setstate__

all_structs.append(RebuildIndexRequest)
RebuildIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 2, ), # 2
  (3, TType.I32, 'index_id', None, None, 2, ), # 3
  (4, TType.BOOL, 'is_offline', None, None, 2, ), # 4
)

RebuildIndexRequest.thrift_struct_annotations = {
}
RebuildIndexRequest.thrift_field_annotations = {
}

def RebuildIndexRequest__init__(self, space_id=None, parts=None, index_id=None, is_offline=None,):
  self.space_id = space_id
  self.parts = parts
  self.index_id = index_id
  self.is_offline = is_offline

RebuildIndexRequest.__init__ = RebuildIndexRequest__init__

def RebuildIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('index_id', None)
  state.setdefault('is_offline', None)
  self.__dict__ = state

RebuildIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexRequest.__setstate__ = RebuildIndexRequest__setstate__

all_structs.append(KVGetRequest)
KVGetRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
  (3, TType.BOOL, 'return_partly', None, None, 2, ), # 3
)

KVGetRequest.thrift_struct_annotations = {
}
KVGetRequest.thrift_field_annotations = {
}

def KVGetRequest__init__(self, space_id=None, parts=None, return_partly=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_partly = return_partly

KVGetRequest.__init__ = KVGetRequest__init__

def KVGetRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_partly', None)
  self.__dict__ = state

KVGetRequest.__getstate__ = lambda self: self.__dict__.copy()
KVGetRequest.__setstate__ = KVGetRequest__setstate__

all_structs.append(KVGetResponse)
KVGetResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'key_values', (TType.STRING,False,TType.STRING,False), None, 2, ), # 2
)

KVGetResponse.thrift_struct_annotations = {
}
KVGetResponse.thrift_field_annotations = {
}

def KVGetResponse__init__(self, result=None, key_values=None,):
  self.result = result
  self.key_values = key_values

KVGetResponse.__init__ = KVGetResponse__init__

def KVGetResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('key_values', None)
  self.__dict__ = state

KVGetResponse.__getstate__ = lambda self: self.__dict__.copy()
KVGetResponse.__setstate__ = KVGetResponse__setstate__

all_structs.append(KVPutRequest)
KVPutRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.KeyValue, nebula2.common.ttypes.KeyValue.thrift_spec, False])), None, 2, ), # 2
)

KVPutRequest.thrift_struct_annotations = {
}
KVPutRequest.thrift_field_annotations = {
}

def KVPutRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVPutRequest.__init__ = KVPutRequest__init__

def KVPutRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVPutRequest.__getstate__ = lambda self: self.__dict__.copy()
KVPutRequest.__setstate__ = KVPutRequest__setstate__

all_structs.append(KVRemoveRequest)
KVRemoveRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
)

KVRemoveRequest.thrift_struct_annotations = {
}
KVRemoveRequest.thrift_field_annotations = {
}

def KVRemoveRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVRemoveRequest.__init__ = KVRemoveRequest__init__

def KVRemoveRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVRemoveRequest.__getstate__ = lambda self: self.__dict__.copy()
KVRemoveRequest.__setstate__ = KVRemoveRequest__setstate__

fix_spec(all_structs)
del all_structs
