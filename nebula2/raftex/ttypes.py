#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ErrorCode', 'AskForVoteRequest', 'AskForVoteResponse', 'LogEntry', 'AppendLogRequest', 'AppendLogResponse', 'SendSnapshotRequest', 'SendSnapshotResponse', 'ClusterID', 'GraphSpaceID', 'PartitionID', 'TermID', 'LogID', 'Port']

class ErrorCode:
  SUCCEEDED = 0
  E_LOG_GAP = -1
  E_LOG_STALE = -2
  E_MISSING_COMMIT = -3
  E_WAITING_SNAPSHOT = -4
  E_UNKNOWN_PART = -5
  E_TERM_OUT_OF_DATE = -6
  E_LAST_LOG_TERM_TOO_OLD = -7
  E_BAD_STATE = -8
  E_WRONG_LEADER = -9
  E_WAL_FAIL = -10
  E_NOT_READY = -11
  E_HOST_STOPPED = -12
  E_NOT_A_LEADER = -13
  E_HOST_DISCONNECTED = -14
  E_TOO_MANY_REQUESTS = -15
  E_PERSIST_SNAPSHOT_FAILED = -16
  E_BAD_ROLE = -17
  E_EXCEPTION = -20

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_LOG_GAP",
    -2: "E_LOG_STALE",
    -3: "E_MISSING_COMMIT",
    -4: "E_WAITING_SNAPSHOT",
    -5: "E_UNKNOWN_PART",
    -6: "E_TERM_OUT_OF_DATE",
    -7: "E_LAST_LOG_TERM_TOO_OLD",
    -8: "E_BAD_STATE",
    -9: "E_WRONG_LEADER",
    -10: "E_WAL_FAIL",
    -11: "E_NOT_READY",
    -12: "E_HOST_STOPPED",
    -13: "E_NOT_A_LEADER",
    -14: "E_HOST_DISCONNECTED",
    -15: "E_TOO_MANY_REQUESTS",
    -16: "E_PERSIST_SNAPSHOT_FAILED",
    -17: "E_BAD_ROLE",
    -20: "E_EXCEPTION",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_LOG_GAP": -1,
    "E_LOG_STALE": -2,
    "E_MISSING_COMMIT": -3,
    "E_WAITING_SNAPSHOT": -4,
    "E_UNKNOWN_PART": -5,
    "E_TERM_OUT_OF_DATE": -6,
    "E_LAST_LOG_TERM_TOO_OLD": -7,
    "E_BAD_STATE": -8,
    "E_WRONG_LEADER": -9,
    "E_WAL_FAIL": -10,
    "E_NOT_READY": -11,
    "E_HOST_STOPPED": -12,
    "E_NOT_A_LEADER": -13,
    "E_HOST_DISCONNECTED": -14,
    "E_TOO_MANY_REQUESTS": -15,
    "E_PERSIST_SNAPSHOT_FAILED": -16,
    "E_BAD_ROLE": -17,
    "E_EXCEPTION": -20,
  }

class AskForVoteRequest:
  """
  Attributes:
   - space
   - part
   - candidate_addr
   - candidate_port
   - term
   - last_log_id
   - last_log_term
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.candidate_addr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.candidate_port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.last_log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.last_log_term = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AskForVoteRequest')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.I32, 1)
      oprot.writeI32(self.space)
      oprot.writeFieldEnd()
    if self.part != None:
      oprot.writeFieldBegin('part', TType.I32, 2)
      oprot.writeI32(self.part)
      oprot.writeFieldEnd()
    if self.candidate_addr != None:
      oprot.writeFieldBegin('candidate_addr', TType.STRING, 3)
      oprot.writeString(self.candidate_addr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.candidate_addr, bytes) else oprot.writeString(self.candidate_addr)
      oprot.writeFieldEnd()
    if self.candidate_port != None:
      oprot.writeFieldBegin('candidate_port', TType.I32, 4)
      oprot.writeI32(self.candidate_port)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 5)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    if self.last_log_id != None:
      oprot.writeFieldBegin('last_log_id', TType.I64, 6)
      oprot.writeI64(self.last_log_id)
      oprot.writeFieldEnd()
    if self.last_log_term != None:
      oprot.writeFieldBegin('last_log_term', TType.I64, 7)
      oprot.writeI64(self.last_log_term)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.part is not None:
      value = pprint.pformat(self.part, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part=%s' % (value))
    if self.candidate_addr is not None:
      value = pprint.pformat(self.candidate_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    candidate_addr=%s' % (value))
    if self.candidate_port is not None:
      value = pprint.pformat(self.candidate_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    candidate_port=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    if self.last_log_id is not None:
      value = pprint.pformat(self.last_log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_id=%s' % (value))
    if self.last_log_term is not None:
      value = pprint.pformat(self.last_log_term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_term=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AskForVoteResponse:
  """
  Attributes:
   - error_code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AskForVoteResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LogEntry:
  """
  Attributes:
   - cluster
   - log_str
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.cluster = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.log_str = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LogEntry')
    if self.cluster != None:
      oprot.writeFieldBegin('cluster', TType.I64, 1)
      oprot.writeI64(self.cluster)
      oprot.writeFieldEnd()
    if self.log_str != None:
      oprot.writeFieldBegin('log_str', TType.STRING, 2)
      oprot.writeString(self.log_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.cluster is not None:
      value = pprint.pformat(self.cluster, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cluster=%s' % (value))
    if self.log_str is not None:
      value = pprint.pformat(self.log_str, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_str=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AppendLogRequest:
  """
  Attributes:
   - space
   - part
   - current_term
   - last_log_id
   - committed_log_id
   - leader_addr
   - leader_port
   - last_log_term_sent
   - last_log_id_sent
   - log_term
   - log_str_list
   - sending_snapshot
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.current_term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.last_log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.committed_log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.leader_addr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.leader_port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.last_log_term_sent = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.last_log_id_sent = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.log_term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.log_str_list = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = LogEntry()
              _elem5.read(iprot)
              self.log_str_list.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = LogEntry()
              _elem6.read(iprot)
              self.log_str_list.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.sending_snapshot = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AppendLogRequest')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.I32, 1)
      oprot.writeI32(self.space)
      oprot.writeFieldEnd()
    if self.part != None:
      oprot.writeFieldBegin('part', TType.I32, 2)
      oprot.writeI32(self.part)
      oprot.writeFieldEnd()
    if self.current_term != None:
      oprot.writeFieldBegin('current_term', TType.I64, 3)
      oprot.writeI64(self.current_term)
      oprot.writeFieldEnd()
    if self.last_log_id != None:
      oprot.writeFieldBegin('last_log_id', TType.I64, 4)
      oprot.writeI64(self.last_log_id)
      oprot.writeFieldEnd()
    if self.committed_log_id != None:
      oprot.writeFieldBegin('committed_log_id', TType.I64, 5)
      oprot.writeI64(self.committed_log_id)
      oprot.writeFieldEnd()
    if self.leader_addr != None:
      oprot.writeFieldBegin('leader_addr', TType.STRING, 6)
      oprot.writeString(self.leader_addr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.leader_addr, bytes) else oprot.writeString(self.leader_addr)
      oprot.writeFieldEnd()
    if self.leader_port != None:
      oprot.writeFieldBegin('leader_port', TType.I32, 7)
      oprot.writeI32(self.leader_port)
      oprot.writeFieldEnd()
    if self.last_log_term_sent != None:
      oprot.writeFieldBegin('last_log_term_sent', TType.I64, 8)
      oprot.writeI64(self.last_log_term_sent)
      oprot.writeFieldEnd()
    if self.last_log_id_sent != None:
      oprot.writeFieldBegin('last_log_id_sent', TType.I64, 9)
      oprot.writeI64(self.last_log_id_sent)
      oprot.writeFieldEnd()
    if self.log_term != None:
      oprot.writeFieldBegin('log_term', TType.I64, 10)
      oprot.writeI64(self.log_term)
      oprot.writeFieldEnd()
    if self.log_str_list != None:
      oprot.writeFieldBegin('log_str_list', TType.LIST, 11)
      oprot.writeListBegin(TType.STRUCT, len(self.log_str_list))
      for iter7 in self.log_str_list:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sending_snapshot != None:
      oprot.writeFieldBegin('sending_snapshot', TType.BOOL, 12)
      oprot.writeBool(self.sending_snapshot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.part is not None:
      value = pprint.pformat(self.part, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part=%s' % (value))
    if self.current_term is not None:
      value = pprint.pformat(self.current_term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    current_term=%s' % (value))
    if self.last_log_id is not None:
      value = pprint.pformat(self.last_log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_id=%s' % (value))
    if self.committed_log_id is not None:
      value = pprint.pformat(self.committed_log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    committed_log_id=%s' % (value))
    if self.leader_addr is not None:
      value = pprint.pformat(self.leader_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_addr=%s' % (value))
    if self.leader_port is not None:
      value = pprint.pformat(self.leader_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_port=%s' % (value))
    if self.last_log_term_sent is not None:
      value = pprint.pformat(self.last_log_term_sent, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_term_sent=%s' % (value))
    if self.last_log_id_sent is not None:
      value = pprint.pformat(self.last_log_id_sent, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_id_sent=%s' % (value))
    if self.log_term is not None:
      value = pprint.pformat(self.log_term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_term=%s' % (value))
    if self.log_str_list is not None:
      value = pprint.pformat(self.log_str_list, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_str_list=%s' % (value))
    if self.sending_snapshot is not None:
      value = pprint.pformat(self.sending_snapshot, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sending_snapshot=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AppendLogResponse:
  """
  Attributes:
   - error_code
   - current_term
   - leader_addr
   - leader_port
   - committed_log_id
   - last_log_id
   - last_log_term
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.current_term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.leader_addr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.leader_port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.committed_log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.last_log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.last_log_term = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AppendLogResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.current_term != None:
      oprot.writeFieldBegin('current_term', TType.I64, 2)
      oprot.writeI64(self.current_term)
      oprot.writeFieldEnd()
    if self.leader_addr != None:
      oprot.writeFieldBegin('leader_addr', TType.STRING, 3)
      oprot.writeString(self.leader_addr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.leader_addr, bytes) else oprot.writeString(self.leader_addr)
      oprot.writeFieldEnd()
    if self.leader_port != None:
      oprot.writeFieldBegin('leader_port', TType.I32, 4)
      oprot.writeI32(self.leader_port)
      oprot.writeFieldEnd()
    if self.committed_log_id != None:
      oprot.writeFieldBegin('committed_log_id', TType.I64, 5)
      oprot.writeI64(self.committed_log_id)
      oprot.writeFieldEnd()
    if self.last_log_id != None:
      oprot.writeFieldBegin('last_log_id', TType.I64, 6)
      oprot.writeI64(self.last_log_id)
      oprot.writeFieldEnd()
    if self.last_log_term != None:
      oprot.writeFieldBegin('last_log_term', TType.I64, 7)
      oprot.writeI64(self.last_log_term)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    if self.current_term is not None:
      value = pprint.pformat(self.current_term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    current_term=%s' % (value))
    if self.leader_addr is not None:
      value = pprint.pformat(self.leader_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_addr=%s' % (value))
    if self.leader_port is not None:
      value = pprint.pformat(self.leader_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_port=%s' % (value))
    if self.committed_log_id is not None:
      value = pprint.pformat(self.committed_log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    committed_log_id=%s' % (value))
    if self.last_log_id is not None:
      value = pprint.pformat(self.last_log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_id=%s' % (value))
    if self.last_log_term is not None:
      value = pprint.pformat(self.last_log_term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_log_term=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SendSnapshotRequest:
  """
  Attributes:
   - space
   - part
   - term
   - committed_log_id
   - committed_log_term
   - leader_addr
   - leader_port
   - rows
   - total_size
   - total_count
   - done
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.committed_log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.committed_log_term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.leader_addr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.leader_port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.rows = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = iprot.readString()
              self.rows.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = iprot.readString()
              self.rows.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.total_size = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.total_count = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.done = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SendSnapshotRequest')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.I32, 1)
      oprot.writeI32(self.space)
      oprot.writeFieldEnd()
    if self.part != None:
      oprot.writeFieldBegin('part', TType.I32, 2)
      oprot.writeI32(self.part)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 3)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    if self.committed_log_id != None:
      oprot.writeFieldBegin('committed_log_id', TType.I64, 4)
      oprot.writeI64(self.committed_log_id)
      oprot.writeFieldEnd()
    if self.committed_log_term != None:
      oprot.writeFieldBegin('committed_log_term', TType.I64, 5)
      oprot.writeI64(self.committed_log_term)
      oprot.writeFieldEnd()
    if self.leader_addr != None:
      oprot.writeFieldBegin('leader_addr', TType.STRING, 6)
      oprot.writeString(self.leader_addr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.leader_addr, bytes) else oprot.writeString(self.leader_addr)
      oprot.writeFieldEnd()
    if self.leader_port != None:
      oprot.writeFieldBegin('leader_port', TType.I32, 7)
      oprot.writeI32(self.leader_port)
      oprot.writeFieldEnd()
    if self.rows != None:
      oprot.writeFieldBegin('rows', TType.LIST, 8)
      oprot.writeListBegin(TType.STRING, len(self.rows))
      for iter15 in self.rows:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.total_size != None:
      oprot.writeFieldBegin('total_size', TType.I64, 9)
      oprot.writeI64(self.total_size)
      oprot.writeFieldEnd()
    if self.total_count != None:
      oprot.writeFieldBegin('total_count', TType.I64, 10)
      oprot.writeI64(self.total_count)
      oprot.writeFieldEnd()
    if self.done != None:
      oprot.writeFieldBegin('done', TType.BOOL, 11)
      oprot.writeBool(self.done)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.part is not None:
      value = pprint.pformat(self.part, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    if self.committed_log_id is not None:
      value = pprint.pformat(self.committed_log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    committed_log_id=%s' % (value))
    if self.committed_log_term is not None:
      value = pprint.pformat(self.committed_log_term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    committed_log_term=%s' % (value))
    if self.leader_addr is not None:
      value = pprint.pformat(self.leader_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_addr=%s' % (value))
    if self.leader_port is not None:
      value = pprint.pformat(self.leader_port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_port=%s' % (value))
    if self.rows is not None:
      value = pprint.pformat(self.rows, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    rows=%s' % (value))
    if self.total_size is not None:
      value = pprint.pformat(self.total_size, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    total_size=%s' % (value))
    if self.total_count is not None:
      value = pprint.pformat(self.total_count, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    total_count=%s' % (value))
    if self.done is not None:
      value = pprint.pformat(self.done, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    done=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SendSnapshotResponse:
  """
  Attributes:
   - error_code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SendSnapshotResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

ClusterID = UnimplementedTypedef()
GraphSpaceID = UnimplementedTypedef()
PartitionID = UnimplementedTypedef()
TermID = UnimplementedTypedef()
LogID = UnimplementedTypedef()
Port = UnimplementedTypedef()
all_structs.append(AskForVoteRequest)
AskForVoteRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space', None, None, 2, ), # 1
  (2, TType.I32, 'part', None, None, 2, ), # 2
  (3, TType.STRING, 'candidate_addr', True, None, 2, ), # 3
  (4, TType.I32, 'candidate_port', None, None, 2, ), # 4
  (5, TType.I64, 'term', None, None, 2, ), # 5
  (6, TType.I64, 'last_log_id', None, None, 2, ), # 6
  (7, TType.I64, 'last_log_term', None, None, 2, ), # 7
)

AskForVoteRequest.thrift_struct_annotations = {
}
AskForVoteRequest.thrift_field_annotations = {
}

def AskForVoteRequest__init__(self, space=None, part=None, candidate_addr=None, candidate_port=None, term=None, last_log_id=None, last_log_term=None,):
  self.space = space
  self.part = part
  self.candidate_addr = candidate_addr
  self.candidate_port = candidate_port
  self.term = term
  self.last_log_id = last_log_id
  self.last_log_term = last_log_term

AskForVoteRequest.__init__ = AskForVoteRequest__init__

def AskForVoteRequest__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('part', None)
  state.setdefault('candidate_addr', None)
  state.setdefault('candidate_port', None)
  state.setdefault('term', None)
  state.setdefault('last_log_id', None)
  state.setdefault('last_log_term', None)
  self.__dict__ = state

AskForVoteRequest.__getstate__ = lambda self: self.__dict__.copy()
AskForVoteRequest.__setstate__ = AskForVoteRequest__setstate__

all_structs.append(AskForVoteResponse)
AskForVoteResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', ErrorCode, None, 2, ), # 1
)

AskForVoteResponse.thrift_struct_annotations = {
}
AskForVoteResponse.thrift_field_annotations = {
}

def AskForVoteResponse__init__(self, error_code=None,):
  self.error_code = error_code

AskForVoteResponse.__init__ = AskForVoteResponse__init__

def AskForVoteResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  self.__dict__ = state

AskForVoteResponse.__getstate__ = lambda self: self.__dict__.copy()
AskForVoteResponse.__setstate__ = AskForVoteResponse__setstate__

all_structs.append(LogEntry)
LogEntry.thrift_spec = (
  None, # 0
  (1, TType.I64, 'cluster', None, None, 2, ), # 1
  (2, TType.STRING, 'log_str', False, None, 2, ), # 2
)

LogEntry.thrift_struct_annotations = {
}
LogEntry.thrift_field_annotations = {
}

def LogEntry__init__(self, cluster=None, log_str=None,):
  self.cluster = cluster
  self.log_str = log_str

LogEntry.__init__ = LogEntry__init__

def LogEntry__setstate__(self, state):
  state.setdefault('cluster', None)
  state.setdefault('log_str', None)
  self.__dict__ = state

LogEntry.__getstate__ = lambda self: self.__dict__.copy()
LogEntry.__setstate__ = LogEntry__setstate__

all_structs.append(AppendLogRequest)
AppendLogRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space', None, None, 2, ), # 1
  (2, TType.I32, 'part', None, None, 2, ), # 2
  (3, TType.I64, 'current_term', None, None, 2, ), # 3
  (4, TType.I64, 'last_log_id', None, None, 2, ), # 4
  (5, TType.I64, 'committed_log_id', None, None, 2, ), # 5
  (6, TType.STRING, 'leader_addr', True, None, 2, ), # 6
  (7, TType.I32, 'leader_port', None, None, 2, ), # 7
  (8, TType.I64, 'last_log_term_sent', None, None, 2, ), # 8
  (9, TType.I64, 'last_log_id_sent', None, None, 2, ), # 9
  (10, TType.I64, 'log_term', None, None, 2, ), # 10
  (11, TType.LIST, 'log_str_list', (TType.STRUCT,[LogEntry, LogEntry.thrift_spec, False]), None, 2, ), # 11
  (12, TType.BOOL, 'sending_snapshot', None, None, 2, ), # 12
)

AppendLogRequest.thrift_struct_annotations = {
}
AppendLogRequest.thrift_field_annotations = {
}

def AppendLogRequest__init__(self, space=None, part=None, current_term=None, last_log_id=None, committed_log_id=None, leader_addr=None, leader_port=None, last_log_term_sent=None, last_log_id_sent=None, log_term=None, log_str_list=None, sending_snapshot=None,):
  self.space = space
  self.part = part
  self.current_term = current_term
  self.last_log_id = last_log_id
  self.committed_log_id = committed_log_id
  self.leader_addr = leader_addr
  self.leader_port = leader_port
  self.last_log_term_sent = last_log_term_sent
  self.last_log_id_sent = last_log_id_sent
  self.log_term = log_term
  self.log_str_list = log_str_list
  self.sending_snapshot = sending_snapshot

AppendLogRequest.__init__ = AppendLogRequest__init__

def AppendLogRequest__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('part', None)
  state.setdefault('current_term', None)
  state.setdefault('last_log_id', None)
  state.setdefault('committed_log_id', None)
  state.setdefault('leader_addr', None)
  state.setdefault('leader_port', None)
  state.setdefault('last_log_term_sent', None)
  state.setdefault('last_log_id_sent', None)
  state.setdefault('log_term', None)
  state.setdefault('log_str_list', None)
  state.setdefault('sending_snapshot', None)
  self.__dict__ = state

AppendLogRequest.__getstate__ = lambda self: self.__dict__.copy()
AppendLogRequest.__setstate__ = AppendLogRequest__setstate__

all_structs.append(AppendLogResponse)
AppendLogResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', ErrorCode, None, 2, ), # 1
  (2, TType.I64, 'current_term', None, None, 2, ), # 2
  (3, TType.STRING, 'leader_addr', True, None, 2, ), # 3
  (4, TType.I32, 'leader_port', None, None, 2, ), # 4
  (5, TType.I64, 'committed_log_id', None, None, 2, ), # 5
  (6, TType.I64, 'last_log_id', None, None, 2, ), # 6
  (7, TType.I64, 'last_log_term', None, None, 2, ), # 7
)

AppendLogResponse.thrift_struct_annotations = {
}
AppendLogResponse.thrift_field_annotations = {
}

def AppendLogResponse__init__(self, error_code=None, current_term=None, leader_addr=None, leader_port=None, committed_log_id=None, last_log_id=None, last_log_term=None,):
  self.error_code = error_code
  self.current_term = current_term
  self.leader_addr = leader_addr
  self.leader_port = leader_port
  self.committed_log_id = committed_log_id
  self.last_log_id = last_log_id
  self.last_log_term = last_log_term

AppendLogResponse.__init__ = AppendLogResponse__init__

def AppendLogResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  state.setdefault('current_term', None)
  state.setdefault('leader_addr', None)
  state.setdefault('leader_port', None)
  state.setdefault('committed_log_id', None)
  state.setdefault('last_log_id', None)
  state.setdefault('last_log_term', None)
  self.__dict__ = state

AppendLogResponse.__getstate__ = lambda self: self.__dict__.copy()
AppendLogResponse.__setstate__ = AppendLogResponse__setstate__

all_structs.append(SendSnapshotRequest)
SendSnapshotRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space', None, None, 2, ), # 1
  (2, TType.I32, 'part', None, None, 2, ), # 2
  (3, TType.I64, 'term', None, None, 2, ), # 3
  (4, TType.I64, 'committed_log_id', None, None, 2, ), # 4
  (5, TType.I64, 'committed_log_term', None, None, 2, ), # 5
  (6, TType.STRING, 'leader_addr', True, None, 2, ), # 6
  (7, TType.I32, 'leader_port', None, None, 2, ), # 7
  (8, TType.LIST, 'rows', (TType.STRING,False), None, 2, ), # 8
  (9, TType.I64, 'total_size', None, None, 2, ), # 9
  (10, TType.I64, 'total_count', None, None, 2, ), # 10
  (11, TType.BOOL, 'done', None, None, 2, ), # 11
)

SendSnapshotRequest.thrift_struct_annotations = {
}
SendSnapshotRequest.thrift_field_annotations = {
}

def SendSnapshotRequest__init__(self, space=None, part=None, term=None, committed_log_id=None, committed_log_term=None, leader_addr=None, leader_port=None, rows=None, total_size=None, total_count=None, done=None,):
  self.space = space
  self.part = part
  self.term = term
  self.committed_log_id = committed_log_id
  self.committed_log_term = committed_log_term
  self.leader_addr = leader_addr
  self.leader_port = leader_port
  self.rows = rows
  self.total_size = total_size
  self.total_count = total_count
  self.done = done

SendSnapshotRequest.__init__ = SendSnapshotRequest__init__

def SendSnapshotRequest__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('part', None)
  state.setdefault('term', None)
  state.setdefault('committed_log_id', None)
  state.setdefault('committed_log_term', None)
  state.setdefault('leader_addr', None)
  state.setdefault('leader_port', None)
  state.setdefault('rows', None)
  state.setdefault('total_size', None)
  state.setdefault('total_count', None)
  state.setdefault('done', None)
  self.__dict__ = state

SendSnapshotRequest.__getstate__ = lambda self: self.__dict__.copy()
SendSnapshotRequest.__setstate__ = SendSnapshotRequest__setstate__

all_structs.append(SendSnapshotResponse)
SendSnapshotResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', ErrorCode, None, 2, ), # 1
)

SendSnapshotResponse.thrift_struct_annotations = {
}
SendSnapshotResponse.thrift_field_annotations = {
}

def SendSnapshotResponse__init__(self, error_code=None,):
  self.error_code = error_code

SendSnapshotResponse.__init__ = SendSnapshotResponse__init__

def SendSnapshotResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  self.__dict__ = state

SendSnapshotResponse.__getstate__ = lambda self: self.__dict__.copy()
SendSnapshotResponse.__setstate__ = SendSnapshotResponse__setstate__

fix_spec(all_structs)
del all_structs
