#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
import sys
from nebula2.fbthrift.util.Recursive import fix_spec
from nebula2.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula2.fbthrift.protocol.TProtocol import TProtocolException


from .ttypes import UTF8STRINGS, ProfilingStats, PlanNodeBranchInfo, Pair, PlanNodeDescription, PlanDescription, ExecutionResponse, AuthResponse, VerifyClientVersionResp, VerifyClientVersionReq
import nebula2.common.ttypes

from nebula2.fbthrift.Thrift import TProcessor
import pprint
import warnings
from nebula2.fbthrift import Thrift
from nebula2.fbthrift.transport import TTransport
from nebula2.fbthrift.protocol import TBinaryProtocol
from nebula2.fbthrift.protocol import TCompactProtocol
from nebula2.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula2.fbthrift.protocol import fastproto
except ImportError:
  pass

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

from nebula2.fbthrift.util.Decorators import (
  future_process_main,
  future_process_method,
  process_main as thrift_process_main,
  process_method as thrift_process_method,
  should_run_on_thread,
  write_results_after_future,
)

class Iface:
  def authenticate(self, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    pass

  def signout(self, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    pass

  def execute(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def executeJson(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def verifyClientVersion(self, req=None):
    """
    Parameters:
     - req
    """
    pass


class ContextIface:
  def authenticate(self, handler_ctx, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    pass

  def signout(self, handler_ctx, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    pass

  def execute(self, handler_ctx, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def executeJson(self, handler_ctx, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def verifyClientVersion(self, handler_ctx, req=None):
    """
    Parameters:
     - req
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class authenticate_args:
  """
  Attributes:
   - username
   - password
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('authenticate_args')
    if self.username != None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password != None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.username is not None:
      value = pprint.pformat(self.username, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    username=%s' % (value))
    if self.password is not None:
      value = pprint.pformat(self.password, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    password=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(authenticate_args)
authenticate_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'username', False, None, 2, ), # 1
  (2, TType.STRING, 'password', False, None, 2, ), # 2
)

authenticate_args.thrift_struct_annotations = {
}
authenticate_args.thrift_field_annotations = {
}

def authenticate_args__init__(self, username=None, password=None,):
  self.username = username
  self.password = password

authenticate_args.__init__ = authenticate_args__init__

def authenticate_args__setstate__(self, state):
  state.setdefault('username', None)
  state.setdefault('password', None)
  self.__dict__ = state

authenticate_args.__getstate__ = lambda self: self.__dict__.copy()
authenticate_args.__setstate__ = authenticate_args__setstate__

class authenticate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('authenticate_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(authenticate_result)
authenticate_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [AuthResponse, AuthResponse.thrift_spec, False], None, 2, ), # 0
)

authenticate_result.thrift_struct_annotations = {
}
authenticate_result.thrift_field_annotations = {
}

def authenticate_result__init__(self, success=None,):
  self.success = success

authenticate_result.__init__ = authenticate_result__init__

def authenticate_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

authenticate_result.__getstate__ = lambda self: self.__dict__.copy()
authenticate_result.__setstate__ = authenticate_result__setstate__

class signout_args:
  """
  Attributes:
   - sessionId
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('signout_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(signout_args)
signout_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
)

signout_args.thrift_struct_annotations = {
}
signout_args.thrift_field_annotations = {
}

def signout_args__init__(self, sessionId=None,):
  self.sessionId = sessionId

signout_args.__init__ = signout_args__init__

def signout_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  self.__dict__ = state

signout_args.__getstate__ = lambda self: self.__dict__.copy()
signout_args.__setstate__ = signout_args__setstate__

class execute_args:
  """
  Attributes:
   - sessionId
   - stmt
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('execute_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(execute_args)
execute_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', False, None, 2, ), # 2
)

execute_args.thrift_struct_annotations = {
}
execute_args.thrift_field_annotations = {
}

def execute_args__init__(self, sessionId=None, stmt=None,):
  self.sessionId = sessionId
  self.stmt = stmt

execute_args.__init__ = execute_args__init__

def execute_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  self.__dict__ = state

execute_args.__getstate__ = lambda self: self.__dict__.copy()
execute_args.__setstate__ = execute_args__setstate__

class execute_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExecutionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('execute_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(execute_result)
execute_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExecutionResponse, ExecutionResponse.thrift_spec, False], None, 2, ), # 0
)

execute_result.thrift_struct_annotations = {
}
execute_result.thrift_field_annotations = {
}

def execute_result__init__(self, success=None,):
  self.success = success

execute_result.__init__ = execute_result__init__

def execute_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

execute_result.__getstate__ = lambda self: self.__dict__.copy()
execute_result.__setstate__ = execute_result__setstate__

class executeJson_args:
  """
  Attributes:
   - sessionId
   - stmt
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeJson_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(executeJson_args)
executeJson_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', False, None, 2, ), # 2
)

executeJson_args.thrift_struct_annotations = {
}
executeJson_args.thrift_field_annotations = {
}

def executeJson_args__init__(self, sessionId=None, stmt=None,):
  self.sessionId = sessionId
  self.stmt = stmt

executeJson_args.__init__ = executeJson_args__init__

def executeJson_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  self.__dict__ = state

executeJson_args.__getstate__ = lambda self: self.__dict__.copy()
executeJson_args.__setstate__ = executeJson_args__setstate__

class executeJson_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeJson_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(executeJson_result)
executeJson_result.thrift_spec = (
  (0, TType.STRING, 'success', False, None, 2, ), # 0
)

executeJson_result.thrift_struct_annotations = {
}
executeJson_result.thrift_field_annotations = {
}

def executeJson_result__init__(self, success=None,):
  self.success = success

executeJson_result.__init__ = executeJson_result__init__

def executeJson_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

executeJson_result.__getstate__ = lambda self: self.__dict__.copy()
executeJson_result.__setstate__ = executeJson_result__setstate__

class verifyClientVersion_args:
  """
  Attributes:
   - req
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = VerifyClientVersionReq()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('verifyClientVersion_args')
    if self.req != None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.req is not None:
      value = pprint.pformat(self.req, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    req=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(verifyClientVersion_args)
verifyClientVersion_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'req', [VerifyClientVersionReq, VerifyClientVersionReq.thrift_spec, False], None, 2, ), # 1
)

verifyClientVersion_args.thrift_struct_annotations = {
}
verifyClientVersion_args.thrift_field_annotations = {
}

def verifyClientVersion_args__init__(self, req=None,):
  self.req = req

verifyClientVersion_args.__init__ = verifyClientVersion_args__init__

def verifyClientVersion_args__setstate__(self, state):
  state.setdefault('req', None)
  self.__dict__ = state

verifyClientVersion_args.__getstate__ = lambda self: self.__dict__.copy()
verifyClientVersion_args.__setstate__ = verifyClientVersion_args__setstate__

class verifyClientVersion_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = VerifyClientVersionResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('verifyClientVersion_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(verifyClientVersion_result)
verifyClientVersion_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [VerifyClientVersionResp, VerifyClientVersionResp.thrift_spec, False], None, 2, ), # 0
)

verifyClientVersion_result.thrift_struct_annotations = {
}
verifyClientVersion_result.thrift_field_annotations = {
}

def verifyClientVersion_result__init__(self, success=None,):
  self.success = success

verifyClientVersion_result.__init__ = verifyClientVersion_result__init__

def verifyClientVersion_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

verifyClientVersion_result.__getstate__ = lambda self: self.__dict__.copy()
verifyClientVersion_result.__setstate__ = verifyClientVersion_result__setstate__

class Client(Iface):
  def __enter__(self):
    return self

  def __exit__(self, type, value, tb):
    self._iprot.trans.close()
    if self._iprot is not self._oprot:
      self._oprot.trans.close()

  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def authenticate(self, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    self.send_authenticate(username, password)
    return self.recv_authenticate()

  def send_authenticate(self, username=None, password=None):
    self._oprot.writeMessageBegin('authenticate', TMessageType.CALL, self._seqid)
    args = authenticate_args()
    args.username = username
    args.password = password
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticate failed: unknown result");

  def signout(self, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    self.send_signout(sessionId)

  def send_signout(self, sessionId=None):
    self._oprot.writeMessageBegin('signout', TMessageType.CALL, self._seqid)
    args = signout_args()
    args.sessionId = sessionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.onewayFlush()
  def execute(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    self.send_execute(sessionId, stmt)
    return self.recv_execute()

  def send_execute(self, sessionId=None, stmt=None):
    self._oprot.writeMessageBegin('execute', TMessageType.CALL, self._seqid)
    args = execute_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_execute(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "execute failed: unknown result");

  def executeJson(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    self.send_executeJson(sessionId, stmt)
    return self.recv_executeJson()

  def send_executeJson(self, sessionId=None, stmt=None):
    self._oprot.writeMessageBegin('executeJson', TMessageType.CALL, self._seqid)
    args = executeJson_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_executeJson(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = executeJson_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "executeJson failed: unknown result");

  def verifyClientVersion(self, req=None):
    """
    Parameters:
     - req
    """
    self.send_verifyClientVersion(req)
    return self.recv_verifyClientVersion()

  def send_verifyClientVersion(self, req=None):
    self._oprot.writeMessageBegin('verifyClientVersion', TMessageType.CALL, self._seqid)
    args = verifyClientVersion_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyClientVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = verifyClientVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyClientVersion failed: unknown result");


class Processor(Iface, TProcessor):
  _onewayMethods = ("signout",)

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._priorityMap = {}
    self._processMap["authenticate"] = Processor.process_authenticate
    self._priorityMap["authenticate"] = TPriority.NORMAL
    self._processMap["signout"] = Processor.process_signout
    self._priorityMap["signout"] = TPriority.NORMAL
    self._processMap["execute"] = Processor.process_execute
    self._priorityMap["execute"] = TPriority.NORMAL
    self._processMap["executeJson"] = Processor.process_executeJson
    self._priorityMap["executeJson"] = TPriority.NORMAL
    self._processMap["verifyClientVersion"] = Processor.process_verifyClientVersion
    self._priorityMap["verifyClientVersion"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @thrift_process_main()
  def process(self,): pass

  @thrift_process_method(authenticate_args, oneway=False)
  def process_authenticate(self, args, handler_ctx):
    result = authenticate_result()
    try:
      result.success = self._handler.authenticate(args.username, args.password)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'authenticate', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(signout_args, oneway=True)
  def process_signout(self, args, handler_ctx):
    try:
      self._handler.signout(args.sessionId)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'signout', ex)
      result = Thrift.TApplicationException(message=repr(ex))

  @thrift_process_method(execute_args, oneway=False)
  def process_execute(self, args, handler_ctx):
    result = execute_result()
    try:
      result.success = self._handler.execute(args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'execute', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeJson_args, oneway=False)
  def process_executeJson(self, args, handler_ctx):
    result = executeJson_result()
    try:
      result.success = self._handler.executeJson(args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeJson', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(verifyClientVersion_args, oneway=False)
  def process_verifyClientVersion(self, args, handler_ctx):
    result = verifyClientVersion_result()
    try:
      result.success = self._handler.verifyClientVersion(args.req)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'verifyClientVersion', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  _onewayMethods = ("signout",)

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._priorityMap = {}
    self._processMap["authenticate"] = ContextProcessor.process_authenticate
    self._priorityMap["authenticate"] = TPriority.NORMAL
    self._processMap["signout"] = ContextProcessor.process_signout
    self._priorityMap["signout"] = TPriority.NORMAL
    self._processMap["execute"] = ContextProcessor.process_execute
    self._priorityMap["execute"] = TPriority.NORMAL
    self._processMap["executeJson"] = ContextProcessor.process_executeJson
    self._priorityMap["executeJson"] = TPriority.NORMAL
    self._processMap["verifyClientVersion"] = ContextProcessor.process_verifyClientVersion
    self._priorityMap["verifyClientVersion"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @thrift_process_main()
  def process(self,): pass

  @thrift_process_method(authenticate_args, oneway=False)
  def process_authenticate(self, args, handler_ctx):
    result = authenticate_result()
    try:
      result.success = self._handler.authenticate(handler_ctx, args.username, args.password)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'authenticate', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(signout_args, oneway=True)
  def process_signout(self, args, handler_ctx):
    try:
      self._handler.signout(handler_ctx, args.sessionId)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'signout', ex)
      result = Thrift.TApplicationException(message=repr(ex))

  @thrift_process_method(execute_args, oneway=False)
  def process_execute(self, args, handler_ctx):
    result = execute_result()
    try:
      result.success = self._handler.execute(handler_ctx, args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'execute', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeJson_args, oneway=False)
  def process_executeJson(self, args, handler_ctx):
    result = executeJson_result()
    try:
      result.success = self._handler.executeJson(handler_ctx, args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeJson', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(verifyClientVersion_args, oneway=False)
  def process_verifyClientVersion(self, args, handler_ctx):
    result = verifyClientVersion_result()
    try:
      result.success = self._handler.verifyClientVersion(handler_ctx, args.req)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'verifyClientVersion', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

