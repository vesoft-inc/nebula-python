#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from nebula2.fbthrift.util.Recursive import fix_spec
from nebula2.fbthrift.Thrift import *
from nebula2.fbthrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from nebula2.fbthrift import Thrift
from nebula2.fbthrift.transport import TTransport
from nebula2.fbthrift.protocol import TBinaryProtocol
from nebula2.fbthrift.protocol import TCompactProtocol
from nebula2.fbthrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from nebula2.fbthrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'NullType', 'Date', 'Time', 'DateTime', 'Value', 'NList', 'NMap', 'NSet', 'Row', 'DataSet', 'Tag', 'Vertex', 'Edge', 'Step', 'Path', 'HostAddr', 'KeyValue', 'LogInfo', 'PartitionBackupInfo', 'GraphSpaceID', 'PartitionID', 'TagID', 'EdgeType', 'EdgeRanking', 'LogID', 'TermID', 'Timestamp', 'IndexID', 'Port', 'SessionID']

class NullType:
  __NULL__ = 0
  NaN = 1
  BAD_DATA = 2
  BAD_TYPE = 3
  ERR_OVERFLOW = 4
  UNKNOWN_PROP = 5
  DIV_BY_ZERO = 6
  OUT_OF_RANGE = 7

  _VALUES_TO_NAMES = {
    0: "__NULL__",
    1: "NaN",
    2: "BAD_DATA",
    3: "BAD_TYPE",
    4: "ERR_OVERFLOW",
    5: "UNKNOWN_PROP",
    6: "DIV_BY_ZERO",
    7: "OUT_OF_RANGE",
  }

  _NAMES_TO_VALUES = {
    "__NULL__": 0,
    "NaN": 1,
    "BAD_DATA": 2,
    "BAD_TYPE": 3,
    "ERR_OVERFLOW": 4,
    "UNKNOWN_PROP": 5,
    "DIV_BY_ZERO": 6,
    "OUT_OF_RANGE": 7,
  }

class Date:
  """
  Attributes:
   - year
   - month
   - day
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Date')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Time:
  """
  Attributes:
   - hour
   - minute
   - sec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.sec = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.microsec = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Time')
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 1)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 2)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.BYTE, 3)
      oprot.writeByte(self.sec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I32, 4)
      oprot.writeI32(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.sec is not None:
      value = pprint.pformat(self.sec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DateTime:
  """
  Attributes:
   - year
   - month
   - day
   - hour
   - minute
   - sec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.sec = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.microsec = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DateTime')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 4)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 5)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.BYTE, 6)
      oprot.writeByte(self.sec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I32, 7)
      oprot.writeI32(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.sec is not None:
      value = pprint.pformat(self.sec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Value(object):
  """
  Attributes:
   - nVal
   - bVal
   - iVal
   - fVal
   - sVal
   - dVal
   - tVal
   - dtVal
   - vVal
   - eVal
   - pVal
   - lVal
   - mVal
   - uVal
   - gVal
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  NVAL = 1
  BVAL = 2
  IVAL = 3
  FVAL = 4
  SVAL = 5
  DVAL = 6
  TVAL = 7
  DTVAL = 8
  VVAL = 9
  EVAL = 10
  PVAL = 11
  LVAL = 12
  MVAL = 13
  UVAL = 14
  GVAL = 15
  
  @staticmethod
  def isUnion():
    return True

  def get_nVal(self):
    assert self.field == 1
    return self.value

  def get_bVal(self):
    assert self.field == 2
    return self.value

  def get_iVal(self):
    assert self.field == 3
    return self.value

  def get_fVal(self):
    assert self.field == 4
    return self.value

  def get_sVal(self):
    assert self.field == 5
    return self.value

  def get_dVal(self):
    assert self.field == 6
    return self.value

  def get_tVal(self):
    assert self.field == 7
    return self.value

  def get_dtVal(self):
    assert self.field == 8
    return self.value

  def get_vVal(self):
    assert self.field == 9
    return self.value

  def get_eVal(self):
    assert self.field == 10
    return self.value

  def get_pVal(self):
    assert self.field == 11
    return self.value

  def get_lVal(self):
    assert self.field == 12
    return self.value

  def get_mVal(self):
    assert self.field == 13
    return self.value

  def get_uVal(self):
    assert self.field == 14
    return self.value

  def get_gVal(self):
    assert self.field == 15
    return self.value

  def set_nVal(self, value):
    self.field = 1
    self.value = value

  def set_bVal(self, value):
    self.field = 2
    self.value = value

  def set_iVal(self, value):
    self.field = 3
    self.value = value

  def set_fVal(self, value):
    self.field = 4
    self.value = value

  def set_sVal(self, value):
    self.field = 5
    self.value = value

  def set_dVal(self, value):
    self.field = 6
    self.value = value

  def set_tVal(self, value):
    self.field = 7
    self.value = value

  def set_dtVal(self, value):
    self.field = 8
    self.value = value

  def set_vVal(self, value):
    self.field = 9
    self.value = value

  def set_eVal(self, value):
    self.field = 10
    self.value = value

  def set_pVal(self, value):
    self.field = 11
    self.value = value

  def set_lVal(self, value):
    self.field = 12
    self.value = value

  def set_mVal(self, value):
    self.field = 13
    self.value = value

  def set_uVal(self, value):
    self.field = 14
    self.value = value

  def set_gVal(self, value):
    self.field = 15
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('nVal', value)
    if self.field == 2:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bVal', value)
    if self.field == 3:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('iVal', value)
    if self.field == 4:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('fVal', value)
    if self.field == 5:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('sVal', value)
    if self.field == 6:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dVal', value)
    if self.field == 7:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tVal', value)
    if self.field == 8:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dtVal', value)
    if self.field == 9:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('vVal', value)
    if self.field == 10:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('eVal', value)
    if self.field == 11:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('pVal', value)
    if self.field == 12:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('lVal', value)
    if self.field == 13:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mVal', value)
    if self.field == 14:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('uVal', value)
    if self.field == 15:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('gVal', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          nVal = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_nVal(nVal)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          bVal = iprot.readBool()
          assert self.field == 0 and self.value is None
          self.set_bVal(bVal)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          iVal = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_iVal(iVal)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          fVal = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_fVal(fVal)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          sVal = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_sVal(sVal)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          dVal = Date()
          dVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dVal(dVal)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          tVal = Time()
          tVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_tVal(tVal)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          dtVal = DateTime()
          dtVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dtVal(dtVal)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          vVal = Vertex()
          vVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_vVal(vVal)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          eVal = Edge()
          eVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_eVal(eVal)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          pVal = Path()
          pVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_pVal(pVal)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          lVal = NList()
          lVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_lVal(lVal)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          mVal = NMap()
          mVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_mVal(mVal)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          uVal = NSet()
          uVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_uVal(uVal)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          gVal = DataSet()
          gVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_gVal(gVal)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Value')
    if self.field == 1:
      oprot.writeFieldBegin('nVal', TType.I32, 1)
      nVal = self.value
      oprot.writeI32(nVal)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('bVal', TType.BOOL, 2)
      bVal = self.value
      oprot.writeBool(bVal)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('iVal', TType.I64, 3)
      iVal = self.value
      oprot.writeI64(iVal)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('fVal', TType.DOUBLE, 4)
      fVal = self.value
      oprot.writeDouble(fVal)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('sVal', TType.STRING, 5)
      sVal = self.value
      oprot.writeString(sVal)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('dVal', TType.STRUCT, 6)
      dVal = self.value
      dVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('tVal', TType.STRUCT, 7)
      tVal = self.value
      tVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('dtVal', TType.STRUCT, 8)
      dtVal = self.value
      dtVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('vVal', TType.STRUCT, 9)
      vVal = self.value
      vVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('eVal', TType.STRUCT, 10)
      eVal = self.value
      eVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('pVal', TType.STRUCT, 11)
      pVal = self.value
      pVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 12:
      oprot.writeFieldBegin('lVal', TType.STRUCT, 12)
      lVal = self.value
      lVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 13:
      oprot.writeFieldBegin('mVal', TType.STRUCT, 13)
      mVal = self.value
      mVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 14:
      oprot.writeFieldBegin('uVal', TType.STRUCT, 14)
      uVal = self.value
      uVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 15:
      oprot.writeFieldBegin('gVal', TType.STRUCT, 15)
      gVal = self.value
      gVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NList:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = Value()
              _elem5.read(iprot)
              self.values.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = Value()
              _elem6.read(iprot)
              self.values.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NList')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter7 in self.values:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NMap:
  """
  Attributes:
   - kvs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.kvs = {}
          (_ktype9, _vtype10, _size8 ) = iprot.readMapBegin() 
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _key13 = iprot.readString()
              _val14 = Value()
              _val14.read(iprot)
              self.kvs[_key13] = _val14
          else: 
            while iprot.peekMap():
              _key15 = iprot.readString()
              _val16 = Value()
              _val16.read(iprot)
              self.kvs[_key15] = _val16
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NMap')
    if self.kvs != None:
      oprot.writeFieldBegin('kvs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.kvs))
      for kiter17,viter18 in self.kvs.items():
        oprot.writeString(kiter17)
        viter18.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.kvs is not None:
      value = pprint.pformat(self.kvs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    kvs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NSet:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.values = set()
          (_etype22, _size19) = iprot.readSetBegin()
          if _size19 >= 0:
            for _i23 in six.moves.range(_size19):
              _elem24 = Value()
              _elem24.read(iprot)
              self.values.add(_elem24)
          else: 
            while iprot.peekSet():
              _elem25 = Value()
              _elem25.read(iprot)
              self.values.add(_elem25)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NSet')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.values))
      for iter26 in self.values:
        iter26.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Row:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype30, _size27) = iprot.readListBegin()
          if _size27 >= 0:
            for _i31 in six.moves.range(_size27):
              _elem32 = Value()
              _elem32.read(iprot)
              self.values.append(_elem32)
          else: 
            while iprot.peekList():
              _elem33 = Value()
              _elem33.read(iprot)
              self.values.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Row')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter34 in self.values:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DataSet:
  """
  Attributes:
   - column_names
   - rows
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in six.moves.range(_size35):
              _elem40 = iprot.readString()
              self.column_names.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = iprot.readString()
              self.column_names.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.rows = []
          (_etype45, _size42) = iprot.readListBegin()
          if _size42 >= 0:
            for _i46 in six.moves.range(_size42):
              _elem47 = Row()
              _elem47.read(iprot)
              self.rows.append(_elem47)
          else: 
            while iprot.peekList():
              _elem48 = Row()
              _elem48.read(iprot)
              self.rows.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DataSet')
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter49 in self.column_names:
        oprot.writeString(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rows != None:
      oprot.writeFieldBegin('rows', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.rows))
      for iter50 in self.rows:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.rows is not None:
      value = pprint.pformat(self.rows, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    rows=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Tag:
  """
  Attributes:
   - name
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype52, _vtype53, _size51 ) = iprot.readMapBegin() 
          if _size51 >= 0:
            for _i55 in six.moves.range(_size51):
              _key56 = iprot.readString()
              _val57 = Value()
              _val57.read(iprot)
              self.props[_key56] = _val57
          else: 
            while iprot.peekMap():
              _key58 = iprot.readString()
              _val59 = Value()
              _val59.read(iprot)
              self.props[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Tag')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter60,viter61 in self.props.items():
        oprot.writeString(kiter60)
        viter61.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Vertex:
  """
  Attributes:
   - vid
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.vid = Value()
          self.vid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype65, _size62) = iprot.readListBegin()
          if _size62 >= 0:
            for _i66 in six.moves.range(_size62):
              _elem67 = Tag()
              _elem67.read(iprot)
              self.tags.append(_elem67)
          else: 
            while iprot.peekList():
              _elem68 = Tag()
              _elem68.read(iprot)
              self.tags.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Vertex')
    if self.vid != None:
      oprot.writeFieldBegin('vid', TType.STRUCT, 1)
      self.vid.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter69 in self.tags:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.vid is not None:
      value = pprint.pformat(self.vid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vid=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Edge:
  """
  Attributes:
   - src
   - dst
   - type
   - name
   - ranking
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Value()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dst = Value()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin() 
          if _size70 >= 0:
            for _i74 in six.moves.range(_size70):
              _key75 = iprot.readString()
              _val76 = Value()
              _val76.read(iprot)
              self.props[_key75] = _val76
          else: 
            while iprot.peekMap():
              _key77 = iprot.readString()
              _val78 = Value()
              _val78.read(iprot)
              self.props[_key77] = _val78
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Edge')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 2)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 5)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter79,viter80 in self.props.items():
        oprot.writeString(kiter79)
        viter80.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Step:
  """
  Attributes:
   - dst
   - type
   - name
   - ranking
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dst = Vertex()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype82, _vtype83, _size81 ) = iprot.readMapBegin() 
          if _size81 >= 0:
            for _i85 in six.moves.range(_size81):
              _key86 = iprot.readString()
              _val87 = Value()
              _val87.read(iprot)
              self.props[_key86] = _val87
          else: 
            while iprot.peekMap():
              _key88 = iprot.readString()
              _val89 = Value()
              _val89.read(iprot)
              self.props[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Step')
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 1)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 4)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter90,viter91 in self.props.items():
        oprot.writeString(kiter90)
        viter91.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Path:
  """
  Attributes:
   - src
   - steps
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Vertex()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.steps = []
          (_etype95, _size92) = iprot.readListBegin()
          if _size92 >= 0:
            for _i96 in six.moves.range(_size92):
              _elem97 = Step()
              _elem97.read(iprot)
              self.steps.append(_elem97)
          else: 
            while iprot.peekList():
              _elem98 = Step()
              _elem98.read(iprot)
              self.steps.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Path')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.steps != None:
      oprot.writeFieldBegin('steps', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.steps))
      for iter99 in self.steps:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.steps is not None:
      value = pprint.pformat(self.steps, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    steps=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class HostAddr:
  """
  Attributes:
   - host
   - port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostAddr')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host.encode('utf-8')) if UTF8STRINGS and not isinstance(self.host, bytes) else oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.port != None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.port is not None:
      value = pprint.pformat(self.port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    port=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KeyValue:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KeyValue')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LogInfo:
  """
  Attributes:
   - log_id
   - term_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.term_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LogInfo')
    if self.log_id != None:
      oprot.writeFieldBegin('log_id', TType.I64, 1)
      oprot.writeI64(self.log_id)
      oprot.writeFieldEnd()
    if self.term_id != None:
      oprot.writeFieldBegin('term_id', TType.I64, 2)
      oprot.writeI64(self.term_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.log_id is not None:
      value = pprint.pformat(self.log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_id=%s' % (value))
    if self.term_id is not None:
      value = pprint.pformat(self.term_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PartitionBackupInfo:
  """
  Attributes:
   - info
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.info = {}
          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin() 
          if _size100 >= 0:
            for _i104 in six.moves.range(_size100):
              _key105 = iprot.readI32()
              _val106 = LogInfo()
              _val106.read(iprot)
              self.info[_key105] = _val106
          else: 
            while iprot.peekMap():
              _key107 = iprot.readI32()
              _val108 = LogInfo()
              _val108.read(iprot)
              self.info[_key107] = _val108
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionBackupInfo')
    if self.info != None:
      oprot.writeFieldBegin('info', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.info))
      for kiter109,viter110 in self.info.items():
        oprot.writeI32(kiter109)
        viter110.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.info is not None:
      value = pprint.pformat(self.info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    info=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

GraphSpaceID = UnimplementedTypedef()
PartitionID = UnimplementedTypedef()
TagID = UnimplementedTypedef()
EdgeType = UnimplementedTypedef()
EdgeRanking = UnimplementedTypedef()
LogID = UnimplementedTypedef()
TermID = UnimplementedTypedef()
Timestamp = UnimplementedTypedef()
IndexID = UnimplementedTypedef()
Port = UnimplementedTypedef()
SessionID = UnimplementedTypedef()
all_structs.append(Date)
Date.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
)

Date.thrift_struct_annotations = {
  "cpp.type": """nebula::Date""",
}
Date.thrift_field_annotations = {
}

def Date__init__(self, year=None, month=None, day=None,):
  self.year = year
  self.month = month
  self.day = day

Date.__init__ = Date__init__

def Date__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  self.__dict__ = state

Date.__getstate__ = lambda self: self.__dict__.copy()
Date.__setstate__ = Date__setstate__

all_structs.append(Time)
Time.thrift_spec = (
  None, # 0
  (1, TType.BYTE, 'hour', None, None, 2, ), # 1
  (2, TType.BYTE, 'minute', None, None, 2, ), # 2
  (3, TType.BYTE, 'sec', None, None, 2, ), # 3
  (4, TType.I32, 'microsec', None, None, 2, ), # 4
)

Time.thrift_struct_annotations = {
  "cpp.type": """nebula::Time""",
}
Time.thrift_field_annotations = {
}

def Time__init__(self, hour=None, minute=None, sec=None, microsec=None,):
  self.hour = hour
  self.minute = minute
  self.sec = sec
  self.microsec = microsec

Time.__init__ = Time__init__

def Time__setstate__(self, state):
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('sec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

Time.__getstate__ = lambda self: self.__dict__.copy()
Time.__setstate__ = Time__setstate__

all_structs.append(DateTime)
DateTime.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
  (4, TType.BYTE, 'hour', None, None, 2, ), # 4
  (5, TType.BYTE, 'minute', None, None, 2, ), # 5
  (6, TType.BYTE, 'sec', None, None, 2, ), # 6
  (7, TType.I32, 'microsec', None, None, 2, ), # 7
)

DateTime.thrift_struct_annotations = {
  "cpp.type": """nebula::DateTime""",
}
DateTime.thrift_field_annotations = {
}

def DateTime__init__(self, year=None, month=None, day=None, hour=None, minute=None, sec=None, microsec=None,):
  self.year = year
  self.month = month
  self.day = day
  self.hour = hour
  self.minute = minute
  self.sec = sec
  self.microsec = microsec

DateTime.__init__ = DateTime__init__

def DateTime__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('sec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

DateTime.__getstate__ = lambda self: self.__dict__.copy()
DateTime.__setstate__ = DateTime__setstate__

all_structs.append(Value)
Value.thrift_spec = (
  None, # 0
  (1, TType.I32, 'nVal', NullType, None, 2, ), # 1
  (2, TType.BOOL, 'bVal', None, None, 2, ), # 2
  (3, TType.I64, 'iVal', None, None, 2, ), # 3
  (4, TType.DOUBLE, 'fVal', None, None, 2, ), # 4
  (5, TType.STRING, 'sVal', False, None, 2, ), # 5
  (6, TType.STRUCT, 'dVal', [Date, Date.thrift_spec, False], None, 2, ), # 6
  (7, TType.STRUCT, 'tVal', [Time, Time.thrift_spec, False], None, 2, ), # 7
  (8, TType.STRUCT, 'dtVal', [DateTime, DateTime.thrift_spec, False], None, 2, ), # 8
  (9, TType.STRUCT, 'vVal', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 9
  (10, TType.STRUCT, 'eVal', [Edge, Edge.thrift_spec, False], None, 2, ), # 10
  (11, TType.STRUCT, 'pVal', [Path, Path.thrift_spec, False], None, 2, ), # 11
  (12, TType.STRUCT, 'lVal', [NList, NList.thrift_spec, False], None, 2, ), # 12
  (13, TType.STRUCT, 'mVal', [NMap, NMap.thrift_spec, False], None, 2, ), # 13
  (14, TType.STRUCT, 'uVal', [NSet, NSet.thrift_spec, False], None, 2, ), # 14
  (15, TType.STRUCT, 'gVal', [DataSet, DataSet.thrift_spec, False], None, 2, ), # 15
)

Value.thrift_struct_annotations = {
  "cpp.type": """nebula::Value""",
}
Value.thrift_field_annotations = {
  9: {
    "cpp.ref_type": """unique""",
  },
  10: {
    "cpp.ref_type": """unique""",
  },
  11: {
    "cpp.ref_type": """unique""",
  },
  12: {
    "cpp.ref_type": """unique""",
  },
  13: {
    "cpp.ref_type": """unique""",
  },
  14: {
    "cpp.ref_type": """unique""",
  },
  15: {
    "cpp.ref_type": """unique""",
  },
}

def Value__init__(self, nVal=None, bVal=None, iVal=None, fVal=None, sVal=None, dVal=None, tVal=None, dtVal=None, vVal=None, eVal=None, pVal=None, lVal=None, mVal=None, uVal=None, gVal=None,):
  self.field = 0
  self.value = None
  if nVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = nVal
  if bVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = bVal
  if iVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = iVal
  if fVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = fVal
  if sVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = sVal
  if dVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = dVal
  if tVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = tVal
  if dtVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = dtVal
  if vVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = vVal
  if eVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = eVal
  if pVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = pVal
  if lVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 12
    self.value = lVal
  if mVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 13
    self.value = mVal
  if uVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 14
    self.value = uVal
  if gVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 15
    self.value = gVal

Value.__init__ = Value__init__

all_structs.append(NList)
NList.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NList.thrift_struct_annotations = {
  "cpp.type": """nebula::List""",
}
NList.thrift_field_annotations = {
}

def NList__init__(self, values=None,):
  self.values = values

NList.__init__ = NList__init__

def NList__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

NList.__getstate__ = lambda self: self.__dict__.copy()
NList.__setstate__ = NList__setstate__

all_structs.append(NMap)
NMap.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'kvs', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NMap.thrift_struct_annotations = {
  "cpp.type": """nebula::Map""",
}
NMap.thrift_field_annotations = {
}

def NMap__init__(self, kvs=None,):
  self.kvs = kvs

NMap.__init__ = NMap__init__

def NMap__setstate__(self, state):
  state.setdefault('kvs', None)
  self.__dict__ = state

NMap.__getstate__ = lambda self: self.__dict__.copy()
NMap.__setstate__ = NMap__setstate__

all_structs.append(NSet)
NSet.thrift_spec = (
  None, # 0
  (1, TType.SET, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NSet.thrift_struct_annotations = {
  "cpp.type": """nebula::Set""",
}
NSet.thrift_field_annotations = {
}

def NSet__init__(self, values=None,):
  self.values = values

NSet.__init__ = NSet__init__

def NSet__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

NSet.__getstate__ = lambda self: self.__dict__.copy()
NSet.__setstate__ = NSet__setstate__

all_structs.append(Row)
Row.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

Row.thrift_struct_annotations = {
  "cpp.type": """nebula::Row""",
}
Row.thrift_field_annotations = {
}

def Row__init__(self, values=None,):
  self.values = values

Row.__init__ = Row__init__

def Row__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

Row.__getstate__ = lambda self: self.__dict__.copy()
Row.__setstate__ = Row__setstate__

all_structs.append(DataSet)
DataSet.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 1
  (2, TType.LIST, 'rows', (TType.STRUCT,[Row, Row.thrift_spec, False]), None, 2, ), # 2
)

DataSet.thrift_struct_annotations = {
  "cpp.type": """nebula::DataSet""",
}
DataSet.thrift_field_annotations = {
}

def DataSet__init__(self, column_names=None, rows=None,):
  self.column_names = column_names
  self.rows = rows

DataSet.__init__ = DataSet__init__

def DataSet__setstate__(self, state):
  state.setdefault('column_names', None)
  state.setdefault('rows', None)
  self.__dict__ = state

DataSet.__getstate__ = lambda self: self.__dict__.copy()
DataSet.__setstate__ = DataSet__setstate__

all_structs.append(Tag)
Tag.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 2
)

Tag.thrift_struct_annotations = {
  "cpp.type": """nebula::Tag""",
}
Tag.thrift_field_annotations = {
}

def Tag__init__(self, name=None, props=None,):
  self.name = name
  self.props = props

Tag.__init__ = Tag__init__

def Tag__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('props', None)
  self.__dict__ = state

Tag.__getstate__ = lambda self: self.__dict__.copy()
Tag.__setstate__ = Tag__setstate__

all_structs.append(Vertex)
Vertex.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'vid', [Value, Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[Tag, Tag.thrift_spec, False]), None, 2, ), # 2
)

Vertex.thrift_struct_annotations = {
  "cpp.type": """nebula::Vertex""",
}
Vertex.thrift_field_annotations = {
}

def Vertex__init__(self, vid=None, tags=None,):
  self.vid = vid
  self.tags = tags

Vertex.__init__ = Vertex__init__

def Vertex__setstate__(self, state):
  state.setdefault('vid', None)
  state.setdefault('tags', None)
  self.__dict__ = state

Vertex.__getstate__ = lambda self: self.__dict__.copy()
Vertex.__setstate__ = Vertex__setstate__

all_structs.append(Edge)
Edge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [Value, Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.STRUCT, 'dst', [Value, Value.thrift_spec, True], None, 2, ), # 2
  (3, TType.I32, 'type', None, None, 2, ), # 3
  (4, TType.STRING, 'name', False, None, 2, ), # 4
  (5, TType.I64, 'ranking', None, None, 2, ), # 5
  (6, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 6
)

Edge.thrift_struct_annotations = {
  "cpp.type": """nebula::Edge""",
}
Edge.thrift_field_annotations = {
}

def Edge__init__(self, src=None, dst=None, type=None, name=None, ranking=None, props=None,):
  self.src = src
  self.dst = dst
  self.type = type
  self.name = name
  self.ranking = ranking
  self.props = props

Edge.__init__ = Edge__init__

def Edge__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('dst', None)
  state.setdefault('type', None)
  state.setdefault('name', None)
  state.setdefault('ranking', None)
  state.setdefault('props', None)
  self.__dict__ = state

Edge.__getstate__ = lambda self: self.__dict__.copy()
Edge.__setstate__ = Edge__setstate__

all_structs.append(Step)
Step.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dst', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'type', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
  (4, TType.I64, 'ranking', None, None, 2, ), # 4
  (5, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 5
)

Step.thrift_struct_annotations = {
  "cpp.type": """nebula::Step""",
}
Step.thrift_field_annotations = {
}

def Step__init__(self, dst=None, type=None, name=None, ranking=None, props=None,):
  self.dst = dst
  self.type = type
  self.name = name
  self.ranking = ranking
  self.props = props

Step.__init__ = Step__init__

def Step__setstate__(self, state):
  state.setdefault('dst', None)
  state.setdefault('type', None)
  state.setdefault('name', None)
  state.setdefault('ranking', None)
  state.setdefault('props', None)
  self.__dict__ = state

Step.__getstate__ = lambda self: self.__dict__.copy()
Step.__setstate__ = Step__setstate__

all_structs.append(Path)
Path.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'steps', (TType.STRUCT,[Step, Step.thrift_spec, False]), None, 2, ), # 2
)

Path.thrift_struct_annotations = {
  "cpp.type": """nebula::Path""",
}
Path.thrift_field_annotations = {
}

def Path__init__(self, src=None, steps=None,):
  self.src = src
  self.steps = steps

Path.__init__ = Path__init__

def Path__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('steps', None)
  self.__dict__ = state

Path.__getstate__ = lambda self: self.__dict__.copy()
Path.__setstate__ = Path__setstate__

all_structs.append(HostAddr)
HostAddr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'host', True, None, 2, ), # 1
  (2, TType.I32, 'port', None, None, 2, ), # 2
)

HostAddr.thrift_struct_annotations = {
  "cpp.type": """nebula::HostAddr""",
}
HostAddr.thrift_field_annotations = {
}

def HostAddr__init__(self, host=None, port=None,):
  self.host = host
  self.port = port

HostAddr.__init__ = HostAddr__init__

def HostAddr__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('port', None)
  self.__dict__ = state

HostAddr.__getstate__ = lambda self: self.__dict__.copy()
HostAddr.__setstate__ = HostAddr__setstate__

all_structs.append(KeyValue)
KeyValue.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'key', False, None, 2, ), # 1
  (2, TType.STRING, 'value', False, None, 2, ), # 2
)

KeyValue.thrift_struct_annotations = {
  "cpp.type": """nebula::KeyValue""",
}
KeyValue.thrift_field_annotations = {
}

def KeyValue__init__(self, key=None, value=None,):
  self.key = key
  self.value = value

KeyValue.__init__ = KeyValue__init__

def KeyValue__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('value', None)
  self.__dict__ = state

KeyValue.__getstate__ = lambda self: self.__dict__.copy()
KeyValue.__setstate__ = KeyValue__setstate__

all_structs.append(LogInfo)
LogInfo.thrift_spec = (
  None, # 0
  (1, TType.I64, 'log_id', None, None, 2, ), # 1
  (2, TType.I64, 'term_id', None, None, 2, ), # 2
)

LogInfo.thrift_struct_annotations = {
}
LogInfo.thrift_field_annotations = {
}

def LogInfo__init__(self, log_id=None, term_id=None,):
  self.log_id = log_id
  self.term_id = term_id

LogInfo.__init__ = LogInfo__init__

def LogInfo__setstate__(self, state):
  state.setdefault('log_id', None)
  state.setdefault('term_id', None)
  self.__dict__ = state

LogInfo.__getstate__ = lambda self: self.__dict__.copy()
LogInfo.__setstate__ = LogInfo__setstate__

all_structs.append(PartitionBackupInfo)
PartitionBackupInfo.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'info', (TType.I32,None,TType.STRUCT,[LogInfo, LogInfo.thrift_spec, False]), None, 2, ), # 1
)

PartitionBackupInfo.thrift_struct_annotations = {
}
PartitionBackupInfo.thrift_field_annotations = {
}

def PartitionBackupInfo__init__(self, info=None,):
  self.info = info

PartitionBackupInfo.__init__ = PartitionBackupInfo__init__

def PartitionBackupInfo__setstate__(self, state):
  state.setdefault('info', None)
  self.__dict__ = state

PartitionBackupInfo.__getstate__ = lambda self: self.__dict__.copy()
PartitionBackupInfo.__setstate__ = PartitionBackupInfo__setstate__

fix_spec(all_structs)
del all_structs
