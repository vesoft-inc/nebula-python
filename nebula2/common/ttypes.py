#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
import sys
from nebula2.fbthrift.util.Recursive import fix_spec
from nebula2.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula2.fbthrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from nebula2.fbthrift import Thrift
from nebula2.fbthrift.transport import TTransport
from nebula2.fbthrift.protocol import TBinaryProtocol
from nebula2.fbthrift.protocol import TCompactProtocol
from nebula2.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula2.fbthrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'NullType', 'ErrorCode', 'Date', 'Time', 'DateTime', 'Value', 'NList', 'NMap', 'NSet', 'Row', 'DataSet', 'Tag', 'Vertex', 'Edge', 'Step', 'Path', 'HostAddr', 'KeyValue', 'LogInfo', 'DirInfo', 'NodeInfo', 'PartitionBackupInfo', 'CheckpointInfo', 'GraphSpaceID', 'PartitionID', 'TagID', 'EdgeType', 'EdgeRanking', 'LogID', 'TermID', 'Timestamp', 'IndexID', 'Port', 'SessionID', 'ExecutionPlanID']

class NullType:
  __NULL__ = 0
  NaN = 1
  BAD_DATA = 2
  BAD_TYPE = 3
  ERR_OVERFLOW = 4
  UNKNOWN_PROP = 5
  DIV_BY_ZERO = 6
  OUT_OF_RANGE = 7

  _VALUES_TO_NAMES = {
    0: "__NULL__",
    1: "NaN",
    2: "BAD_DATA",
    3: "BAD_TYPE",
    4: "ERR_OVERFLOW",
    5: "UNKNOWN_PROP",
    6: "DIV_BY_ZERO",
    7: "OUT_OF_RANGE",
  }

  _NAMES_TO_VALUES = {
    "__NULL__": 0,
    "NaN": 1,
    "BAD_DATA": 2,
    "BAD_TYPE": 3,
    "ERR_OVERFLOW": 4,
    "UNKNOWN_PROP": 5,
    "DIV_BY_ZERO": 6,
    "OUT_OF_RANGE": 7,
  }

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAIL_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_LEADER_CHANGED = -4
  E_SPACE_NOT_FOUND = -5
  E_TAG_NOT_FOUND = -6
  E_EDGE_NOT_FOUND = -7
  E_INDEX_NOT_FOUND = -8
  E_EDGE_PROP_NOT_FOUND = -9
  E_TAG_PROP_NOT_FOUND = -10
  E_ROLE_NOT_FOUND = -11
  E_CONFIG_NOT_FOUND = -12
  E_GROUP_NOT_FOUND = -13
  E_ZONE_NOT_FOUND = -14
  E_LISTENER_NOT_FOUND = -15
  E_PART_NOT_FOUND = -16
  E_KEY_NOT_FOUND = -17
  E_USER_NOT_FOUND = -18
  E_BACKUP_FAILED = -24
  E_BACKUP_EMPTY_TABLE = -25
  E_BACKUP_TABLE_FAILED = -26
  E_PARTIAL_RESULT = -27
  E_REBUILD_INDEX_FAILED = -28
  E_INVALID_PASSWORD = -29
  E_FAILED_GET_ABS_PATH = -30
  E_BAD_USERNAME_PASSWORD = -1001
  E_SESSION_INVALID = -1002
  E_SESSION_TIMEOUT = -1003
  E_SYNTAX_ERROR = -1004
  E_EXECUTION_ERROR = -1005
  E_STATEMENT_EMPTY = -1006
  E_BAD_PERMISSION = -1008
  E_SEMANTIC_ERROR = -1009
  E_TOO_MANY_CONNECTIONS = -1010
  E_PARTIAL_SUCCEEDED = -1011
  E_NO_HOSTS = -2001
  E_EXISTED = -2002
  E_INVALID_HOST = -2003
  E_UNSUPPORTED = -2004
  E_NOT_DROP = -2005
  E_BALANCER_RUNNING = -2006
  E_CONFIG_IMMUTABLE = -2007
  E_CONFLICT = -2008
  E_INVALID_PARM = -2009
  E_WRONGCLUSTER = -2010
  E_STORE_FAILURE = -2021
  E_STORE_SEGMENT_ILLEGAL = -2022
  E_BAD_BALANCE_PLAN = -2023
  E_BALANCED = -2024
  E_NO_RUNNING_BALANCE_PLAN = -2025
  E_NO_VALID_HOST = -2026
  E_CORRUPTTED_BALANCE_PLAN = -2027
  E_NO_INVALID_BALANCE_PLAN = -2028
  E_IMPROPER_ROLE = -2030
  E_INVALID_PARTITION_NUM = -2031
  E_INVALID_REPLICA_FACTOR = -2032
  E_INVALID_CHARSET = -2033
  E_INVALID_COLLATE = -2034
  E_CHARSET_COLLATE_NOT_MATCH = -2035
  E_SNAPSHOT_FAILURE = -2040
  E_BLOCK_WRITE_FAILURE = -2041
  E_REBUILD_INDEX_FAILURE = -2042
  E_INDEX_WITH_TTL = -2043
  E_ADD_JOB_FAILURE = -2044
  E_STOP_JOB_FAILURE = -2045
  E_SAVE_JOB_FAILURE = -2046
  E_BALANCER_FAILURE = -2047
  E_JOB_NOT_FINISHED = -2048
  E_TASK_REPORT_OUT_DATE = -2049
  E_INVALID_JOB = -2065
  E_BACKUP_BUILDING_INDEX = -2066
  E_BACKUP_SPACE_NOT_FOUND = -2067
  E_RESTORE_FAILURE = -2068
  E_SESSION_NOT_FOUND = -2069
  E_LIST_CLUSTER_FAILURE = -2070
  E_LIST_CLUSTER_GET_ABS_PATH_FAILURE = -2071
  E_GET_META_DIR_FAILURE = -2072
  E_QUERY_NOT_FOUND = -2073
  E_CONSENSUS_ERROR = -3001
  E_KEY_HAS_EXISTS = -3002
  E_DATA_TYPE_MISMATCH = -3003
  E_INVALID_FIELD_VALUE = -3004
  E_INVALID_OPERATION = -3005
  E_NOT_NULLABLE = -3006
  E_FIELD_UNSET = -3007
  E_OUT_OF_RANGE = -3008
  E_ATOMIC_OP_FAILED = -3009
  E_DATA_CONFLICT_ERROR = -3010
  E_WRITE_STALLED = -3011
  E_IMPROPER_DATA_TYPE = -3021
  E_INVALID_SPACEVIDLEN = -3022
  E_INVALID_FILTER = -3031
  E_INVALID_UPDATER = -3032
  E_INVALID_STORE = -3033
  E_INVALID_PEER = -3034
  E_RETRY_EXHAUSTED = -3035
  E_TRANSFER_LEADER_FAILED = -3036
  E_INVALID_STAT_TYPE = -3037
  E_INVALID_VID = -3038
  E_NO_TRANSFORMED = -3039
  E_LOAD_META_FAILED = -3040
  E_FAILED_TO_CHECKPOINT = -3041
  E_CHECKPOINT_BLOCKED = -3042
  E_FILTER_OUT = -3043
  E_INVALID_DATA = -3044
  E_MUTATE_EDGE_CONFLICT = -3045
  E_MUTATE_TAG_CONFLICT = -3046
  E_OUTDATED_LOCK = -3047
  E_INVALID_TASK_PARA = -3051
  E_USER_CANCEL = -3052
  E_TASK_EXECUTION_FAILED = -3053
  E_UNKNOWN = -8000

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAIL_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -4: "E_LEADER_CHANGED",
    -5: "E_SPACE_NOT_FOUND",
    -6: "E_TAG_NOT_FOUND",
    -7: "E_EDGE_NOT_FOUND",
    -8: "E_INDEX_NOT_FOUND",
    -9: "E_EDGE_PROP_NOT_FOUND",
    -10: "E_TAG_PROP_NOT_FOUND",
    -11: "E_ROLE_NOT_FOUND",
    -12: "E_CONFIG_NOT_FOUND",
    -13: "E_GROUP_NOT_FOUND",
    -14: "E_ZONE_NOT_FOUND",
    -15: "E_LISTENER_NOT_FOUND",
    -16: "E_PART_NOT_FOUND",
    -17: "E_KEY_NOT_FOUND",
    -18: "E_USER_NOT_FOUND",
    -24: "E_BACKUP_FAILED",
    -25: "E_BACKUP_EMPTY_TABLE",
    -26: "E_BACKUP_TABLE_FAILED",
    -27: "E_PARTIAL_RESULT",
    -28: "E_REBUILD_INDEX_FAILED",
    -29: "E_INVALID_PASSWORD",
    -30: "E_FAILED_GET_ABS_PATH",
    -1001: "E_BAD_USERNAME_PASSWORD",
    -1002: "E_SESSION_INVALID",
    -1003: "E_SESSION_TIMEOUT",
    -1004: "E_SYNTAX_ERROR",
    -1005: "E_EXECUTION_ERROR",
    -1006: "E_STATEMENT_EMPTY",
    -1008: "E_BAD_PERMISSION",
    -1009: "E_SEMANTIC_ERROR",
    -1010: "E_TOO_MANY_CONNECTIONS",
    -1011: "E_PARTIAL_SUCCEEDED",
    -2001: "E_NO_HOSTS",
    -2002: "E_EXISTED",
    -2003: "E_INVALID_HOST",
    -2004: "E_UNSUPPORTED",
    -2005: "E_NOT_DROP",
    -2006: "E_BALANCER_RUNNING",
    -2007: "E_CONFIG_IMMUTABLE",
    -2008: "E_CONFLICT",
    -2009: "E_INVALID_PARM",
    -2010: "E_WRONGCLUSTER",
    -2021: "E_STORE_FAILURE",
    -2022: "E_STORE_SEGMENT_ILLEGAL",
    -2023: "E_BAD_BALANCE_PLAN",
    -2024: "E_BALANCED",
    -2025: "E_NO_RUNNING_BALANCE_PLAN",
    -2026: "E_NO_VALID_HOST",
    -2027: "E_CORRUPTTED_BALANCE_PLAN",
    -2028: "E_NO_INVALID_BALANCE_PLAN",
    -2030: "E_IMPROPER_ROLE",
    -2031: "E_INVALID_PARTITION_NUM",
    -2032: "E_INVALID_REPLICA_FACTOR",
    -2033: "E_INVALID_CHARSET",
    -2034: "E_INVALID_COLLATE",
    -2035: "E_CHARSET_COLLATE_NOT_MATCH",
    -2040: "E_SNAPSHOT_FAILURE",
    -2041: "E_BLOCK_WRITE_FAILURE",
    -2042: "E_REBUILD_INDEX_FAILURE",
    -2043: "E_INDEX_WITH_TTL",
    -2044: "E_ADD_JOB_FAILURE",
    -2045: "E_STOP_JOB_FAILURE",
    -2046: "E_SAVE_JOB_FAILURE",
    -2047: "E_BALANCER_FAILURE",
    -2048: "E_JOB_NOT_FINISHED",
    -2049: "E_TASK_REPORT_OUT_DATE",
    -2065: "E_INVALID_JOB",
    -2066: "E_BACKUP_BUILDING_INDEX",
    -2067: "E_BACKUP_SPACE_NOT_FOUND",
    -2068: "E_RESTORE_FAILURE",
    -2069: "E_SESSION_NOT_FOUND",
    -2070: "E_LIST_CLUSTER_FAILURE",
    -2071: "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE",
    -2072: "E_GET_META_DIR_FAILURE",
    -2073: "E_QUERY_NOT_FOUND",
    -3001: "E_CONSENSUS_ERROR",
    -3002: "E_KEY_HAS_EXISTS",
    -3003: "E_DATA_TYPE_MISMATCH",
    -3004: "E_INVALID_FIELD_VALUE",
    -3005: "E_INVALID_OPERATION",
    -3006: "E_NOT_NULLABLE",
    -3007: "E_FIELD_UNSET",
    -3008: "E_OUT_OF_RANGE",
    -3009: "E_ATOMIC_OP_FAILED",
    -3010: "E_DATA_CONFLICT_ERROR",
    -3011: "E_WRITE_STALLED",
    -3021: "E_IMPROPER_DATA_TYPE",
    -3022: "E_INVALID_SPACEVIDLEN",
    -3031: "E_INVALID_FILTER",
    -3032: "E_INVALID_UPDATER",
    -3033: "E_INVALID_STORE",
    -3034: "E_INVALID_PEER",
    -3035: "E_RETRY_EXHAUSTED",
    -3036: "E_TRANSFER_LEADER_FAILED",
    -3037: "E_INVALID_STAT_TYPE",
    -3038: "E_INVALID_VID",
    -3039: "E_NO_TRANSFORMED",
    -3040: "E_LOAD_META_FAILED",
    -3041: "E_FAILED_TO_CHECKPOINT",
    -3042: "E_CHECKPOINT_BLOCKED",
    -3043: "E_FILTER_OUT",
    -3044: "E_INVALID_DATA",
    -3045: "E_MUTATE_EDGE_CONFLICT",
    -3046: "E_MUTATE_TAG_CONFLICT",
    -3047: "E_OUTDATED_LOCK",
    -3051: "E_INVALID_TASK_PARA",
    -3052: "E_USER_CANCEL",
    -3053: "E_TASK_EXECUTION_FAILED",
    -8000: "E_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAIL_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_LEADER_CHANGED": -4,
    "E_SPACE_NOT_FOUND": -5,
    "E_TAG_NOT_FOUND": -6,
    "E_EDGE_NOT_FOUND": -7,
    "E_INDEX_NOT_FOUND": -8,
    "E_EDGE_PROP_NOT_FOUND": -9,
    "E_TAG_PROP_NOT_FOUND": -10,
    "E_ROLE_NOT_FOUND": -11,
    "E_CONFIG_NOT_FOUND": -12,
    "E_GROUP_NOT_FOUND": -13,
    "E_ZONE_NOT_FOUND": -14,
    "E_LISTENER_NOT_FOUND": -15,
    "E_PART_NOT_FOUND": -16,
    "E_KEY_NOT_FOUND": -17,
    "E_USER_NOT_FOUND": -18,
    "E_BACKUP_FAILED": -24,
    "E_BACKUP_EMPTY_TABLE": -25,
    "E_BACKUP_TABLE_FAILED": -26,
    "E_PARTIAL_RESULT": -27,
    "E_REBUILD_INDEX_FAILED": -28,
    "E_INVALID_PASSWORD": -29,
    "E_FAILED_GET_ABS_PATH": -30,
    "E_BAD_USERNAME_PASSWORD": -1001,
    "E_SESSION_INVALID": -1002,
    "E_SESSION_TIMEOUT": -1003,
    "E_SYNTAX_ERROR": -1004,
    "E_EXECUTION_ERROR": -1005,
    "E_STATEMENT_EMPTY": -1006,
    "E_BAD_PERMISSION": -1008,
    "E_SEMANTIC_ERROR": -1009,
    "E_TOO_MANY_CONNECTIONS": -1010,
    "E_PARTIAL_SUCCEEDED": -1011,
    "E_NO_HOSTS": -2001,
    "E_EXISTED": -2002,
    "E_INVALID_HOST": -2003,
    "E_UNSUPPORTED": -2004,
    "E_NOT_DROP": -2005,
    "E_BALANCER_RUNNING": -2006,
    "E_CONFIG_IMMUTABLE": -2007,
    "E_CONFLICT": -2008,
    "E_INVALID_PARM": -2009,
    "E_WRONGCLUSTER": -2010,
    "E_STORE_FAILURE": -2021,
    "E_STORE_SEGMENT_ILLEGAL": -2022,
    "E_BAD_BALANCE_PLAN": -2023,
    "E_BALANCED": -2024,
    "E_NO_RUNNING_BALANCE_PLAN": -2025,
    "E_NO_VALID_HOST": -2026,
    "E_CORRUPTTED_BALANCE_PLAN": -2027,
    "E_NO_INVALID_BALANCE_PLAN": -2028,
    "E_IMPROPER_ROLE": -2030,
    "E_INVALID_PARTITION_NUM": -2031,
    "E_INVALID_REPLICA_FACTOR": -2032,
    "E_INVALID_CHARSET": -2033,
    "E_INVALID_COLLATE": -2034,
    "E_CHARSET_COLLATE_NOT_MATCH": -2035,
    "E_SNAPSHOT_FAILURE": -2040,
    "E_BLOCK_WRITE_FAILURE": -2041,
    "E_REBUILD_INDEX_FAILURE": -2042,
    "E_INDEX_WITH_TTL": -2043,
    "E_ADD_JOB_FAILURE": -2044,
    "E_STOP_JOB_FAILURE": -2045,
    "E_SAVE_JOB_FAILURE": -2046,
    "E_BALANCER_FAILURE": -2047,
    "E_JOB_NOT_FINISHED": -2048,
    "E_TASK_REPORT_OUT_DATE": -2049,
    "E_INVALID_JOB": -2065,
    "E_BACKUP_BUILDING_INDEX": -2066,
    "E_BACKUP_SPACE_NOT_FOUND": -2067,
    "E_RESTORE_FAILURE": -2068,
    "E_SESSION_NOT_FOUND": -2069,
    "E_LIST_CLUSTER_FAILURE": -2070,
    "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE": -2071,
    "E_GET_META_DIR_FAILURE": -2072,
    "E_QUERY_NOT_FOUND": -2073,
    "E_CONSENSUS_ERROR": -3001,
    "E_KEY_HAS_EXISTS": -3002,
    "E_DATA_TYPE_MISMATCH": -3003,
    "E_INVALID_FIELD_VALUE": -3004,
    "E_INVALID_OPERATION": -3005,
    "E_NOT_NULLABLE": -3006,
    "E_FIELD_UNSET": -3007,
    "E_OUT_OF_RANGE": -3008,
    "E_ATOMIC_OP_FAILED": -3009,
    "E_DATA_CONFLICT_ERROR": -3010,
    "E_WRITE_STALLED": -3011,
    "E_IMPROPER_DATA_TYPE": -3021,
    "E_INVALID_SPACEVIDLEN": -3022,
    "E_INVALID_FILTER": -3031,
    "E_INVALID_UPDATER": -3032,
    "E_INVALID_STORE": -3033,
    "E_INVALID_PEER": -3034,
    "E_RETRY_EXHAUSTED": -3035,
    "E_TRANSFER_LEADER_FAILED": -3036,
    "E_INVALID_STAT_TYPE": -3037,
    "E_INVALID_VID": -3038,
    "E_NO_TRANSFORMED": -3039,
    "E_LOAD_META_FAILED": -3040,
    "E_FAILED_TO_CHECKPOINT": -3041,
    "E_CHECKPOINT_BLOCKED": -3042,
    "E_FILTER_OUT": -3043,
    "E_INVALID_DATA": -3044,
    "E_MUTATE_EDGE_CONFLICT": -3045,
    "E_MUTATE_TAG_CONFLICT": -3046,
    "E_OUTDATED_LOCK": -3047,
    "E_INVALID_TASK_PARA": -3051,
    "E_USER_CANCEL": -3052,
    "E_TASK_EXECUTION_FAILED": -3053,
    "E_UNKNOWN": -8000,
  }

class Date:
  """
  Attributes:
   - year
   - month
   - day
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Date')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Time:
  """
  Attributes:
   - hour
   - minute
   - sec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.sec = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.microsec = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Time')
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 1)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 2)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.BYTE, 3)
      oprot.writeByte(self.sec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I32, 4)
      oprot.writeI32(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.sec is not None:
      value = pprint.pformat(self.sec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DateTime:
  """
  Attributes:
   - year
   - month
   - day
   - hour
   - minute
   - sec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.sec = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.microsec = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DateTime')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 4)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 5)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.BYTE, 6)
      oprot.writeByte(self.sec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I32, 7)
      oprot.writeI32(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.sec is not None:
      value = pprint.pformat(self.sec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Value(object):
  """
  Attributes:
   - nVal
   - bVal
   - iVal
   - fVal
   - sVal
   - dVal
   - tVal
   - dtVal
   - vVal
   - eVal
   - pVal
   - lVal
   - mVal
   - uVal
   - gVal
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  NVAL = 1
  BVAL = 2
  IVAL = 3
  FVAL = 4
  SVAL = 5
  DVAL = 6
  TVAL = 7
  DTVAL = 8
  VVAL = 9
  EVAL = 10
  PVAL = 11
  LVAL = 12
  MVAL = 13
  UVAL = 14
  GVAL = 15
  
  @staticmethod
  def isUnion():
    return True

  def get_nVal(self):
    assert self.field == 1
    return self.value

  def get_bVal(self):
    assert self.field == 2
    return self.value

  def get_iVal(self):
    assert self.field == 3
    return self.value

  def get_fVal(self):
    assert self.field == 4
    return self.value

  def get_sVal(self):
    assert self.field == 5
    return self.value

  def get_dVal(self):
    assert self.field == 6
    return self.value

  def get_tVal(self):
    assert self.field == 7
    return self.value

  def get_dtVal(self):
    assert self.field == 8
    return self.value

  def get_vVal(self):
    assert self.field == 9
    return self.value

  def get_eVal(self):
    assert self.field == 10
    return self.value

  def get_pVal(self):
    assert self.field == 11
    return self.value

  def get_lVal(self):
    assert self.field == 12
    return self.value

  def get_mVal(self):
    assert self.field == 13
    return self.value

  def get_uVal(self):
    assert self.field == 14
    return self.value

  def get_gVal(self):
    assert self.field == 15
    return self.value

  def set_nVal(self, value):
    self.field = 1
    self.value = value

  def set_bVal(self, value):
    self.field = 2
    self.value = value

  def set_iVal(self, value):
    self.field = 3
    self.value = value

  def set_fVal(self, value):
    self.field = 4
    self.value = value

  def set_sVal(self, value):
    self.field = 5
    self.value = value

  def set_dVal(self, value):
    self.field = 6
    self.value = value

  def set_tVal(self, value):
    self.field = 7
    self.value = value

  def set_dtVal(self, value):
    self.field = 8
    self.value = value

  def set_vVal(self, value):
    self.field = 9
    self.value = value

  def set_eVal(self, value):
    self.field = 10
    self.value = value

  def set_pVal(self, value):
    self.field = 11
    self.value = value

  def set_lVal(self, value):
    self.field = 12
    self.value = value

  def set_mVal(self, value):
    self.field = 13
    self.value = value

  def set_uVal(self, value):
    self.field = 14
    self.value = value

  def set_gVal(self, value):
    self.field = 15
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('nVal', value)
    if self.field == 2:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bVal', value)
    if self.field == 3:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('iVal', value)
    if self.field == 4:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('fVal', value)
    if self.field == 5:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('sVal', value)
    if self.field == 6:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dVal', value)
    if self.field == 7:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tVal', value)
    if self.field == 8:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dtVal', value)
    if self.field == 9:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('vVal', value)
    if self.field == 10:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('eVal', value)
    if self.field == 11:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('pVal', value)
    if self.field == 12:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('lVal', value)
    if self.field == 13:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mVal', value)
    if self.field == 14:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('uVal', value)
    if self.field == 15:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('gVal', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          nVal = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_nVal(nVal)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          bVal = iprot.readBool()
          assert self.field == 0 and self.value is None
          self.set_bVal(bVal)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          iVal = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_iVal(iVal)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          fVal = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_fVal(fVal)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          sVal = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_sVal(sVal)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          dVal = Date()
          dVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dVal(dVal)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          tVal = Time()
          tVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_tVal(tVal)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          dtVal = DateTime()
          dtVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dtVal(dtVal)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          vVal = Vertex()
          vVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_vVal(vVal)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          eVal = Edge()
          eVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_eVal(eVal)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          pVal = Path()
          pVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_pVal(pVal)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          lVal = NList()
          lVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_lVal(lVal)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          mVal = NMap()
          mVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_mVal(mVal)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          uVal = NSet()
          uVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_uVal(uVal)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          gVal = DataSet()
          gVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_gVal(gVal)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Value')
    if self.field == 1:
      oprot.writeFieldBegin('nVal', TType.I32, 1)
      nVal = self.value
      oprot.writeI32(nVal)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('bVal', TType.BOOL, 2)
      bVal = self.value
      oprot.writeBool(bVal)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('iVal', TType.I64, 3)
      iVal = self.value
      oprot.writeI64(iVal)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('fVal', TType.DOUBLE, 4)
      fVal = self.value
      oprot.writeDouble(fVal)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('sVal', TType.STRING, 5)
      sVal = self.value
      oprot.writeString(sVal)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('dVal', TType.STRUCT, 6)
      dVal = self.value
      dVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('tVal', TType.STRUCT, 7)
      tVal = self.value
      tVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('dtVal', TType.STRUCT, 8)
      dtVal = self.value
      dtVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('vVal', TType.STRUCT, 9)
      vVal = self.value
      vVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('eVal', TType.STRUCT, 10)
      eVal = self.value
      eVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('pVal', TType.STRUCT, 11)
      pVal = self.value
      pVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 12:
      oprot.writeFieldBegin('lVal', TType.STRUCT, 12)
      lVal = self.value
      lVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 13:
      oprot.writeFieldBegin('mVal', TType.STRUCT, 13)
      mVal = self.value
      mVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 14:
      oprot.writeFieldBegin('uVal', TType.STRUCT, 14)
      uVal = self.value
      uVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 15:
      oprot.writeFieldBegin('gVal', TType.STRUCT, 15)
      gVal = self.value
      gVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NList:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = Value()
              _elem5.read(iprot)
              self.values.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = Value()
              _elem6.read(iprot)
              self.values.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NList')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter7 in self.values:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NMap:
  """
  Attributes:
   - kvs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.kvs = {}
          (_ktype9, _vtype10, _size8 ) = iprot.readMapBegin() 
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _key13 = iprot.readString()
              _val14 = Value()
              _val14.read(iprot)
              self.kvs[_key13] = _val14
          else: 
            while iprot.peekMap():
              _key15 = iprot.readString()
              _val16 = Value()
              _val16.read(iprot)
              self.kvs[_key15] = _val16
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NMap')
    if self.kvs != None:
      oprot.writeFieldBegin('kvs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.kvs))
      for kiter17,viter18 in self.kvs.items():
        oprot.writeString(kiter17)
        viter18.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.kvs is not None:
      value = pprint.pformat(self.kvs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    kvs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NSet:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.values = set()
          (_etype22, _size19) = iprot.readSetBegin()
          if _size19 >= 0:
            for _i23 in six.moves.range(_size19):
              _elem24 = Value()
              _elem24.read(iprot)
              self.values.add(_elem24)
          else: 
            while iprot.peekSet():
              _elem25 = Value()
              _elem25.read(iprot)
              self.values.add(_elem25)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NSet')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.values))
      for iter26 in self.values:
        iter26.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Row:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype30, _size27) = iprot.readListBegin()
          if _size27 >= 0:
            for _i31 in six.moves.range(_size27):
              _elem32 = Value()
              _elem32.read(iprot)
              self.values.append(_elem32)
          else: 
            while iprot.peekList():
              _elem33 = Value()
              _elem33.read(iprot)
              self.values.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Row')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter34 in self.values:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DataSet:
  """
  Attributes:
   - column_names
   - rows
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in six.moves.range(_size35):
              _elem40 = iprot.readString()
              self.column_names.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = iprot.readString()
              self.column_names.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.rows = []
          (_etype45, _size42) = iprot.readListBegin()
          if _size42 >= 0:
            for _i46 in six.moves.range(_size42):
              _elem47 = Row()
              _elem47.read(iprot)
              self.rows.append(_elem47)
          else: 
            while iprot.peekList():
              _elem48 = Row()
              _elem48.read(iprot)
              self.rows.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DataSet')
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter49 in self.column_names:
        oprot.writeString(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rows != None:
      oprot.writeFieldBegin('rows', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.rows))
      for iter50 in self.rows:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.rows is not None:
      value = pprint.pformat(self.rows, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    rows=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Tag:
  """
  Attributes:
   - name
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype52, _vtype53, _size51 ) = iprot.readMapBegin() 
          if _size51 >= 0:
            for _i55 in six.moves.range(_size51):
              _key56 = iprot.readString()
              _val57 = Value()
              _val57.read(iprot)
              self.props[_key56] = _val57
          else: 
            while iprot.peekMap():
              _key58 = iprot.readString()
              _val59 = Value()
              _val59.read(iprot)
              self.props[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Tag')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter60,viter61 in self.props.items():
        oprot.writeString(kiter60)
        viter61.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Vertex:
  """
  Attributes:
   - vid
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.vid = Value()
          self.vid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype65, _size62) = iprot.readListBegin()
          if _size62 >= 0:
            for _i66 in six.moves.range(_size62):
              _elem67 = Tag()
              _elem67.read(iprot)
              self.tags.append(_elem67)
          else: 
            while iprot.peekList():
              _elem68 = Tag()
              _elem68.read(iprot)
              self.tags.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Vertex')
    if self.vid != None:
      oprot.writeFieldBegin('vid', TType.STRUCT, 1)
      self.vid.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter69 in self.tags:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.vid is not None:
      value = pprint.pformat(self.vid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vid=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Edge:
  """
  Attributes:
   - src
   - dst
   - type
   - name
   - ranking
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Value()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dst = Value()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin() 
          if _size70 >= 0:
            for _i74 in six.moves.range(_size70):
              _key75 = iprot.readString()
              _val76 = Value()
              _val76.read(iprot)
              self.props[_key75] = _val76
          else: 
            while iprot.peekMap():
              _key77 = iprot.readString()
              _val78 = Value()
              _val78.read(iprot)
              self.props[_key77] = _val78
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Edge')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 2)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 5)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter79,viter80 in self.props.items():
        oprot.writeString(kiter79)
        viter80.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Step:
  """
  Attributes:
   - dst
   - type
   - name
   - ranking
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dst = Vertex()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype82, _vtype83, _size81 ) = iprot.readMapBegin() 
          if _size81 >= 0:
            for _i85 in six.moves.range(_size81):
              _key86 = iprot.readString()
              _val87 = Value()
              _val87.read(iprot)
              self.props[_key86] = _val87
          else: 
            while iprot.peekMap():
              _key88 = iprot.readString()
              _val89 = Value()
              _val89.read(iprot)
              self.props[_key88] = _val89
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Step')
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 1)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 4)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter90,viter91 in self.props.items():
        oprot.writeString(kiter90)
        viter91.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Path:
  """
  Attributes:
   - src
   - steps
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Vertex()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.steps = []
          (_etype95, _size92) = iprot.readListBegin()
          if _size92 >= 0:
            for _i96 in six.moves.range(_size92):
              _elem97 = Step()
              _elem97.read(iprot)
              self.steps.append(_elem97)
          else: 
            while iprot.peekList():
              _elem98 = Step()
              _elem98.read(iprot)
              self.steps.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Path')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.steps != None:
      oprot.writeFieldBegin('steps', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.steps))
      for iter99 in self.steps:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.steps is not None:
      value = pprint.pformat(self.steps, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    steps=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class HostAddr:
  """
  Attributes:
   - host
   - port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostAddr')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host.encode('utf-8')) if UTF8STRINGS and not isinstance(self.host, bytes) else oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.port != None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.port is not None:
      value = pprint.pformat(self.port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    port=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KeyValue:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KeyValue')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LogInfo:
  """
  Attributes:
   - log_id
   - term_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.term_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LogInfo')
    if self.log_id != None:
      oprot.writeFieldBegin('log_id', TType.I64, 1)
      oprot.writeI64(self.log_id)
      oprot.writeFieldEnd()
    if self.term_id != None:
      oprot.writeFieldBegin('term_id', TType.I64, 2)
      oprot.writeI64(self.term_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.log_id is not None:
      value = pprint.pformat(self.log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_id=%s' % (value))
    if self.term_id is not None:
      value = pprint.pformat(self.term_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DirInfo:
  """
  Attributes:
   - root
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.root = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.data = []
          (_etype103, _size100) = iprot.readListBegin()
          if _size100 >= 0:
            for _i104 in six.moves.range(_size100):
              _elem105 = iprot.readString()
              self.data.append(_elem105)
          else: 
            while iprot.peekList():
              _elem106 = iprot.readString()
              self.data.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DirInfo')
    if self.root != None:
      oprot.writeFieldBegin('root', TType.STRING, 1)
      oprot.writeString(self.root)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.data))
      for iter107 in self.data:
        oprot.writeString(iter107)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.root is not None:
      value = pprint.pformat(self.root, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    root=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NodeInfo:
  """
  Attributes:
   - host
   - dir
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host = HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dir = DirInfo()
          self.dir.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NodeInfo')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 1)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.dir != None:
      oprot.writeFieldBegin('dir', TType.STRUCT, 2)
      self.dir.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.dir is not None:
      value = pprint.pformat(self.dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dir=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PartitionBackupInfo:
  """
  Attributes:
   - info
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.info = {}
          (_ktype109, _vtype110, _size108 ) = iprot.readMapBegin() 
          if _size108 >= 0:
            for _i112 in six.moves.range(_size108):
              _key113 = iprot.readI32()
              _val114 = LogInfo()
              _val114.read(iprot)
              self.info[_key113] = _val114
          else: 
            while iprot.peekMap():
              _key115 = iprot.readI32()
              _val116 = LogInfo()
              _val116.read(iprot)
              self.info[_key115] = _val116
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionBackupInfo')
    if self.info != None:
      oprot.writeFieldBegin('info', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.info))
      for kiter117,viter118 in self.info.items():
        oprot.writeI32(kiter117)
        viter118.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.info is not None:
      value = pprint.pformat(self.info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    info=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CheckpointInfo:
  """
  Attributes:
   - partition_info
   - path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.partition_info = PartitionBackupInfo()
          self.partition_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.path = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckpointInfo')
    if self.partition_info != None:
      oprot.writeFieldBegin('partition_info', TType.STRUCT, 1)
      self.partition_info.write(oprot)
      oprot.writeFieldEnd()
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 2)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.partition_info is not None:
      value = pprint.pformat(self.partition_info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    partition_info=%s' % (value))
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

GraphSpaceID = UnimplementedTypedef()
PartitionID = UnimplementedTypedef()
TagID = UnimplementedTypedef()
EdgeType = UnimplementedTypedef()
EdgeRanking = UnimplementedTypedef()
LogID = UnimplementedTypedef()
TermID = UnimplementedTypedef()
Timestamp = UnimplementedTypedef()
IndexID = UnimplementedTypedef()
Port = UnimplementedTypedef()
SessionID = UnimplementedTypedef()
ExecutionPlanID = UnimplementedTypedef()
all_structs.append(Date)
Date.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
)

Date.thrift_struct_annotations = {
  "cpp.type": "nebula::Date",
}
Date.thrift_field_annotations = {
}

def Date__init__(self, year=None, month=None, day=None,):
  self.year = year
  self.month = month
  self.day = day

Date.__init__ = Date__init__

def Date__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  self.__dict__ = state

Date.__getstate__ = lambda self: self.__dict__.copy()
Date.__setstate__ = Date__setstate__

all_structs.append(Time)
Time.thrift_spec = (
  None, # 0
  (1, TType.BYTE, 'hour', None, None, 2, ), # 1
  (2, TType.BYTE, 'minute', None, None, 2, ), # 2
  (3, TType.BYTE, 'sec', None, None, 2, ), # 3
  (4, TType.I32, 'microsec', None, None, 2, ), # 4
)

Time.thrift_struct_annotations = {
  "cpp.type": "nebula::Time",
}
Time.thrift_field_annotations = {
}

def Time__init__(self, hour=None, minute=None, sec=None, microsec=None,):
  self.hour = hour
  self.minute = minute
  self.sec = sec
  self.microsec = microsec

Time.__init__ = Time__init__

def Time__setstate__(self, state):
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('sec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

Time.__getstate__ = lambda self: self.__dict__.copy()
Time.__setstate__ = Time__setstate__

all_structs.append(DateTime)
DateTime.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
  (4, TType.BYTE, 'hour', None, None, 2, ), # 4
  (5, TType.BYTE, 'minute', None, None, 2, ), # 5
  (6, TType.BYTE, 'sec', None, None, 2, ), # 6
  (7, TType.I32, 'microsec', None, None, 2, ), # 7
)

DateTime.thrift_struct_annotations = {
  "cpp.type": "nebula::DateTime",
}
DateTime.thrift_field_annotations = {
}

def DateTime__init__(self, year=None, month=None, day=None, hour=None, minute=None, sec=None, microsec=None,):
  self.year = year
  self.month = month
  self.day = day
  self.hour = hour
  self.minute = minute
  self.sec = sec
  self.microsec = microsec

DateTime.__init__ = DateTime__init__

def DateTime__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('sec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

DateTime.__getstate__ = lambda self: self.__dict__.copy()
DateTime.__setstate__ = DateTime__setstate__

all_structs.append(Value)
Value.thrift_spec = (
  None, # 0
  (1, TType.I32, 'nVal', NullType, None, 2, ), # 1
  (2, TType.BOOL, 'bVal', None, None, 2, ), # 2
  (3, TType.I64, 'iVal', None, None, 2, ), # 3
  (4, TType.DOUBLE, 'fVal', None, None, 2, ), # 4
  (5, TType.STRING, 'sVal', False, None, 2, ), # 5
  (6, TType.STRUCT, 'dVal', [Date, Date.thrift_spec, False], None, 2, ), # 6
  (7, TType.STRUCT, 'tVal', [Time, Time.thrift_spec, False], None, 2, ), # 7
  (8, TType.STRUCT, 'dtVal', [DateTime, DateTime.thrift_spec, False], None, 2, ), # 8
  (9, TType.STRUCT, 'vVal', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 9
  (10, TType.STRUCT, 'eVal', [Edge, Edge.thrift_spec, False], None, 2, ), # 10
  (11, TType.STRUCT, 'pVal', [Path, Path.thrift_spec, False], None, 2, ), # 11
  (12, TType.STRUCT, 'lVal', [NList, NList.thrift_spec, False], None, 2, ), # 12
  (13, TType.STRUCT, 'mVal', [NMap, NMap.thrift_spec, False], None, 2, ), # 13
  (14, TType.STRUCT, 'uVal', [NSet, NSet.thrift_spec, False], None, 2, ), # 14
  (15, TType.STRUCT, 'gVal', [DataSet, DataSet.thrift_spec, False], None, 2, ), # 15
)

Value.thrift_struct_annotations = {
  "cpp.type": "nebula::Value",
}
Value.thrift_field_annotations = {
  9: {
    "cpp.ref_type": "unique",
  },
  10: {
    "cpp.ref_type": "unique",
  },
  11: {
    "cpp.ref_type": "unique",
  },
  12: {
    "cpp.ref_type": "unique",
  },
  13: {
    "cpp.ref_type": "unique",
  },
  14: {
    "cpp.ref_type": "unique",
  },
  15: {
    "cpp.ref_type": "unique",
  },
}

def Value__init__(self, nVal=None, bVal=None, iVal=None, fVal=None, sVal=None, dVal=None, tVal=None, dtVal=None, vVal=None, eVal=None, pVal=None, lVal=None, mVal=None, uVal=None, gVal=None,):
  self.field = 0
  self.value = None
  if nVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = nVal
  if bVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = bVal
  if iVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = iVal
  if fVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = fVal
  if sVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = sVal
  if dVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = dVal
  if tVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = tVal
  if dtVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = dtVal
  if vVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = vVal
  if eVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = eVal
  if pVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = pVal
  if lVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 12
    self.value = lVal
  if mVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 13
    self.value = mVal
  if uVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 14
    self.value = uVal
  if gVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 15
    self.value = gVal

Value.__init__ = Value__init__

all_structs.append(NList)
NList.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NList.thrift_struct_annotations = {
  "cpp.type": "nebula::List",
}
NList.thrift_field_annotations = {
}

def NList__init__(self, values=None,):
  self.values = values

NList.__init__ = NList__init__

def NList__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

NList.__getstate__ = lambda self: self.__dict__.copy()
NList.__setstate__ = NList__setstate__

all_structs.append(NMap)
NMap.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'kvs', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NMap.thrift_struct_annotations = {
  "cpp.type": "nebula::Map",
}
NMap.thrift_field_annotations = {
}

def NMap__init__(self, kvs=None,):
  self.kvs = kvs

NMap.__init__ = NMap__init__

def NMap__setstate__(self, state):
  state.setdefault('kvs', None)
  self.__dict__ = state

NMap.__getstate__ = lambda self: self.__dict__.copy()
NMap.__setstate__ = NMap__setstate__

all_structs.append(NSet)
NSet.thrift_spec = (
  None, # 0
  (1, TType.SET, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NSet.thrift_struct_annotations = {
  "cpp.type": "nebula::Set",
}
NSet.thrift_field_annotations = {
}

def NSet__init__(self, values=None,):
  self.values = values

NSet.__init__ = NSet__init__

def NSet__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

NSet.__getstate__ = lambda self: self.__dict__.copy()
NSet.__setstate__ = NSet__setstate__

all_structs.append(Row)
Row.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

Row.thrift_struct_annotations = {
  "cpp.type": "nebula::Row",
}
Row.thrift_field_annotations = {
}

def Row__init__(self, values=None,):
  self.values = values

Row.__init__ = Row__init__

def Row__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

Row.__getstate__ = lambda self: self.__dict__.copy()
Row.__setstate__ = Row__setstate__

all_structs.append(DataSet)
DataSet.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 1
  (2, TType.LIST, 'rows', (TType.STRUCT,[Row, Row.thrift_spec, False]), None, 2, ), # 2
)

DataSet.thrift_struct_annotations = {
  "cpp.type": "nebula::DataSet",
}
DataSet.thrift_field_annotations = {
}

def DataSet__init__(self, column_names=None, rows=None,):
  self.column_names = column_names
  self.rows = rows

DataSet.__init__ = DataSet__init__

def DataSet__setstate__(self, state):
  state.setdefault('column_names', None)
  state.setdefault('rows', None)
  self.__dict__ = state

DataSet.__getstate__ = lambda self: self.__dict__.copy()
DataSet.__setstate__ = DataSet__setstate__

all_structs.append(Tag)
Tag.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 2
)

Tag.thrift_struct_annotations = {
  "cpp.type": "nebula::Tag",
}
Tag.thrift_field_annotations = {
}

def Tag__init__(self, name=None, props=None,):
  self.name = name
  self.props = props

Tag.__init__ = Tag__init__

def Tag__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('props', None)
  self.__dict__ = state

Tag.__getstate__ = lambda self: self.__dict__.copy()
Tag.__setstate__ = Tag__setstate__

all_structs.append(Vertex)
Vertex.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'vid', [Value, Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[Tag, Tag.thrift_spec, False]), None, 2, ), # 2
)

Vertex.thrift_struct_annotations = {
  "cpp.type": "nebula::Vertex",
}
Vertex.thrift_field_annotations = {
}

def Vertex__init__(self, vid=None, tags=None,):
  self.vid = vid
  self.tags = tags

Vertex.__init__ = Vertex__init__

def Vertex__setstate__(self, state):
  state.setdefault('vid', None)
  state.setdefault('tags', None)
  self.__dict__ = state

Vertex.__getstate__ = lambda self: self.__dict__.copy()
Vertex.__setstate__ = Vertex__setstate__

all_structs.append(Edge)
Edge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [Value, Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.STRUCT, 'dst', [Value, Value.thrift_spec, True], None, 2, ), # 2
  (3, TType.I32, 'type', None, None, 2, ), # 3
  (4, TType.STRING, 'name', False, None, 2, ), # 4
  (5, TType.I64, 'ranking', None, None, 2, ), # 5
  (6, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 6
)

Edge.thrift_struct_annotations = {
  "cpp.type": "nebula::Edge",
}
Edge.thrift_field_annotations = {
}

def Edge__init__(self, src=None, dst=None, type=None, name=None, ranking=None, props=None,):
  self.src = src
  self.dst = dst
  self.type = type
  self.name = name
  self.ranking = ranking
  self.props = props

Edge.__init__ = Edge__init__

def Edge__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('dst', None)
  state.setdefault('type', None)
  state.setdefault('name', None)
  state.setdefault('ranking', None)
  state.setdefault('props', None)
  self.__dict__ = state

Edge.__getstate__ = lambda self: self.__dict__.copy()
Edge.__setstate__ = Edge__setstate__

all_structs.append(Step)
Step.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dst', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'type', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
  (4, TType.I64, 'ranking', None, None, 2, ), # 4
  (5, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 5
)

Step.thrift_struct_annotations = {
  "cpp.type": "nebula::Step",
}
Step.thrift_field_annotations = {
}

def Step__init__(self, dst=None, type=None, name=None, ranking=None, props=None,):
  self.dst = dst
  self.type = type
  self.name = name
  self.ranking = ranking
  self.props = props

Step.__init__ = Step__init__

def Step__setstate__(self, state):
  state.setdefault('dst', None)
  state.setdefault('type', None)
  state.setdefault('name', None)
  state.setdefault('ranking', None)
  state.setdefault('props', None)
  self.__dict__ = state

Step.__getstate__ = lambda self: self.__dict__.copy()
Step.__setstate__ = Step__setstate__

all_structs.append(Path)
Path.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'steps', (TType.STRUCT,[Step, Step.thrift_spec, False]), None, 2, ), # 2
)

Path.thrift_struct_annotations = {
  "cpp.type": "nebula::Path",
}
Path.thrift_field_annotations = {
}

def Path__init__(self, src=None, steps=None,):
  self.src = src
  self.steps = steps

Path.__init__ = Path__init__

def Path__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('steps', None)
  self.__dict__ = state

Path.__getstate__ = lambda self: self.__dict__.copy()
Path.__setstate__ = Path__setstate__

all_structs.append(HostAddr)
HostAddr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'host', True, None, 2, ), # 1
  (2, TType.I32, 'port', None, None, 2, ), # 2
)

HostAddr.thrift_struct_annotations = {
  "cpp.type": "nebula::HostAddr",
}
HostAddr.thrift_field_annotations = {
}

def HostAddr__init__(self, host=None, port=None,):
  self.host = host
  self.port = port

HostAddr.__init__ = HostAddr__init__

def HostAddr__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('port', None)
  self.__dict__ = state

HostAddr.__getstate__ = lambda self: self.__dict__.copy()
HostAddr.__setstate__ = HostAddr__setstate__

all_structs.append(KeyValue)
KeyValue.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'key', False, None, 2, ), # 1
  (2, TType.STRING, 'value', False, None, 2, ), # 2
)

KeyValue.thrift_struct_annotations = {
  "cpp.type": "nebula::KeyValue",
}
KeyValue.thrift_field_annotations = {
}

def KeyValue__init__(self, key=None, value=None,):
  self.key = key
  self.value = value

KeyValue.__init__ = KeyValue__init__

def KeyValue__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('value', None)
  self.__dict__ = state

KeyValue.__getstate__ = lambda self: self.__dict__.copy()
KeyValue.__setstate__ = KeyValue__setstate__

all_structs.append(LogInfo)
LogInfo.thrift_spec = (
  None, # 0
  (1, TType.I64, 'log_id', None, None, 2, ), # 1
  (2, TType.I64, 'term_id', None, None, 2, ), # 2
)

LogInfo.thrift_struct_annotations = {
}
LogInfo.thrift_field_annotations = {
}

def LogInfo__init__(self, log_id=None, term_id=None,):
  self.log_id = log_id
  self.term_id = term_id

LogInfo.__init__ = LogInfo__init__

def LogInfo__setstate__(self, state):
  state.setdefault('log_id', None)
  state.setdefault('term_id', None)
  self.__dict__ = state

LogInfo.__getstate__ = lambda self: self.__dict__.copy()
LogInfo.__setstate__ = LogInfo__setstate__

all_structs.append(DirInfo)
DirInfo.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'root', False, None, 2, ), # 1
  (2, TType.LIST, 'data', (TType.STRING,False), None, 2, ), # 2
)

DirInfo.thrift_struct_annotations = {
}
DirInfo.thrift_field_annotations = {
}

def DirInfo__init__(self, root=None, data=None,):
  self.root = root
  self.data = data

DirInfo.__init__ = DirInfo__init__

def DirInfo__setstate__(self, state):
  state.setdefault('root', None)
  state.setdefault('data', None)
  self.__dict__ = state

DirInfo.__getstate__ = lambda self: self.__dict__.copy()
DirInfo.__setstate__ = DirInfo__setstate__

all_structs.append(NodeInfo)
NodeInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'host', [HostAddr, HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'dir', [DirInfo, DirInfo.thrift_spec, False], None, 2, ), # 2
)

NodeInfo.thrift_struct_annotations = {
}
NodeInfo.thrift_field_annotations = {
}

def NodeInfo__init__(self, host=None, dir=None,):
  self.host = host
  self.dir = dir

NodeInfo.__init__ = NodeInfo__init__

def NodeInfo__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('dir', None)
  self.__dict__ = state

NodeInfo.__getstate__ = lambda self: self.__dict__.copy()
NodeInfo.__setstate__ = NodeInfo__setstate__

all_structs.append(PartitionBackupInfo)
PartitionBackupInfo.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'info', (TType.I32,None,TType.STRUCT,[LogInfo, LogInfo.thrift_spec, False]), None, 2, ), # 1
)

PartitionBackupInfo.thrift_struct_annotations = {
}
PartitionBackupInfo.thrift_field_annotations = {
}

def PartitionBackupInfo__init__(self, info=None,):
  self.info = info

PartitionBackupInfo.__init__ = PartitionBackupInfo__init__

def PartitionBackupInfo__setstate__(self, state):
  state.setdefault('info', None)
  self.__dict__ = state

PartitionBackupInfo.__getstate__ = lambda self: self.__dict__.copy()
PartitionBackupInfo.__setstate__ = PartitionBackupInfo__setstate__

all_structs.append(CheckpointInfo)
CheckpointInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'partition_info', [PartitionBackupInfo, PartitionBackupInfo.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'path', False, None, 2, ), # 2
)

CheckpointInfo.thrift_struct_annotations = {
}
CheckpointInfo.thrift_field_annotations = {
}

def CheckpointInfo__init__(self, partition_info=None, path=None,):
  self.partition_info = partition_info
  self.path = path

CheckpointInfo.__init__ = CheckpointInfo__init__

def CheckpointInfo__setstate__(self, state):
  state.setdefault('partition_info', None)
  state.setdefault('path', None)
  self.__dict__ = state

CheckpointInfo.__getstate__ = lambda self: self.__dict__.copy()
CheckpointInfo.__setstate__ = CheckpointInfo__setstate__

fix_spec(all_structs)
del all_structs
