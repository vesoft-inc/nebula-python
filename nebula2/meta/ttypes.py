#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from nebula2.fbthrift.util.Recursive import fix_spec
from nebula2.fbthrift.Thrift import *
from nebula2.fbthrift.protocol.TProtocol import TProtocolException


import nebula2.common.ttypes


import pprint
import warnings
from nebula2.fbthrift import Thrift
from nebula2.fbthrift.transport import TTransport
from nebula2.fbthrift.protocol import TBinaryProtocol
from nebula2.fbthrift.protocol import TCompactProtocol
from nebula2.fbthrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from nebula2.fbthrift.protocol import fastproto
  except:
    pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ErrorCode', 'AlterSchemaOp', 'RoleType', 'PropertyType', 'IsolationLevel', 'HostStatus', 'SnapshotStatus', 'AdminJobOp', 'AdminCmd', 'JobStatus', 'ListHostType', 'HostRole', 'TaskResult', 'ConfigModule', 'ConfigMode', 'ListenerType', 'FTServiceType', 'ID', 'ColumnTypeDef', 'ColumnDef', 'SchemaProp', 'Schema', 'IdName', 'SpaceDesc', 'SpaceItem', 'TagItem', 'AlterSchemaItem', 'EdgeItem', 'SchemaID', 'IndexItem', 'HostItem', 'UserItem', 'RoleItem', 'ExecResp', 'AdminJobReq', 'JobDesc', 'TaskDesc', 'AdminJobResult', 'AdminJobResp', 'Correlativity', 'StatisItem', 'CreateSpaceReq', 'DropSpaceReq', 'ListSpacesReq', 'ListSpacesResp', 'GetSpaceReq', 'GetSpaceResp', 'CreateTagReq', 'AlterTagReq', 'DropTagReq', 'ListTagsReq', 'ListTagsResp', 'GetTagReq', 'GetTagResp', 'CreateEdgeReq', 'AlterEdgeReq', 'GetEdgeReq', 'GetEdgeResp', 'DropEdgeReq', 'ListEdgesReq', 'ListEdgesResp', 'ListHostsReq', 'ListHostsResp', 'PartItem', 'ListPartsReq', 'ListPartsResp', 'GetPartsAllocReq', 'GetPartsAllocResp', 'MultiPutReq', 'GetReq', 'GetResp', 'MultiGetReq', 'MultiGetResp', 'RemoveReq', 'RemoveRangeReq', 'ScanReq', 'ScanResp', 'HBResp', 'HBReq', 'IndexFieldDef', 'CreateTagIndexReq', 'DropTagIndexReq', 'GetTagIndexReq', 'GetTagIndexResp', 'ListTagIndexesReq', 'ListTagIndexesResp', 'CreateEdgeIndexReq', 'DropEdgeIndexReq', 'GetEdgeIndexReq', 'GetEdgeIndexResp', 'ListEdgeIndexesReq', 'ListEdgeIndexesResp', 'RebuildIndexReq', 'CreateUserReq', 'DropUserReq', 'AlterUserReq', 'GrantRoleReq', 'RevokeRoleReq', 'ListUsersReq', 'ListUsersResp', 'ListRolesReq', 'ListRolesResp', 'GetUserRolesReq', 'ChangePasswordReq', 'BalanceReq', 'BalanceTask', 'BalanceResp', 'LeaderBalanceReq', 'ConfigItem', 'RegConfigReq', 'GetConfigReq', 'GetConfigResp', 'SetConfigReq', 'ListConfigsReq', 'ListConfigsResp', 'CreateSnapshotReq', 'DropSnapshotReq', 'ListSnapshotsReq', 'Snapshot', 'ListSnapshotsResp', 'ListIndexStatusReq', 'IndexStatus', 'ListIndexStatusResp', 'AddZoneReq', 'DropZoneReq', 'AddHostIntoZoneReq', 'DropHostFromZoneReq', 'GetZoneReq', 'GetZoneResp', 'ListZonesReq', 'Zone', 'ListZonesResp', 'AddGroupReq', 'DropGroupReq', 'AddZoneIntoGroupReq', 'DropZoneFromGroupReq', 'GetGroupReq', 'GetGroupResp', 'ListGroupsReq', 'Group', 'ListGroupsResp', 'AddListenerReq', 'RemoveListenerReq', 'ListListenerReq', 'ListenerInfo', 'ListListenerResp', 'GetStatisReq', 'GetStatisResp', 'CheckpointInfo', 'SpaceBackupInfo', 'BackupMeta', 'CreateBackupReq', 'CreateBackupResp', 'HostPair', 'RestoreMetaReq', 'FTClient', 'SignInFTServiceReq', 'SignOutFTServiceReq', 'ListFTClientsReq', 'ListFTClientsResp', 'Session', 'CreateSessionReq', 'CreateSessionResp', 'UpdateSessionsReq', 'ListSessionsReq', 'ListSessionsResp', 'GetSessionReq', 'GetSessionResp', 'RemoveSessionReq', 'ReportTaskReq', 'SchemaVer', 'ClusterID']

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAIL_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_LEADER_CHANGED = -11
  E_NO_HOSTS = -21
  E_EXISTED = -22
  E_NOT_FOUND = -23
  E_INVALID_HOST = -24
  E_UNSUPPORTED = -25
  E_NOT_DROP = -26
  E_BALANCER_RUNNING = -27
  E_CONFIG_IMMUTABLE = -28
  E_CONFLICT = -29
  E_INVALID_PARM = -30
  E_WRONGCLUSTER = -31
  E_STORE_FAILURE = -32
  E_STORE_SEGMENT_ILLEGAL = -33
  E_BAD_BALANCE_PLAN = -34
  E_BALANCED = -35
  E_NO_RUNNING_BALANCE_PLAN = -36
  E_NO_VALID_HOST = -37
  E_CORRUPTTED_BALANCE_PLAN = -38
  E_NO_INVALID_BALANCE_PLAN = -39
  E_INVALID_PASSWORD = -41
  E_IMPROPER_ROLE = -42
  E_INVALID_PARTITION_NUM = -43
  E_INVALID_REPLICA_FACTOR = -44
  E_INVALID_CHARSET = -45
  E_INVALID_COLLATE = -46
  E_CHARSET_COLLATE_NOT_MATCH = -47
  E_SNAPSHOT_FAILURE = -51
  E_BLOCK_WRITE_FAILURE = -52
  E_REBUILD_INDEX_FAILURE = -53
  E_INDEX_WITH_TTL = -54
  E_ADD_JOB_FAILURE = -55
  E_STOP_JOB_FAILURE = -56
  E_SAVE_JOB_FAILURE = -57
  E_BALANCER_FAILURE = -58
  E_JOB_NOT_FINISHED = -59
  E_TASK_REPORT_OUT_DATE = -60
  E_BACKUP_FAILURE = -70
  E_BACKUP_BUILDING_INDEX = -71
  E_BACKUP_SPACE_NOT_FOUND = -72
  E_RESTORE_FAILURE = -80
  E_UNKNOWN = -99

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAIL_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -11: "E_LEADER_CHANGED",
    -21: "E_NO_HOSTS",
    -22: "E_EXISTED",
    -23: "E_NOT_FOUND",
    -24: "E_INVALID_HOST",
    -25: "E_UNSUPPORTED",
    -26: "E_NOT_DROP",
    -27: "E_BALANCER_RUNNING",
    -28: "E_CONFIG_IMMUTABLE",
    -29: "E_CONFLICT",
    -30: "E_INVALID_PARM",
    -31: "E_WRONGCLUSTER",
    -32: "E_STORE_FAILURE",
    -33: "E_STORE_SEGMENT_ILLEGAL",
    -34: "E_BAD_BALANCE_PLAN",
    -35: "E_BALANCED",
    -36: "E_NO_RUNNING_BALANCE_PLAN",
    -37: "E_NO_VALID_HOST",
    -38: "E_CORRUPTTED_BALANCE_PLAN",
    -39: "E_NO_INVALID_BALANCE_PLAN",
    -41: "E_INVALID_PASSWORD",
    -42: "E_IMPROPER_ROLE",
    -43: "E_INVALID_PARTITION_NUM",
    -44: "E_INVALID_REPLICA_FACTOR",
    -45: "E_INVALID_CHARSET",
    -46: "E_INVALID_COLLATE",
    -47: "E_CHARSET_COLLATE_NOT_MATCH",
    -51: "E_SNAPSHOT_FAILURE",
    -52: "E_BLOCK_WRITE_FAILURE",
    -53: "E_REBUILD_INDEX_FAILURE",
    -54: "E_INDEX_WITH_TTL",
    -55: "E_ADD_JOB_FAILURE",
    -56: "E_STOP_JOB_FAILURE",
    -57: "E_SAVE_JOB_FAILURE",
    -58: "E_BALANCER_FAILURE",
    -59: "E_JOB_NOT_FINISHED",
    -60: "E_TASK_REPORT_OUT_DATE",
    -70: "E_BACKUP_FAILURE",
    -71: "E_BACKUP_BUILDING_INDEX",
    -72: "E_BACKUP_SPACE_NOT_FOUND",
    -80: "E_RESTORE_FAILURE",
    -99: "E_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAIL_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_LEADER_CHANGED": -11,
    "E_NO_HOSTS": -21,
    "E_EXISTED": -22,
    "E_NOT_FOUND": -23,
    "E_INVALID_HOST": -24,
    "E_UNSUPPORTED": -25,
    "E_NOT_DROP": -26,
    "E_BALANCER_RUNNING": -27,
    "E_CONFIG_IMMUTABLE": -28,
    "E_CONFLICT": -29,
    "E_INVALID_PARM": -30,
    "E_WRONGCLUSTER": -31,
    "E_STORE_FAILURE": -32,
    "E_STORE_SEGMENT_ILLEGAL": -33,
    "E_BAD_BALANCE_PLAN": -34,
    "E_BALANCED": -35,
    "E_NO_RUNNING_BALANCE_PLAN": -36,
    "E_NO_VALID_HOST": -37,
    "E_CORRUPTTED_BALANCE_PLAN": -38,
    "E_NO_INVALID_BALANCE_PLAN": -39,
    "E_INVALID_PASSWORD": -41,
    "E_IMPROPER_ROLE": -42,
    "E_INVALID_PARTITION_NUM": -43,
    "E_INVALID_REPLICA_FACTOR": -44,
    "E_INVALID_CHARSET": -45,
    "E_INVALID_COLLATE": -46,
    "E_CHARSET_COLLATE_NOT_MATCH": -47,
    "E_SNAPSHOT_FAILURE": -51,
    "E_BLOCK_WRITE_FAILURE": -52,
    "E_REBUILD_INDEX_FAILURE": -53,
    "E_INDEX_WITH_TTL": -54,
    "E_ADD_JOB_FAILURE": -55,
    "E_STOP_JOB_FAILURE": -56,
    "E_SAVE_JOB_FAILURE": -57,
    "E_BALANCER_FAILURE": -58,
    "E_JOB_NOT_FINISHED": -59,
    "E_TASK_REPORT_OUT_DATE": -60,
    "E_BACKUP_FAILURE": -70,
    "E_BACKUP_BUILDING_INDEX": -71,
    "E_BACKUP_SPACE_NOT_FOUND": -72,
    "E_RESTORE_FAILURE": -80,
    "E_UNKNOWN": -99,
  }

class AlterSchemaOp:
  ADD = 1
  CHANGE = 2
  DROP = 3
  UNKNOWN = 4

  _VALUES_TO_NAMES = {
    1: "ADD",
    2: "CHANGE",
    3: "DROP",
    4: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "ADD": 1,
    "CHANGE": 2,
    "DROP": 3,
    "UNKNOWN": 4,
  }

class RoleType:
  GOD = 1
  ADMIN = 2
  DBA = 3
  USER = 4
  GUEST = 5

  _VALUES_TO_NAMES = {
    1: "GOD",
    2: "ADMIN",
    3: "DBA",
    4: "USER",
    5: "GUEST",
  }

  _NAMES_TO_VALUES = {
    "GOD": 1,
    "ADMIN": 2,
    "DBA": 3,
    "USER": 4,
    "GUEST": 5,
  }

class PropertyType:
  UNKNOWN = 0
  BOOL = 1
  INT64 = 2
  VID = 3
  FLOAT = 4
  DOUBLE = 5
  STRING = 6
  FIXED_STRING = 7
  INT8 = 8
  INT16 = 9
  INT32 = 10
  TIMESTAMP = 21
  DATE = 24
  DATETIME = 25
  TIME = 26

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "BOOL",
    2: "INT64",
    3: "VID",
    4: "FLOAT",
    5: "DOUBLE",
    6: "STRING",
    7: "FIXED_STRING",
    8: "INT8",
    9: "INT16",
    10: "INT32",
    21: "TIMESTAMP",
    24: "DATE",
    25: "DATETIME",
    26: "TIME",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "BOOL": 1,
    "INT64": 2,
    "VID": 3,
    "FLOAT": 4,
    "DOUBLE": 5,
    "STRING": 6,
    "FIXED_STRING": 7,
    "INT8": 8,
    "INT16": 9,
    "INT32": 10,
    "TIMESTAMP": 21,
    "DATE": 24,
    "DATETIME": 25,
    "TIME": 26,
  }

class IsolationLevel:
  DEFAULT = 0
  TOSS = 1

  _VALUES_TO_NAMES = {
    0: "DEFAULT",
    1: "TOSS",
  }

  _NAMES_TO_VALUES = {
    "DEFAULT": 0,
    "TOSS": 1,
  }

class HostStatus:
  ONLINE = 0
  OFFLINE = 1
  UNKNOWN = 2

  _VALUES_TO_NAMES = {
    0: "ONLINE",
    1: "OFFLINE",
    2: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "ONLINE": 0,
    "OFFLINE": 1,
    "UNKNOWN": 2,
  }

class SnapshotStatus:
  VALID = 0
  INVALID = 1

  _VALUES_TO_NAMES = {
    0: "VALID",
    1: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "VALID": 0,
    "INVALID": 1,
  }

class AdminJobOp:
  ADD = 1
  SHOW_All = 2
  SHOW = 3
  STOP = 4
  RECOVER = 5

  _VALUES_TO_NAMES = {
    1: "ADD",
    2: "SHOW_All",
    3: "SHOW",
    4: "STOP",
    5: "RECOVER",
  }

  _NAMES_TO_VALUES = {
    "ADD": 1,
    "SHOW_All": 2,
    "SHOW": 3,
    "STOP": 4,
    "RECOVER": 5,
  }

class AdminCmd:
  COMPACT = 0
  FLUSH = 1
  REBUILD_TAG_INDEX = 2
  REBUILD_EDGE_INDEX = 3
  STATS = 4
  DATA_BALANCE = 5
  DOWELOAD = 6
  INGEST = 7
  UNKNOWN = 99

  _VALUES_TO_NAMES = {
    0: "COMPACT",
    1: "FLUSH",
    2: "REBUILD_TAG_INDEX",
    3: "REBUILD_EDGE_INDEX",
    4: "STATS",
    5: "DATA_BALANCE",
    6: "DOWELOAD",
    7: "INGEST",
    99: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "COMPACT": 0,
    "FLUSH": 1,
    "REBUILD_TAG_INDEX": 2,
    "REBUILD_EDGE_INDEX": 3,
    "STATS": 4,
    "DATA_BALANCE": 5,
    "DOWELOAD": 6,
    "INGEST": 7,
    "UNKNOWN": 99,
  }

class JobStatus:
  QUEUE = 1
  RUNNING = 2
  FINISHED = 3
  FAILED = 4
  STOPPED = 5
  INVALID = 255

  _VALUES_TO_NAMES = {
    1: "QUEUE",
    2: "RUNNING",
    3: "FINISHED",
    4: "FAILED",
    5: "STOPPED",
    255: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "QUEUE": 1,
    "RUNNING": 2,
    "FINISHED": 3,
    "FAILED": 4,
    "STOPPED": 5,
    "INVALID": 255,
  }

class ListHostType:
  ALLOC = 0
  GRAPH = 1
  META = 2
  STORAGE = 3

  _VALUES_TO_NAMES = {
    0: "ALLOC",
    1: "GRAPH",
    2: "META",
    3: "STORAGE",
  }

  _NAMES_TO_VALUES = {
    "ALLOC": 0,
    "GRAPH": 1,
    "META": 2,
    "STORAGE": 3,
  }

class HostRole:
  GRAPH = 0
  META = 1
  STORAGE = 2
  LISTENER = 3
  UNKNOWN = 4

  _VALUES_TO_NAMES = {
    0: "GRAPH",
    1: "META",
    2: "STORAGE",
    3: "LISTENER",
    4: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "GRAPH": 0,
    "META": 1,
    "STORAGE": 2,
    "LISTENER": 3,
    "UNKNOWN": 4,
  }

class TaskResult:
  SUCCEEDED = 0
  FAILED = 1
  IN_PROGRESS = 2
  INVALID = 3

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    1: "FAILED",
    2: "IN_PROGRESS",
    3: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "FAILED": 1,
    "IN_PROGRESS": 2,
    "INVALID": 3,
  }

class ConfigModule:
  UNKNOWN = 0
  ALL = 1
  GRAPH = 2
  META = 3
  STORAGE = 4

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "ALL",
    2: "GRAPH",
    3: "META",
    4: "STORAGE",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "ALL": 1,
    "GRAPH": 2,
    "META": 3,
    "STORAGE": 4,
  }

class ConfigMode:
  IMMUTABLE = 0
  REBOOT = 1
  MUTABLE = 2
  IGNORED = 3

  _VALUES_TO_NAMES = {
    0: "IMMUTABLE",
    1: "REBOOT",
    2: "MUTABLE",
    3: "IGNORED",
  }

  _NAMES_TO_VALUES = {
    "IMMUTABLE": 0,
    "REBOOT": 1,
    "MUTABLE": 2,
    "IGNORED": 3,
  }

class ListenerType:
  UNKNOWN = 0
  ELASTICSEARCH = 1

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "ELASTICSEARCH",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "ELASTICSEARCH": 1,
  }

class FTServiceType:
  ELASTICSEARCH = 1

  _VALUES_TO_NAMES = {
    1: "ELASTICSEARCH",
  }

  _NAMES_TO_VALUES = {
    "ELASTICSEARCH": 1,
  }

class ID(object):
  """
  Attributes:
   - space_id
   - tag_id
   - edge_type
   - index_id
   - cluster_id
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  SPACE_ID = 1
  TAG_ID = 2
  EDGE_TYPE = 3
  INDEX_ID = 4
  CLUSTER_ID = 5
  
  @staticmethod
  def isUnion():
    return True

  def get_space_id(self):
    assert self.field == 1
    return self.value

  def get_tag_id(self):
    assert self.field == 2
    return self.value

  def get_edge_type(self):
    assert self.field == 3
    return self.value

  def get_index_id(self):
    assert self.field == 4
    return self.value

  def get_cluster_id(self):
    assert self.field == 5
    return self.value

  def set_space_id(self, value):
    self.field = 1
    self.value = value

  def set_tag_id(self, value):
    self.field = 2
    self.value = value

  def set_edge_type(self, value):
    self.field = 3
    self.value = value

  def set_index_id(self, value):
    self.field = 4
    self.value = value

  def set_cluster_id(self, value):
    self.field = 5
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('space_id', value)
    if self.field == 2:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tag_id', value)
    if self.field == 3:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('edge_type', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('index_id', value)
    if self.field == 5:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('cluster_id', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          space_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_space_id(space_id)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          tag_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_tag_id(tag_id)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          edge_type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_edge_type(edge_type)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          index_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_index_id(index_id)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          cluster_id = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_cluster_id(cluster_id)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('ID')
    if self.field == 1:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      space_id = self.value
      oprot.writeI32(space_id)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('tag_id', TType.I32, 2)
      tag_id = self.value
      oprot.writeI32(tag_id)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('edge_type', TType.I32, 3)
      edge_type = self.value
      oprot.writeI32(edge_type)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('index_id', TType.I32, 4)
      index_id = self.value
      oprot.writeI32(index_id)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('cluster_id', TType.I64, 5)
      cluster_id = self.value
      oprot.writeI64(cluster_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnTypeDef:
  """
  Attributes:
   - type
   - type_length
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.type_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.type == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'type' was not found in serialized data! Struct: ColumnTypeDef")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ColumnTypeDef')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.type_length != None and self.type_length != self.thrift_spec[2][4]:
      oprot.writeFieldBegin('type_length', TType.I16, 2)
      oprot.writeI16(self.type_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.type_length is not None:
      value = pprint.pformat(self.type_length, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type_length=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ColumnDef:
  """
  Attributes:
   - name
   - type
   - default_value
   - nullable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.type = ColumnTypeDef()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.default_value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.nullable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.name == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'name' was not found in serialized data! Struct: ColumnDef")

    if self.type == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'type' was not found in serialized data! Struct: ColumnDef")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ColumnDef')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 2)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    if self.default_value != None:
      oprot.writeFieldBegin('default_value', TType.STRING, 3)
      oprot.writeString(self.default_value)
      oprot.writeFieldEnd()
    if self.nullable != None and self.nullable != self.thrift_spec[4][4]:
      oprot.writeFieldBegin('nullable', TType.BOOL, 4)
      oprot.writeBool(self.nullable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.default_value is not None:
      value = pprint.pformat(self.default_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    default_value=%s' % (value))
    if self.nullable is not None:
      value = pprint.pformat(self.nullable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nullable=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SchemaProp:
  """
  Attributes:
   - ttl_duration
   - ttl_col
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ttl_duration = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ttl_col = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SchemaProp')
    if self.ttl_duration != None:
      oprot.writeFieldBegin('ttl_duration', TType.I64, 1)
      oprot.writeI64(self.ttl_duration)
      oprot.writeFieldEnd()
    if self.ttl_col != None:
      oprot.writeFieldBegin('ttl_col', TType.STRING, 2)
      oprot.writeString(self.ttl_col)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ttl_duration is not None:
      value = pprint.pformat(self.ttl_duration, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ttl_duration=%s' % (value))
    if self.ttl_col is not None:
      value = pprint.pformat(self.ttl_col, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ttl_col=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Schema:
  """
  Attributes:
   - columns
   - schema_prop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = ColumnDef()
              _elem5.read(iprot)
              self.columns.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = ColumnDef()
              _elem6.read(iprot)
              self.columns.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema_prop = SchemaProp()
          self.schema_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Schema')
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter7 in self.columns:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_prop != None:
      oprot.writeFieldBegin('schema_prop', TType.STRUCT, 2)
      self.schema_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.columns is not None:
      value = pprint.pformat(self.columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    columns=%s' % (value))
    if self.schema_prop is not None:
      value = pprint.pformat(self.schema_prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_prop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IdName:
  """
  Attributes:
   - id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = ID()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IdName')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SpaceDesc:
  """
  Attributes:
   - space_name
   - partition_num
   - replica_factor
   - charset_name
   - collate_name
   - vid_type
   - group_name
   - isolation_level
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partition_num = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.replica_factor = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.charset_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.collate_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.vid_type = ColumnTypeDef()
          self.vid_type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.isolation_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SpaceDesc')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.partition_num != None:
      oprot.writeFieldBegin('partition_num', TType.I32, 2)
      oprot.writeI32(self.partition_num)
      oprot.writeFieldEnd()
    if self.replica_factor != None:
      oprot.writeFieldBegin('replica_factor', TType.I32, 3)
      oprot.writeI32(self.replica_factor)
      oprot.writeFieldEnd()
    if self.charset_name != None:
      oprot.writeFieldBegin('charset_name', TType.STRING, 4)
      oprot.writeString(self.charset_name)
      oprot.writeFieldEnd()
    if self.collate_name != None:
      oprot.writeFieldBegin('collate_name', TType.STRING, 5)
      oprot.writeString(self.collate_name)
      oprot.writeFieldEnd()
    if self.vid_type != None:
      oprot.writeFieldBegin('vid_type', TType.STRUCT, 6)
      self.vid_type.write(oprot)
      oprot.writeFieldEnd()
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 7)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    if self.isolation_level != None:
      oprot.writeFieldBegin('isolation_level', TType.I32, 8)
      oprot.writeI32(self.isolation_level)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.partition_num is not None:
      value = pprint.pformat(self.partition_num, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    partition_num=%s' % (value))
    if self.replica_factor is not None:
      value = pprint.pformat(self.replica_factor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    replica_factor=%s' % (value))
    if self.charset_name is not None:
      value = pprint.pformat(self.charset_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    charset_name=%s' % (value))
    if self.collate_name is not None:
      value = pprint.pformat(self.collate_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    collate_name=%s' % (value))
    if self.vid_type is not None:
      value = pprint.pformat(self.vid_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vid_type=%s' % (value))
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    if self.isolation_level is not None:
      value = pprint.pformat(self.isolation_level, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    isolation_level=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SpaceItem:
  """
  Attributes:
   - space_id
   - properties
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.properties = SpaceDesc()
          self.properties.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SpaceItem')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.properties != None:
      oprot.writeFieldBegin('properties', TType.STRUCT, 2)
      self.properties.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.properties is not None:
      value = pprint.pformat(self.properties, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    properties=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TagItem:
  """
  Attributes:
   - tag_id
   - tag_name
   - version
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TagItem')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 4)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AlterSchemaItem:
  """
  Attributes:
   - op
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterSchemaItem')
    if self.op != None:
      oprot.writeFieldBegin('op', TType.I32, 1)
      oprot.writeI32(self.op)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.op is not None:
      value = pprint.pformat(self.op, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    op=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class EdgeItem:
  """
  Attributes:
   - edge_type
   - edge_name
   - version
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeItem')
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 1)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 4)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SchemaID(object):
  """
  Attributes:
   - tag_id
   - edge_type
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  TAG_ID = 1
  EDGE_TYPE = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_tag_id(self):
    assert self.field == 1
    return self.value

  def get_edge_type(self):
    assert self.field == 2
    return self.value

  def set_tag_id(self, value):
    self.field = 1
    self.value = value

  def set_edge_type(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tag_id', value)
    if self.field == 2:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('edge_type', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          tag_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_tag_id(tag_id)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          edge_type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_edge_type(edge_type)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('SchemaID')
    if self.field == 1:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      tag_id = self.value
      oprot.writeI32(tag_id)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      edge_type = self.value
      oprot.writeI32(edge_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexItem:
  """
  Attributes:
   - index_id
   - index_name
   - schema_id
   - schema_name
   - fields
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema_id = SchemaID()
          self.schema_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.schema_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fields = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = ColumnDef()
              _elem13.read(iprot)
              self.fields.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = ColumnDef()
              _elem14.read(iprot)
              self.fields.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexItem')
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 1)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.schema_id != None:
      oprot.writeFieldBegin('schema_id', TType.STRUCT, 3)
      self.schema_id.write(oprot)
      oprot.writeFieldEnd()
    if self.schema_name != None:
      oprot.writeFieldBegin('schema_name', TType.STRING, 4)
      oprot.writeString(self.schema_name)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter15 in self.fields:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.schema_id is not None:
      value = pprint.pformat(self.schema_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_id=%s' % (value))
    if self.schema_name is not None:
      value = pprint.pformat(self.schema_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_name=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class HostItem:
  """
  Attributes:
   - hostAddr
   - status
   - leader_parts
   - all_parts
   - role
   - git_info_sha
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hostAddr = nebula2.common.ttypes.HostAddr()
          self.hostAddr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin() 
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _key21 = iprot.readString()
              _val22 = []
              (_etype26, _size23) = iprot.readListBegin()
              if _size23 >= 0:
                for _i27 in six.moves.range(_size23):
                  _elem28 = iprot.readI32()
                  _val22.append(_elem28)
              else: 
                while iprot.peekList():
                  _elem29 = iprot.readI32()
                  _val22.append(_elem29)
              iprot.readListEnd()
              self.leader_parts[_key21] = _val22
          else: 
            while iprot.peekMap():
              _key30 = iprot.readString()
              _val31 = []
              (_etype35, _size32) = iprot.readListBegin()
              if _size32 >= 0:
                for _i36 in six.moves.range(_size32):
                  _elem37 = iprot.readI32()
                  _val31.append(_elem37)
              else: 
                while iprot.peekList():
                  _elem38 = iprot.readI32()
                  _val31.append(_elem38)
              iprot.readListEnd()
              self.leader_parts[_key30] = _val31
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.all_parts = {}
          (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
          if _size39 >= 0:
            for _i43 in six.moves.range(_size39):
              _key44 = iprot.readString()
              _val45 = []
              (_etype49, _size46) = iprot.readListBegin()
              if _size46 >= 0:
                for _i50 in six.moves.range(_size46):
                  _elem51 = iprot.readI32()
                  _val45.append(_elem51)
              else: 
                while iprot.peekList():
                  _elem52 = iprot.readI32()
                  _val45.append(_elem52)
              iprot.readListEnd()
              self.all_parts[_key44] = _val45
          else: 
            while iprot.peekMap():
              _key53 = iprot.readString()
              _val54 = []
              (_etype58, _size55) = iprot.readListBegin()
              if _size55 >= 0:
                for _i59 in six.moves.range(_size55):
                  _elem60 = iprot.readI32()
                  _val54.append(_elem60)
              else: 
                while iprot.peekList():
                  _elem61 = iprot.readI32()
                  _val54.append(_elem61)
              iprot.readListEnd()
              self.all_parts[_key53] = _val54
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.role = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.git_info_sha = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostItem')
    if self.hostAddr != None:
      oprot.writeFieldBegin('hostAddr', TType.STRUCT, 1)
      self.hostAddr.write(oprot)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.leader_parts))
      for kiter62,viter63 in self.leader_parts.items():
        oprot.writeString(kiter62)
        oprot.writeListBegin(TType.I32, len(viter63))
        for iter64 in viter63:
          oprot.writeI32(iter64)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.all_parts != None:
      oprot.writeFieldBegin('all_parts', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.all_parts))
      for kiter65,viter66 in self.all_parts.items():
        oprot.writeString(kiter65)
        oprot.writeListBegin(TType.I32, len(viter66))
        for iter67 in viter66:
          oprot.writeI32(iter67)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.role != None:
      oprot.writeFieldBegin('role', TType.I32, 5)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.git_info_sha != None:
      oprot.writeFieldBegin('git_info_sha', TType.STRING, 6)
      oprot.writeString(self.git_info_sha)
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 7)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hostAddr is not None:
      value = pprint.pformat(self.hostAddr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hostAddr=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    if self.all_parts is not None:
      value = pprint.pformat(self.all_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    all_parts=%s' % (value))
    if self.role is not None:
      value = pprint.pformat(self.role, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role=%s' % (value))
    if self.git_info_sha is not None:
      value = pprint.pformat(self.git_info_sha, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    git_info_sha=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UserItem:
  """
  Attributes:
   - account
   - is_lock
   - max_queries_per_hour
   - max_updates_per_hour
   - max_connections_per_hour
   - max_user_connections
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_lock = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_queries_per_hour = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.max_updates_per_hour = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.max_connections_per_hour = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.max_user_connections = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UserItem')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.is_lock != None:
      oprot.writeFieldBegin('is_lock', TType.BOOL, 2)
      oprot.writeBool(self.is_lock)
      oprot.writeFieldEnd()
    if self.max_queries_per_hour != None:
      oprot.writeFieldBegin('max_queries_per_hour', TType.I32, 3)
      oprot.writeI32(self.max_queries_per_hour)
      oprot.writeFieldEnd()
    if self.max_updates_per_hour != None:
      oprot.writeFieldBegin('max_updates_per_hour', TType.I32, 4)
      oprot.writeI32(self.max_updates_per_hour)
      oprot.writeFieldEnd()
    if self.max_connections_per_hour != None:
      oprot.writeFieldBegin('max_connections_per_hour', TType.I32, 5)
      oprot.writeI32(self.max_connections_per_hour)
      oprot.writeFieldEnd()
    if self.max_user_connections != None:
      oprot.writeFieldBegin('max_user_connections', TType.I32, 6)
      oprot.writeI32(self.max_user_connections)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.is_lock is not None:
      value = pprint.pformat(self.is_lock, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_lock=%s' % (value))
    if self.max_queries_per_hour is not None:
      value = pprint.pformat(self.max_queries_per_hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_queries_per_hour=%s' % (value))
    if self.max_updates_per_hour is not None:
      value = pprint.pformat(self.max_updates_per_hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_updates_per_hour=%s' % (value))
    if self.max_connections_per_hour is not None:
      value = pprint.pformat(self.max_connections_per_hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_connections_per_hour=%s' % (value))
    if self.max_user_connections is not None:
      value = pprint.pformat(self.max_user_connections, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_user_connections=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RoleItem:
  """
  Attributes:
   - user_id
   - space_id
   - role_type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.role_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RoleItem')
    if self.user_id != None:
      oprot.writeFieldBegin('user_id', TType.STRING, 1)
      oprot.writeString(self.user_id)
      oprot.writeFieldEnd()
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 2)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.role_type != None:
      oprot.writeFieldBegin('role_type', TType.I32, 3)
      oprot.writeI32(self.role_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.user_id is not None:
      value = pprint.pformat(self.user_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user_id=%s' % (value))
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.role_type is not None:
      value = pprint.pformat(self.role_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role_type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ExecResp:
  """
  Attributes:
   - code
   - id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.id = ID()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 2)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdminJobReq:
  """
  Attributes:
   - op
   - cmd
   - paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.paras = []
          (_etype71, _size68) = iprot.readListBegin()
          if _size68 >= 0:
            for _i72 in six.moves.range(_size68):
              _elem73 = iprot.readString()
              self.paras.append(_elem73)
          else: 
            while iprot.peekList():
              _elem74 = iprot.readString()
              self.paras.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminJobReq')
    if self.op != None:
      oprot.writeFieldBegin('op', TType.I32, 1)
      oprot.writeI32(self.op)
      oprot.writeFieldEnd()
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 2)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.paras != None:
      oprot.writeFieldBegin('paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.paras))
      for iter75 in self.paras:
        oprot.writeString(iter75)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.op is not None:
      value = pprint.pformat(self.op, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    op=%s' % (value))
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.paras is not None:
      value = pprint.pformat(self.paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class JobDesc:
  """
  Attributes:
   - id
   - cmd
   - paras
   - status
   - start_time
   - stop_time
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.paras = []
          (_etype79, _size76) = iprot.readListBegin()
          if _size76 >= 0:
            for _i80 in six.moves.range(_size76):
              _elem81 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.paras.append(_elem81)
          else: 
            while iprot.peekList():
              _elem82 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.paras.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.stop_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('JobDesc')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 2)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.paras != None:
      oprot.writeFieldBegin('paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.paras))
      for iter83 in self.paras:
        oprot.writeString(iter83.encode('utf-8')) if UTF8STRINGS and not isinstance(iter83, bytes) else oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 5)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.stop_time != None:
      oprot.writeFieldBegin('stop_time', TType.I64, 6)
      oprot.writeI64(self.stop_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.paras is not None:
      value = pprint.pformat(self.paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    paras=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.stop_time is not None:
      value = pprint.pformat(self.stop_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stop_time=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class TaskDesc:
  """
  Attributes:
   - task_id
   - host
   - status
   - start_time
   - stop_time
   - job_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula2.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.stop_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TaskDesc')
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 1)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 3)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 4)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.stop_time != None:
      oprot.writeFieldBegin('stop_time', TType.I64, 5)
      oprot.writeI64(self.stop_time)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 6)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.stop_time is not None:
      value = pprint.pformat(self.stop_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stop_time=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdminJobResult:
  """
  Attributes:
   - job_id
   - job_desc
   - task_desc
   - recovered_job_num
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.job_desc = []
          (_etype87, _size84) = iprot.readListBegin()
          if _size84 >= 0:
            for _i88 in six.moves.range(_size84):
              _elem89 = JobDesc()
              _elem89.read(iprot)
              self.job_desc.append(_elem89)
          else: 
            while iprot.peekList():
              _elem90 = JobDesc()
              _elem90.read(iprot)
              self.job_desc.append(_elem90)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.task_desc = []
          (_etype94, _size91) = iprot.readListBegin()
          if _size91 >= 0:
            for _i95 in six.moves.range(_size91):
              _elem96 = TaskDesc()
              _elem96.read(iprot)
              self.task_desc.append(_elem96)
          else: 
            while iprot.peekList():
              _elem97 = TaskDesc()
              _elem97.read(iprot)
              self.task_desc.append(_elem97)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.recovered_job_num = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminJobResult')
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 1)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.job_desc != None:
      oprot.writeFieldBegin('job_desc', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.job_desc))
      for iter98 in self.job_desc:
        iter98.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.task_desc != None:
      oprot.writeFieldBegin('task_desc', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.task_desc))
      for iter99 in self.task_desc:
        iter99.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.recovered_job_num != None:
      oprot.writeFieldBegin('recovered_job_num', TType.I32, 4)
      oprot.writeI32(self.recovered_job_num)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.job_desc is not None:
      value = pprint.pformat(self.job_desc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_desc=%s' % (value))
    if self.task_desc is not None:
      value = pprint.pformat(self.task_desc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_desc=%s' % (value))
    if self.recovered_job_num is not None:
      value = pprint.pformat(self.recovered_job_num, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    recovered_job_num=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdminJobResp:
  """
  Attributes:
   - code
   - leader
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = AdminJobResult()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminJobResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Correlativity:
  """
  Attributes:
   - part_id
   - proportion
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.proportion = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Correlativity')
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 1)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.proportion != None:
      oprot.writeFieldBegin('proportion', TType.DOUBLE, 2)
      oprot.writeDouble(self.proportion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.proportion is not None:
      value = pprint.pformat(self.proportion, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    proportion=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class StatisItem:
  """
  Attributes:
   - tag_vertices
   - edges
   - space_vertices
   - space_edges
   - part_corelativity
   - status
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.tag_vertices = {}
          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin() 
          if _size100 >= 0:
            for _i104 in six.moves.range(_size100):
              _key105 = iprot.readString()
              _val106 = iprot.readI64()
              self.tag_vertices[_key105] = _val106
          else: 
            while iprot.peekMap():
              _key107 = iprot.readString()
              _val108 = iprot.readI64()
              self.tag_vertices[_key107] = _val108
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.edges = {}
          (_ktype110, _vtype111, _size109 ) = iprot.readMapBegin() 
          if _size109 >= 0:
            for _i113 in six.moves.range(_size109):
              _key114 = iprot.readString()
              _val115 = iprot.readI64()
              self.edges[_key114] = _val115
          else: 
            while iprot.peekMap():
              _key116 = iprot.readString()
              _val117 = iprot.readI64()
              self.edges[_key116] = _val117
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.space_vertices = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.space_edges = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.part_corelativity = {}
          (_ktype119, _vtype120, _size118 ) = iprot.readMapBegin() 
          if _size118 >= 0:
            for _i122 in six.moves.range(_size118):
              _key123 = iprot.readI32()
              _val124 = []
              (_etype128, _size125) = iprot.readListBegin()
              if _size125 >= 0:
                for _i129 in six.moves.range(_size125):
                  _elem130 = Correlativity()
                  _elem130.read(iprot)
                  _val124.append(_elem130)
              else: 
                while iprot.peekList():
                  _elem131 = Correlativity()
                  _elem131.read(iprot)
                  _val124.append(_elem131)
              iprot.readListEnd()
              self.part_corelativity[_key123] = _val124
          else: 
            while iprot.peekMap():
              _key132 = iprot.readI32()
              _val133 = []
              (_etype137, _size134) = iprot.readListBegin()
              if _size134 >= 0:
                for _i138 in six.moves.range(_size134):
                  _elem139 = Correlativity()
                  _elem139.read(iprot)
                  _val133.append(_elem139)
              else: 
                while iprot.peekList():
                  _elem140 = Correlativity()
                  _elem140.read(iprot)
                  _val133.append(_elem140)
              iprot.readListEnd()
              self.part_corelativity[_key132] = _val133
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StatisItem')
    if self.tag_vertices != None:
      oprot.writeFieldBegin('tag_vertices', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.tag_vertices))
      for kiter141,viter142 in self.tag_vertices.items():
        oprot.writeString(kiter141)
        oprot.writeI64(viter142)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edges != None:
      oprot.writeFieldBegin('edges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.edges))
      for kiter143,viter144 in self.edges.items():
        oprot.writeString(kiter143)
        oprot.writeI64(viter144)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.space_vertices != None:
      oprot.writeFieldBegin('space_vertices', TType.I64, 3)
      oprot.writeI64(self.space_vertices)
      oprot.writeFieldEnd()
    if self.space_edges != None:
      oprot.writeFieldBegin('space_edges', TType.I64, 4)
      oprot.writeI64(self.space_edges)
      oprot.writeFieldEnd()
    if self.part_corelativity != None:
      oprot.writeFieldBegin('part_corelativity', TType.MAP, 5)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.part_corelativity))
      for kiter145,viter146 in self.part_corelativity.items():
        oprot.writeI32(kiter145)
        oprot.writeListBegin(TType.STRUCT, len(viter146))
        for iter147 in viter146:
          iter147.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 6)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_vertices is not None:
      value = pprint.pformat(self.tag_vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_vertices=%s' % (value))
    if self.edges is not None:
      value = pprint.pformat(self.edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edges=%s' % (value))
    if self.space_vertices is not None:
      value = pprint.pformat(self.space_vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_vertices=%s' % (value))
    if self.space_edges is not None:
      value = pprint.pformat(self.space_edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_edges=%s' % (value))
    if self.part_corelativity is not None:
      value = pprint.pformat(self.part_corelativity, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_corelativity=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateSpaceReq:
  """
  Attributes:
   - properties
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.properties = SpaceDesc()
          self.properties.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSpaceReq')
    if self.properties != None:
      oprot.writeFieldBegin('properties', TType.STRUCT, 1)
      self.properties.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.properties is not None:
      value = pprint.pformat(self.properties, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    properties=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropSpaceReq:
  """
  Attributes:
   - space_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropSpaceReq')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListSpacesReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSpacesReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListSpacesResp:
  """
  Attributes:
   - code
   - leader
   - spaces
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.spaces = []
          (_etype151, _size148) = iprot.readListBegin()
          if _size148 >= 0:
            for _i152 in six.moves.range(_size148):
              _elem153 = IdName()
              _elem153.read(iprot)
              self.spaces.append(_elem153)
          else: 
            while iprot.peekList():
              _elem154 = IdName()
              _elem154.read(iprot)
              self.spaces.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSpacesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.spaces != None:
      oprot.writeFieldBegin('spaces', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.spaces))
      for iter155 in self.spaces:
        iter155.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.spaces is not None:
      value = pprint.pformat(self.spaces, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    spaces=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetSpaceReq:
  """
  Attributes:
   - space_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSpaceReq')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetSpaceResp:
  """
  Attributes:
   - code
   - leader
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = SpaceItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSpaceResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - schema
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AlterTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - tag_items
   - schema_prop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tag_items = []
          (_etype159, _size156) = iprot.readListBegin()
          if _size156 >= 0:
            for _i160 in six.moves.range(_size156):
              _elem161 = AlterSchemaItem()
              _elem161.read(iprot)
              self.tag_items.append(_elem161)
          else: 
            while iprot.peekList():
              _elem162 = AlterSchemaItem()
              _elem162.read(iprot)
              self.tag_items.append(_elem162)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema_prop = SchemaProp()
          self.schema_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.tag_items != None:
      oprot.writeFieldBegin('tag_items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tag_items))
      for iter163 in self.tag_items:
        iter163.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_prop != None:
      oprot.writeFieldBegin('schema_prop', TType.STRUCT, 4)
      self.schema_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.tag_items is not None:
      value = pprint.pformat(self.tag_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_items=%s' % (value))
    if self.schema_prop is not None:
      value = pprint.pformat(self.schema_prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_prop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListTagsReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagsReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListTagsResp:
  """
  Attributes:
   - code
   - leader
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tags = []
          (_etype167, _size164) = iprot.readListBegin()
          if _size164 >= 0:
            for _i168 in six.moves.range(_size164):
              _elem169 = TagItem()
              _elem169.read(iprot)
              self.tags.append(_elem169)
          else: 
            while iprot.peekList():
              _elem170 = TagItem()
              _elem170.read(iprot)
              self.tags.append(_elem170)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter171 in self.tags:
        iter171.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetTagResp:
  """
  Attributes:
   - code
   - leader
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - schema
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AlterEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - edge_items
   - schema_prop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edge_items = []
          (_etype175, _size172) = iprot.readListBegin()
          if _size172 >= 0:
            for _i176 in six.moves.range(_size172):
              _elem177 = AlterSchemaItem()
              _elem177.read(iprot)
              self.edge_items.append(_elem177)
          else: 
            while iprot.peekList():
              _elem178 = AlterSchemaItem()
              _elem178.read(iprot)
              self.edge_items.append(_elem178)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema_prop = SchemaProp()
          self.schema_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.edge_items != None:
      oprot.writeFieldBegin('edge_items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_items))
      for iter179 in self.edge_items:
        iter179.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_prop != None:
      oprot.writeFieldBegin('schema_prop', TType.STRUCT, 4)
      self.schema_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.edge_items is not None:
      value = pprint.pformat(self.edge_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_items=%s' % (value))
    if self.schema_prop is not None:
      value = pprint.pformat(self.schema_prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_prop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetEdgeResp:
  """
  Attributes:
   - code
   - leader
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListEdgesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListEdgesResp:
  """
  Attributes:
   - code
   - leader
   - edges
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edges = []
          (_etype183, _size180) = iprot.readListBegin()
          if _size180 >= 0:
            for _i184 in six.moves.range(_size180):
              _elem185 = EdgeItem()
              _elem185.read(iprot)
              self.edges.append(_elem185)
          else: 
            while iprot.peekList():
              _elem186 = EdgeItem()
              _elem186.read(iprot)
              self.edges.append(_elem186)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.edges != None:
      oprot.writeFieldBegin('edges', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edges))
      for iter187 in self.edges:
        iter187.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.edges is not None:
      value = pprint.pformat(self.edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edges=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListHostsReq:
  """
  Attributes:
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListHostsReq')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListHostsResp:
  """
  Attributes:
   - code
   - leader
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype191, _size188) = iprot.readListBegin()
          if _size188 >= 0:
            for _i192 in six.moves.range(_size188):
              _elem193 = HostItem()
              _elem193.read(iprot)
              self.hosts.append(_elem193)
          else: 
            while iprot.peekList():
              _elem194 = HostItem()
              _elem194.read(iprot)
              self.hosts.append(_elem194)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListHostsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter195 in self.hosts:
        iter195.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PartItem:
  """
  Attributes:
   - part_id
   - leader
   - peers
   - losts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype199, _size196) = iprot.readListBegin()
          if _size196 >= 0:
            for _i200 in six.moves.range(_size196):
              _elem201 = nebula2.common.ttypes.HostAddr()
              _elem201.read(iprot)
              self.peers.append(_elem201)
          else: 
            while iprot.peekList():
              _elem202 = nebula2.common.ttypes.HostAddr()
              _elem202.read(iprot)
              self.peers.append(_elem202)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.losts = []
          (_etype206, _size203) = iprot.readListBegin()
          if _size203 >= 0:
            for _i207 in six.moves.range(_size203):
              _elem208 = nebula2.common.ttypes.HostAddr()
              _elem208.read(iprot)
              self.losts.append(_elem208)
          else: 
            while iprot.peekList():
              _elem209 = nebula2.common.ttypes.HostAddr()
              _elem209.read(iprot)
              self.losts.append(_elem209)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.part_id == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'part_id' was not found in serialized data! Struct: PartItem")

    if self.peers == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'peers' was not found in serialized data! Struct: PartItem")

    if self.losts == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'losts' was not found in serialized data! Struct: PartItem")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartItem')
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 1)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter210 in self.peers:
        iter210.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.losts != None:
      oprot.writeFieldBegin('losts', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.losts))
      for iter211 in self.losts:
        iter211.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    if self.losts is not None:
      value = pprint.pformat(self.losts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    losts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListPartsReq:
  """
  Attributes:
   - space_id
   - part_ids
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.part_ids = []
          (_etype215, _size212) = iprot.readListBegin()
          if _size212 >= 0:
            for _i216 in six.moves.range(_size212):
              _elem217 = iprot.readI32()
              self.part_ids.append(_elem217)
          else: 
            while iprot.peekList():
              _elem218 = iprot.readI32()
              self.part_ids.append(_elem218)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListPartsReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_ids != None:
      oprot.writeFieldBegin('part_ids', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.part_ids))
      for iter219 in self.part_ids:
        oprot.writeI32(iter219)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_ids is not None:
      value = pprint.pformat(self.part_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_ids=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListPartsResp:
  """
  Attributes:
   - code
   - leader
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parts = []
          (_etype223, _size220) = iprot.readListBegin()
          if _size220 >= 0:
            for _i224 in six.moves.range(_size220):
              _elem225 = PartItem()
              _elem225.read(iprot)
              self.parts.append(_elem225)
          else: 
            while iprot.peekList():
              _elem226 = PartItem()
              _elem226.read(iprot)
              self.parts.append(_elem226)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListPartsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parts))
      for iter227 in self.parts:
        iter227.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetPartsAllocReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPartsAllocReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetPartsAllocResp:
  """
  Attributes:
   - code
   - leader
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype229, _vtype230, _size228 ) = iprot.readMapBegin() 
          if _size228 >= 0:
            for _i232 in six.moves.range(_size228):
              _key233 = iprot.readI32()
              _val234 = []
              (_etype238, _size235) = iprot.readListBegin()
              if _size235 >= 0:
                for _i239 in six.moves.range(_size235):
                  _elem240 = nebula2.common.ttypes.HostAddr()
                  _elem240.read(iprot)
                  _val234.append(_elem240)
              else: 
                while iprot.peekList():
                  _elem241 = nebula2.common.ttypes.HostAddr()
                  _elem241.read(iprot)
                  _val234.append(_elem241)
              iprot.readListEnd()
              self.parts[_key233] = _val234
          else: 
            while iprot.peekMap():
              _key242 = iprot.readI32()
              _val243 = []
              (_etype247, _size244) = iprot.readListBegin()
              if _size244 >= 0:
                for _i248 in six.moves.range(_size244):
                  _elem249 = nebula2.common.ttypes.HostAddr()
                  _elem249.read(iprot)
                  _val243.append(_elem249)
              else: 
                while iprot.peekList():
                  _elem250 = nebula2.common.ttypes.HostAddr()
                  _elem250.read(iprot)
                  _val243.append(_elem250)
              iprot.readListEnd()
              self.parts[_key242] = _val243
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPartsAllocResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter251,viter252 in self.parts.items():
        oprot.writeI32(kiter251)
        oprot.writeListBegin(TType.STRUCT, len(viter252))
        for iter253 in viter252:
          iter253.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MultiPutReq:
  """
  Attributes:
   - segment
   - pairs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.pairs = []
          (_etype257, _size254) = iprot.readListBegin()
          if _size254 >= 0:
            for _i258 in six.moves.range(_size254):
              _elem259 = nebula2.common.ttypes.KeyValue()
              _elem259.read(iprot)
              self.pairs.append(_elem259)
          else: 
            while iprot.peekList():
              _elem260 = nebula2.common.ttypes.KeyValue()
              _elem260.read(iprot)
              self.pairs.append(_elem260)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MultiPutReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.pairs != None:
      oprot.writeFieldBegin('pairs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.pairs))
      for iter261 in self.pairs:
        iter261.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.pairs is not None:
      value = pprint.pformat(self.pairs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    pairs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetReq:
  """
  Attributes:
   - segment
   - key
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetResp:
  """
  Attributes:
   - code
   - leader
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MultiGetReq:
  """
  Attributes:
   - segment
   - keys
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.keys = []
          (_etype265, _size262) = iprot.readListBegin()
          if _size262 >= 0:
            for _i266 in six.moves.range(_size262):
              _elem267 = iprot.readString()
              self.keys.append(_elem267)
          else: 
            while iprot.peekList():
              _elem268 = iprot.readString()
              self.keys.append(_elem268)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MultiGetReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.keys != None:
      oprot.writeFieldBegin('keys', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter269 in self.keys:
        oprot.writeString(iter269)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.keys is not None:
      value = pprint.pformat(self.keys, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    keys=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class MultiGetResp:
  """
  Attributes:
   - code
   - leader
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype273, _size270) = iprot.readListBegin()
          if _size270 >= 0:
            for _i274 in six.moves.range(_size270):
              _elem275 = iprot.readString()
              self.values.append(_elem275)
          else: 
            while iprot.peekList():
              _elem276 = iprot.readString()
              self.values.append(_elem276)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MultiGetResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter277 in self.values:
        oprot.writeString(iter277)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemoveReq:
  """
  Attributes:
   - segment
   - key
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemoveRangeReq:
  """
  Attributes:
   - segment
   - start
   - end
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.end = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveRangeReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.end != None:
      oprot.writeFieldBegin('end', TType.STRING, 3)
      oprot.writeString(self.end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.start is not None:
      value = pprint.pformat(self.start, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start=%s' % (value))
    if self.end is not None:
      value = pprint.pformat(self.end, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanReq:
  """
  Attributes:
   - segment
   - start
   - end
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.end = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.end != None:
      oprot.writeFieldBegin('end', TType.STRING, 3)
      oprot.writeString(self.end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.start is not None:
      value = pprint.pformat(self.start, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start=%s' % (value))
    if self.end is not None:
      value = pprint.pformat(self.end, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ScanResp:
  """
  Attributes:
   - code
   - leader
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype281, _size278) = iprot.readListBegin()
          if _size278 >= 0:
            for _i282 in six.moves.range(_size278):
              _elem283 = iprot.readString()
              self.values.append(_elem283)
          else: 
            while iprot.peekList():
              _elem284 = iprot.readString()
              self.values.append(_elem284)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter285 in self.values:
        oprot.writeString(iter285)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class HBResp:
  """
  Attributes:
   - code
   - leader
   - cluster_id
   - last_update_time_in_ms
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.cluster_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.last_update_time_in_ms = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HBResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.cluster_id != None:
      oprot.writeFieldBegin('cluster_id', TType.I64, 3)
      oprot.writeI64(self.cluster_id)
      oprot.writeFieldEnd()
    if self.last_update_time_in_ms != None:
      oprot.writeFieldBegin('last_update_time_in_ms', TType.I64, 4)
      oprot.writeI64(self.last_update_time_in_ms)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.cluster_id is not None:
      value = pprint.pformat(self.cluster_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cluster_id=%s' % (value))
    if self.last_update_time_in_ms is not None:
      value = pprint.pformat(self.last_update_time_in_ms, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_update_time_in_ms=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class HBReq:
  """
  Attributes:
   - role
   - host
   - cluster_id
   - leader_partIds
   - git_info_sha
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.role = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula2.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.cluster_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.leader_partIds = {}
          (_ktype287, _vtype288, _size286 ) = iprot.readMapBegin() 
          if _size286 >= 0:
            for _i290 in six.moves.range(_size286):
              _key291 = iprot.readI32()
              _val292 = []
              (_etype296, _size293) = iprot.readListBegin()
              if _size293 >= 0:
                for _i297 in six.moves.range(_size293):
                  _elem298 = iprot.readI32()
                  _val292.append(_elem298)
              else: 
                while iprot.peekList():
                  _elem299 = iprot.readI32()
                  _val292.append(_elem299)
              iprot.readListEnd()
              self.leader_partIds[_key291] = _val292
          else: 
            while iprot.peekMap():
              _key300 = iprot.readI32()
              _val301 = []
              (_etype305, _size302) = iprot.readListBegin()
              if _size302 >= 0:
                for _i306 in six.moves.range(_size302):
                  _elem307 = iprot.readI32()
                  _val301.append(_elem307)
              else: 
                while iprot.peekList():
                  _elem308 = iprot.readI32()
                  _val301.append(_elem308)
              iprot.readListEnd()
              self.leader_partIds[_key300] = _val301
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.git_info_sha = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HBReq')
    if self.role != None:
      oprot.writeFieldBegin('role', TType.I32, 1)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.cluster_id != None:
      oprot.writeFieldBegin('cluster_id', TType.I64, 3)
      oprot.writeI64(self.cluster_id)
      oprot.writeFieldEnd()
    if self.leader_partIds != None:
      oprot.writeFieldBegin('leader_partIds', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_partIds))
      for kiter309,viter310 in self.leader_partIds.items():
        oprot.writeI32(kiter309)
        oprot.writeListBegin(TType.I32, len(viter310))
        for iter311 in viter310:
          oprot.writeI32(iter311)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.git_info_sha != None:
      oprot.writeFieldBegin('git_info_sha', TType.STRING, 5)
      oprot.writeString(self.git_info_sha)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.role is not None:
      value = pprint.pformat(self.role, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.cluster_id is not None:
      value = pprint.pformat(self.cluster_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cluster_id=%s' % (value))
    if self.leader_partIds is not None:
      value = pprint.pformat(self.leader_partIds, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_partIds=%s' % (value))
    if self.git_info_sha is not None:
      value = pprint.pformat(self.git_info_sha, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    git_info_sha=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexFieldDef:
  """
  Attributes:
   - name
   - type_length
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.type_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.name == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'name' was not found in serialized data! Struct: IndexFieldDef")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexFieldDef')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type_length != None:
      oprot.writeFieldBegin('type_length', TType.I16, 2)
      oprot.writeI16(self.type_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.type_length is not None:
      value = pprint.pformat(self.type_length, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type_length=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateTagIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - tag_name
   - fields
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype315, _size312) = iprot.readListBegin()
          if _size312 >= 0:
            for _i316 in six.moves.range(_size312):
              _elem317 = IndexFieldDef()
              _elem317.read(iprot)
              self.fields.append(_elem317)
          else: 
            while iprot.peekList():
              _elem318 = IndexFieldDef()
              _elem318.read(iprot)
              self.fields.append(_elem318)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateTagIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 3)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter319 in self.fields:
        iter319.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 5)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropTagIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropTagIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetTagIndexReq:
  """
  Attributes:
   - space_id
   - index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetTagIndexResp:
  """
  Attributes:
   - code
   - leader
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = IndexItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagIndexResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListTagIndexesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagIndexesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListTagIndexesResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype323, _size320) = iprot.readListBegin()
          if _size320 >= 0:
            for _i324 in six.moves.range(_size320):
              _elem325 = IndexItem()
              _elem325.read(iprot)
              self.items.append(_elem325)
          else: 
            while iprot.peekList():
              _elem326 = IndexItem()
              _elem326.read(iprot)
              self.items.append(_elem326)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagIndexesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter327 in self.items:
        iter327.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateEdgeIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - edge_name
   - fields
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype331, _size328) = iprot.readListBegin()
          if _size328 >= 0:
            for _i332 in six.moves.range(_size328):
              _elem333 = IndexFieldDef()
              _elem333.read(iprot)
              self.fields.append(_elem333)
          else: 
            while iprot.peekList():
              _elem334 = IndexFieldDef()
              _elem334.read(iprot)
              self.fields.append(_elem334)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateEdgeIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 3)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter335 in self.fields:
        iter335.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 5)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropEdgeIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropEdgeIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetEdgeIndexReq:
  """
  Attributes:
   - space_id
   - index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetEdgeIndexResp:
  """
  Attributes:
   - code
   - leader
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = IndexItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeIndexResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListEdgeIndexesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgeIndexesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListEdgeIndexesResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype339, _size336) = iprot.readListBegin()
          if _size336 >= 0:
            for _i340 in six.moves.range(_size336):
              _elem341 = IndexItem()
              _elem341.read(iprot)
              self.items.append(_elem341)
          else: 
            while iprot.peekList():
              _elem342 = IndexItem()
              _elem342.read(iprot)
              self.items.append(_elem342)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgeIndexesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter343 in self.items:
        iter343.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RebuildIndexReq:
  """
  Attributes:
   - space_id
   - index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateUserReq:
  """
  Attributes:
   - account
   - encoded_pwd
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateUserReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.encoded_pwd != None:
      oprot.writeFieldBegin('encoded_pwd', TType.STRING, 2)
      oprot.writeString(self.encoded_pwd)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.encoded_pwd is not None:
      value = pprint.pformat(self.encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    encoded_pwd=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropUserReq:
  """
  Attributes:
   - account
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropUserReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AlterUserReq:
  """
  Attributes:
   - account
   - encoded_pwd
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterUserReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.encoded_pwd != None:
      oprot.writeFieldBegin('encoded_pwd', TType.STRING, 2)
      oprot.writeString(self.encoded_pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.encoded_pwd is not None:
      value = pprint.pformat(self.encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    encoded_pwd=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GrantRoleReq:
  """
  Attributes:
   - role_item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role_item = RoleItem()
          self.role_item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GrantRoleReq')
    if self.role_item != None:
      oprot.writeFieldBegin('role_item', TType.STRUCT, 1)
      self.role_item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.role_item is not None:
      value = pprint.pformat(self.role_item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role_item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RevokeRoleReq:
  """
  Attributes:
   - role_item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role_item = RoleItem()
          self.role_item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RevokeRoleReq')
    if self.role_item != None:
      oprot.writeFieldBegin('role_item', TType.STRUCT, 1)
      self.role_item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.role_item is not None:
      value = pprint.pformat(self.role_item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role_item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListUsersReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListUsersReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListUsersResp:
  """
  Attributes:
   - code
   - leader
   - users
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.users = {}
          (_ktype345, _vtype346, _size344 ) = iprot.readMapBegin() 
          if _size344 >= 0:
            for _i348 in six.moves.range(_size344):
              _key349 = iprot.readString()
              _val350 = iprot.readString()
              self.users[_key349] = _val350
          else: 
            while iprot.peekMap():
              _key351 = iprot.readString()
              _val352 = iprot.readString()
              self.users[_key351] = _val352
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListUsersResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.users != None:
      oprot.writeFieldBegin('users', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.users))
      for kiter353,viter354 in self.users.items():
        oprot.writeString(kiter353)
        oprot.writeString(viter354)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.users is not None:
      value = pprint.pformat(self.users, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    users=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListRolesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListRolesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListRolesResp:
  """
  Attributes:
   - code
   - leader
   - roles
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.roles = []
          (_etype358, _size355) = iprot.readListBegin()
          if _size355 >= 0:
            for _i359 in six.moves.range(_size355):
              _elem360 = RoleItem()
              _elem360.read(iprot)
              self.roles.append(_elem360)
          else: 
            while iprot.peekList():
              _elem361 = RoleItem()
              _elem361.read(iprot)
              self.roles.append(_elem361)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListRolesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.roles != None:
      oprot.writeFieldBegin('roles', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.roles))
      for iter362 in self.roles:
        iter362.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.roles is not None:
      value = pprint.pformat(self.roles, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    roles=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetUserRolesReq:
  """
  Attributes:
   - account
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUserRolesReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ChangePasswordReq:
  """
  Attributes:
   - account
   - new_encoded_pwd
   - old_encoded_pwd
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.new_encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.old_encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChangePasswordReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.new_encoded_pwd != None:
      oprot.writeFieldBegin('new_encoded_pwd', TType.STRING, 2)
      oprot.writeString(self.new_encoded_pwd)
      oprot.writeFieldEnd()
    if self.old_encoded_pwd != None:
      oprot.writeFieldBegin('old_encoded_pwd', TType.STRING, 3)
      oprot.writeString(self.old_encoded_pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.new_encoded_pwd is not None:
      value = pprint.pformat(self.new_encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_encoded_pwd=%s' % (value))
    if self.old_encoded_pwd is not None:
      value = pprint.pformat(self.old_encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    old_encoded_pwd=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BalanceReq:
  """
  Attributes:
   - space_id
   - id
   - host_del
   - stop
   - reset
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.host_del = []
          (_etype366, _size363) = iprot.readListBegin()
          if _size363 >= 0:
            for _i367 in six.moves.range(_size363):
              _elem368 = nebula2.common.ttypes.HostAddr()
              _elem368.read(iprot)
              self.host_del.append(_elem368)
          else: 
            while iprot.peekList():
              _elem369 = nebula2.common.ttypes.HostAddr()
              _elem369.read(iprot)
              self.host_del.append(_elem369)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.stop = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.reset = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BalanceReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.host_del != None:
      oprot.writeFieldBegin('host_del', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.host_del))
      for iter370 in self.host_del:
        iter370.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stop != None:
      oprot.writeFieldBegin('stop', TType.BOOL, 4)
      oprot.writeBool(self.stop)
      oprot.writeFieldEnd()
    if self.reset != None:
      oprot.writeFieldBegin('reset', TType.BOOL, 5)
      oprot.writeBool(self.reset)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.host_del is not None:
      value = pprint.pformat(self.host_del, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host_del=%s' % (value))
    if self.stop is not None:
      value = pprint.pformat(self.stop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stop=%s' % (value))
    if self.reset is not None:
      value = pprint.pformat(self.reset, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    reset=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BalanceTask:
  """
  Attributes:
   - id
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.result = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BalanceTask')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.result != None:
      oprot.writeFieldBegin('result', TType.I32, 2)
      oprot.writeI32(self.result)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BalanceResp:
  """
  Attributes:
   - code
   - id
   - leader
   - tasks
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.tasks = []
          (_etype374, _size371) = iprot.readListBegin()
          if _size371 >= 0:
            for _i375 in six.moves.range(_size371):
              _elem376 = BalanceTask()
              _elem376.read(iprot)
              self.tasks.append(_elem376)
          else: 
            while iprot.peekList():
              _elem377 = BalanceTask()
              _elem377.read(iprot)
              self.tasks.append(_elem377)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BalanceResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.tasks != None:
      oprot.writeFieldBegin('tasks', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.tasks))
      for iter378 in self.tasks:
        iter378.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.tasks is not None:
      value = pprint.pformat(self.tasks, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tasks=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class LeaderBalanceReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LeaderBalanceReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ConfigItem:
  """
  Attributes:
   - module
   - name
   - mode
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.module = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.value = nebula2.common.ttypes.Value()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ConfigItem')
    if self.module != None:
      oprot.writeFieldBegin('module', TType.I32, 1)
      oprot.writeI32(self.module)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.mode != None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRUCT, 4)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.module is not None:
      value = pprint.pformat(self.module, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    module=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.mode is not None:
      value = pprint.pformat(self.mode, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mode=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RegConfigReq:
  """
  Attributes:
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype382, _size379) = iprot.readListBegin()
          if _size379 >= 0:
            for _i383 in six.moves.range(_size379):
              _elem384 = ConfigItem()
              _elem384.read(iprot)
              self.items.append(_elem384)
          else: 
            while iprot.peekList():
              _elem385 = ConfigItem()
              _elem385.read(iprot)
              self.items.append(_elem385)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RegConfigReq')
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter386 in self.items:
        iter386.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetConfigReq:
  """
  Attributes:
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.item = ConfigItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetConfigReq')
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 1)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetConfigResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype390, _size387) = iprot.readListBegin()
          if _size387 >= 0:
            for _i391 in six.moves.range(_size387):
              _elem392 = ConfigItem()
              _elem392.read(iprot)
              self.items.append(_elem392)
          else: 
            while iprot.peekList():
              _elem393 = ConfigItem()
              _elem393.read(iprot)
              self.items.append(_elem393)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetConfigResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter394 in self.items:
        iter394.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SetConfigReq:
  """
  Attributes:
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.item = ConfigItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SetConfigReq')
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 1)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListConfigsReq:
  """
  Attributes:
   - space
   - module
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.module = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListConfigsReq')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.STRING, 1)
      oprot.writeString(self.space)
      oprot.writeFieldEnd()
    if self.module != None:
      oprot.writeFieldBegin('module', TType.I32, 2)
      oprot.writeI32(self.module)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.module is not None:
      value = pprint.pformat(self.module, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    module=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListConfigsResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype398, _size395) = iprot.readListBegin()
          if _size395 >= 0:
            for _i399 in six.moves.range(_size395):
              _elem400 = ConfigItem()
              _elem400.read(iprot)
              self.items.append(_elem400)
          else: 
            while iprot.peekList():
              _elem401 = ConfigItem()
              _elem401.read(iprot)
              self.items.append(_elem401)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListConfigsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter402 in self.items:
        iter402.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateSnapshotReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSnapshotReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropSnapshotReq:
  """
  Attributes:
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropSnapshotReq')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListSnapshotsReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSnapshotsReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Snapshot:
  """
  Attributes:
   - name
   - status
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hosts = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Snapshot')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.STRING, 3)
      oprot.writeString(self.hosts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListSnapshotsResp:
  """
  Attributes:
   - code
   - leader
   - snapshots
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.snapshots = []
          (_etype406, _size403) = iprot.readListBegin()
          if _size403 >= 0:
            for _i407 in six.moves.range(_size403):
              _elem408 = Snapshot()
              _elem408.read(iprot)
              self.snapshots.append(_elem408)
          else: 
            while iprot.peekList():
              _elem409 = Snapshot()
              _elem409.read(iprot)
              self.snapshots.append(_elem409)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSnapshotsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.snapshots != None:
      oprot.writeFieldBegin('snapshots', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.snapshots))
      for iter410 in self.snapshots:
        iter410.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.snapshots is not None:
      value = pprint.pformat(self.snapshots, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    snapshots=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListIndexStatusReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListIndexStatusReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IndexStatus:
  """
  Attributes:
   - name
   - status
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.status = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexStatus')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.STRING, 2)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListIndexStatusResp:
  """
  Attributes:
   - code
   - leader
   - statuses
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.statuses = []
          (_etype414, _size411) = iprot.readListBegin()
          if _size411 >= 0:
            for _i415 in six.moves.range(_size411):
              _elem416 = IndexStatus()
              _elem416.read(iprot)
              self.statuses.append(_elem416)
          else: 
            while iprot.peekList():
              _elem417 = IndexStatus()
              _elem417.read(iprot)
              self.statuses.append(_elem417)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListIndexStatusResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.statuses != None:
      oprot.writeFieldBegin('statuses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.statuses))
      for iter418 in self.statuses:
        iter418.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.statuses is not None:
      value = pprint.pformat(self.statuses, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    statuses=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddZoneReq:
  """
  Attributes:
   - zone_name
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype422, _size419) = iprot.readListBegin()
          if _size419 >= 0:
            for _i423 in six.moves.range(_size419):
              _elem424 = nebula2.common.ttypes.HostAddr()
              _elem424.read(iprot)
              self.nodes.append(_elem424)
          else: 
            while iprot.peekList():
              _elem425 = nebula2.common.ttypes.HostAddr()
              _elem425.read(iprot)
              self.nodes.append(_elem425)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddZoneReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter426 in self.nodes:
        iter426.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropZoneReq:
  """
  Attributes:
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropZoneReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddHostIntoZoneReq:
  """
  Attributes:
   - node
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.node = nebula2.common.ttypes.HostAddr()
          self.node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddHostIntoZoneReq')
    if self.node != None:
      oprot.writeFieldBegin('node', TType.STRUCT, 1)
      self.node.write(oprot)
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 2)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.node is not None:
      value = pprint.pformat(self.node, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    node=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropHostFromZoneReq:
  """
  Attributes:
   - node
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.node = nebula2.common.ttypes.HostAddr()
          self.node.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropHostFromZoneReq')
    if self.node != None:
      oprot.writeFieldBegin('node', TType.STRUCT, 1)
      self.node.write(oprot)
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 2)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.node is not None:
      value = pprint.pformat(self.node, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    node=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetZoneReq:
  """
  Attributes:
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetZoneReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetZoneResp:
  """
  Attributes:
   - code
   - leader
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype430, _size427) = iprot.readListBegin()
          if _size427 >= 0:
            for _i431 in six.moves.range(_size427):
              _elem432 = nebula2.common.ttypes.HostAddr()
              _elem432.read(iprot)
              self.hosts.append(_elem432)
          else: 
            while iprot.peekList():
              _elem433 = nebula2.common.ttypes.HostAddr()
              _elem433.read(iprot)
              self.hosts.append(_elem433)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetZoneResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter434 in self.hosts:
        iter434.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListZonesReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListZonesReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Zone:
  """
  Attributes:
   - zone_name
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype438, _size435) = iprot.readListBegin()
          if _size435 >= 0:
            for _i439 in six.moves.range(_size435):
              _elem440 = nebula2.common.ttypes.HostAddr()
              _elem440.read(iprot)
              self.nodes.append(_elem440)
          else: 
            while iprot.peekList():
              _elem441 = nebula2.common.ttypes.HostAddr()
              _elem441.read(iprot)
              self.nodes.append(_elem441)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Zone')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter442 in self.nodes:
        iter442.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListZonesResp:
  """
  Attributes:
   - code
   - leader
   - zones
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.zones = []
          (_etype446, _size443) = iprot.readListBegin()
          if _size443 >= 0:
            for _i447 in six.moves.range(_size443):
              _elem448 = Zone()
              _elem448.read(iprot)
              self.zones.append(_elem448)
          else: 
            while iprot.peekList():
              _elem449 = Zone()
              _elem449.read(iprot)
              self.zones.append(_elem449)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListZonesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.zones != None:
      oprot.writeFieldBegin('zones', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.zones))
      for iter450 in self.zones:
        iter450.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.zones is not None:
      value = pprint.pformat(self.zones, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zones=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddGroupReq:
  """
  Attributes:
   - group_name
   - zone_names
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.zone_names = []
          (_etype454, _size451) = iprot.readListBegin()
          if _size451 >= 0:
            for _i455 in six.moves.range(_size451):
              _elem456 = iprot.readString()
              self.zone_names.append(_elem456)
          else: 
            while iprot.peekList():
              _elem457 = iprot.readString()
              self.zone_names.append(_elem457)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddGroupReq')
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 1)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    if self.zone_names != None:
      oprot.writeFieldBegin('zone_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.zone_names))
      for iter458 in self.zone_names:
        oprot.writeString(iter458)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    if self.zone_names is not None:
      value = pprint.pformat(self.zone_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_names=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropGroupReq:
  """
  Attributes:
   - group_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropGroupReq')
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 1)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddZoneIntoGroupReq:
  """
  Attributes:
   - zone_name
   - group_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddZoneIntoGroupReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 2)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class DropZoneFromGroupReq:
  """
  Attributes:
   - zone_name
   - group_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropZoneFromGroupReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 2)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetGroupReq:
  """
  Attributes:
   - group_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetGroupReq')
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 1)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetGroupResp:
  """
  Attributes:
   - code
   - leader
   - zone_names
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.zone_names = []
          (_etype462, _size459) = iprot.readListBegin()
          if _size459 >= 0:
            for _i463 in six.moves.range(_size459):
              _elem464 = iprot.readString()
              self.zone_names.append(_elem464)
          else: 
            while iprot.peekList():
              _elem465 = iprot.readString()
              self.zone_names.append(_elem465)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetGroupResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.zone_names != None:
      oprot.writeFieldBegin('zone_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.zone_names))
      for iter466 in self.zone_names:
        oprot.writeString(iter466)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.zone_names is not None:
      value = pprint.pformat(self.zone_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_names=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListGroupsReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListGroupsReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Group:
  """
  Attributes:
   - group_name
   - zone_names
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.group_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.zone_names = []
          (_etype470, _size467) = iprot.readListBegin()
          if _size467 >= 0:
            for _i471 in six.moves.range(_size467):
              _elem472 = iprot.readString()
              self.zone_names.append(_elem472)
          else: 
            while iprot.peekList():
              _elem473 = iprot.readString()
              self.zone_names.append(_elem473)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Group')
    if self.group_name != None:
      oprot.writeFieldBegin('group_name', TType.STRING, 1)
      oprot.writeString(self.group_name)
      oprot.writeFieldEnd()
    if self.zone_names != None:
      oprot.writeFieldBegin('zone_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.zone_names))
      for iter474 in self.zone_names:
        oprot.writeString(iter474)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.group_name is not None:
      value = pprint.pformat(self.group_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    group_name=%s' % (value))
    if self.zone_names is not None:
      value = pprint.pformat(self.zone_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_names=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListGroupsResp:
  """
  Attributes:
   - code
   - leader
   - groups
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.groups = []
          (_etype478, _size475) = iprot.readListBegin()
          if _size475 >= 0:
            for _i479 in six.moves.range(_size475):
              _elem480 = Group()
              _elem480.read(iprot)
              self.groups.append(_elem480)
          else: 
            while iprot.peekList():
              _elem481 = Group()
              _elem481.read(iprot)
              self.groups.append(_elem481)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListGroupsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.groups != None:
      oprot.writeFieldBegin('groups', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.groups))
      for iter482 in self.groups:
        iter482.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.groups is not None:
      value = pprint.pformat(self.groups, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    groups=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddListenerReq:
  """
  Attributes:
   - space_id
   - type
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype486, _size483) = iprot.readListBegin()
          if _size483 >= 0:
            for _i487 in six.moves.range(_size483):
              _elem488 = nebula2.common.ttypes.HostAddr()
              _elem488.read(iprot)
              self.hosts.append(_elem488)
          else: 
            while iprot.peekList():
              _elem489 = nebula2.common.ttypes.HostAddr()
              _elem489.read(iprot)
              self.hosts.append(_elem489)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddListenerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter490 in self.hosts:
        iter490.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemoveListenerReq:
  """
  Attributes:
   - space_id
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveListenerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListListenerReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListListenerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListenerInfo:
  """
  Attributes:
   - type
   - host
   - part_id
   - status
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula2.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListenerInfo')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 3)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListListenerResp:
  """
  Attributes:
   - code
   - leader
   - listeners
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.listeners = []
          (_etype494, _size491) = iprot.readListBegin()
          if _size491 >= 0:
            for _i495 in six.moves.range(_size491):
              _elem496 = ListenerInfo()
              _elem496.read(iprot)
              self.listeners.append(_elem496)
          else: 
            while iprot.peekList():
              _elem497 = ListenerInfo()
              _elem497.read(iprot)
              self.listeners.append(_elem497)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListListenerResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.listeners != None:
      oprot.writeFieldBegin('listeners', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.listeners))
      for iter498 in self.listeners:
        iter498.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.listeners is not None:
      value = pprint.pformat(self.listeners, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listeners=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetStatisReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetStatisReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetStatisResp:
  """
  Attributes:
   - code
   - leader
   - statis
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.statis = StatisItem()
          self.statis.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetStatisResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.statis != None:
      oprot.writeFieldBegin('statis', TType.STRUCT, 3)
      self.statis.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.statis is not None:
      value = pprint.pformat(self.statis, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    statis=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CheckpointInfo:
  """
  Attributes:
   - host
   - checkpoint_dir
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host = nebula2.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.checkpoint_dir = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckpointInfo')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 1)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.checkpoint_dir != None:
      oprot.writeFieldBegin('checkpoint_dir', TType.STRING, 2)
      oprot.writeString(self.checkpoint_dir)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.checkpoint_dir is not None:
      value = pprint.pformat(self.checkpoint_dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    checkpoint_dir=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SpaceBackupInfo:
  """
  Attributes:
   - space
   - partition_info
   - cp_dirs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.space = SpaceDesc()
          self.space.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.partition_info = nebula2.common.ttypes.PartitionBackupInfo()
          self.partition_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.cp_dirs = []
          (_etype502, _size499) = iprot.readListBegin()
          if _size499 >= 0:
            for _i503 in six.moves.range(_size499):
              _elem504 = CheckpointInfo()
              _elem504.read(iprot)
              self.cp_dirs.append(_elem504)
          else: 
            while iprot.peekList():
              _elem505 = CheckpointInfo()
              _elem505.read(iprot)
              self.cp_dirs.append(_elem505)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SpaceBackupInfo')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.STRUCT, 1)
      self.space.write(oprot)
      oprot.writeFieldEnd()
    if self.partition_info != None:
      oprot.writeFieldBegin('partition_info', TType.STRUCT, 2)
      self.partition_info.write(oprot)
      oprot.writeFieldEnd()
    if self.cp_dirs != None:
      oprot.writeFieldBegin('cp_dirs', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.cp_dirs))
      for iter506 in self.cp_dirs:
        iter506.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.partition_info is not None:
      value = pprint.pformat(self.partition_info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    partition_info=%s' % (value))
    if self.cp_dirs is not None:
      value = pprint.pformat(self.cp_dirs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cp_dirs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BackupMeta:
  """
  Attributes:
   - backup_info
   - meta_files
   - backup_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.backup_info = {}
          (_ktype508, _vtype509, _size507 ) = iprot.readMapBegin() 
          if _size507 >= 0:
            for _i511 in six.moves.range(_size507):
              _key512 = iprot.readI32()
              _val513 = SpaceBackupInfo()
              _val513.read(iprot)
              self.backup_info[_key512] = _val513
          else: 
            while iprot.peekMap():
              _key514 = iprot.readI32()
              _val515 = SpaceBackupInfo()
              _val515.read(iprot)
              self.backup_info[_key514] = _val515
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.meta_files = []
          (_etype519, _size516) = iprot.readListBegin()
          if _size516 >= 0:
            for _i520 in six.moves.range(_size516):
              _elem521 = iprot.readString()
              self.meta_files.append(_elem521)
          else: 
            while iprot.peekList():
              _elem522 = iprot.readString()
              self.meta_files.append(_elem522)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.backup_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BackupMeta')
    if self.backup_info != None:
      oprot.writeFieldBegin('backup_info', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.backup_info))
      for kiter523,viter524 in self.backup_info.items():
        oprot.writeI32(kiter523)
        viter524.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.meta_files != None:
      oprot.writeFieldBegin('meta_files', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.meta_files))
      for iter525 in self.meta_files:
        oprot.writeString(iter525)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.backup_name != None:
      oprot.writeFieldBegin('backup_name', TType.STRING, 3)
      oprot.writeString(self.backup_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.backup_info is not None:
      value = pprint.pformat(self.backup_info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    backup_info=%s' % (value))
    if self.meta_files is not None:
      value = pprint.pformat(self.meta_files, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    meta_files=%s' % (value))
    if self.backup_name is not None:
      value = pprint.pformat(self.backup_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    backup_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateBackupReq:
  """
  Attributes:
   - spaces
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.spaces = []
          (_etype529, _size526) = iprot.readListBegin()
          if _size526 >= 0:
            for _i530 in six.moves.range(_size526):
              _elem531 = iprot.readString()
              self.spaces.append(_elem531)
          else: 
            while iprot.peekList():
              _elem532 = iprot.readString()
              self.spaces.append(_elem532)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateBackupReq')
    if self.spaces != None:
      oprot.writeFieldBegin('spaces', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.spaces))
      for iter533 in self.spaces:
        oprot.writeString(iter533)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.spaces is not None:
      value = pprint.pformat(self.spaces, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    spaces=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateBackupResp:
  """
  Attributes:
   - code
   - leader
   - meta
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.meta = BackupMeta()
          self.meta.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateBackupResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.meta != None:
      oprot.writeFieldBegin('meta', TType.STRUCT, 3)
      self.meta.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.meta is not None:
      value = pprint.pformat(self.meta, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    meta=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class HostPair:
  """
  Attributes:
   - from_host
   - to_host
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.from_host = nebula2.common.ttypes.HostAddr()
          self.from_host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.to_host = nebula2.common.ttypes.HostAddr()
          self.to_host.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostPair')
    if self.from_host != None:
      oprot.writeFieldBegin('from_host', TType.STRUCT, 1)
      self.from_host.write(oprot)
      oprot.writeFieldEnd()
    if self.to_host != None:
      oprot.writeFieldBegin('to_host', TType.STRUCT, 2)
      self.to_host.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.from_host is not None:
      value = pprint.pformat(self.from_host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    from_host=%s' % (value))
    if self.to_host is not None:
      value = pprint.pformat(self.to_host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    to_host=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RestoreMetaReq:
  """
  Attributes:
   - files
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.files = []
          (_etype537, _size534) = iprot.readListBegin()
          if _size534 >= 0:
            for _i538 in six.moves.range(_size534):
              _elem539 = iprot.readString()
              self.files.append(_elem539)
          else: 
            while iprot.peekList():
              _elem540 = iprot.readString()
              self.files.append(_elem540)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype544, _size541) = iprot.readListBegin()
          if _size541 >= 0:
            for _i545 in six.moves.range(_size541):
              _elem546 = HostPair()
              _elem546.read(iprot)
              self.hosts.append(_elem546)
          else: 
            while iprot.peekList():
              _elem547 = HostPair()
              _elem547.read(iprot)
              self.hosts.append(_elem547)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RestoreMetaReq')
    if self.files != None:
      oprot.writeFieldBegin('files', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.files))
      for iter548 in self.files:
        oprot.writeString(iter548)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter549 in self.hosts:
        iter549.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.files is not None:
      value = pprint.pformat(self.files, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    files=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class FTClient:
  """
  Attributes:
   - host
   - user
   - pwd
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host = nebula2.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.host == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'host' was not found in serialized data! Struct: FTClient")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FTClient')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 1)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.user != None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.pwd != None:
      oprot.writeFieldBegin('pwd', TType.STRING, 3)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.user is not None:
      value = pprint.pformat(self.user, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user=%s' % (value))
    if self.pwd is not None:
      value = pprint.pformat(self.pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    pwd=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SignInFTServiceReq:
  """
  Attributes:
   - type
   - clients
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.clients = []
          (_etype553, _size550) = iprot.readListBegin()
          if _size550 >= 0:
            for _i554 in six.moves.range(_size550):
              _elem555 = FTClient()
              _elem555.read(iprot)
              self.clients.append(_elem555)
          else: 
            while iprot.peekList():
              _elem556 = FTClient()
              _elem556.read(iprot)
              self.clients.append(_elem556)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SignInFTServiceReq')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.clients != None:
      oprot.writeFieldBegin('clients', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.clients))
      for iter557 in self.clients:
        iter557.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.clients is not None:
      value = pprint.pformat(self.clients, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clients=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SignOutFTServiceReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SignOutFTServiceReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListFTClientsReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListFTClientsReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListFTClientsResp:
  """
  Attributes:
   - code
   - leader
   - clients
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.clients = []
          (_etype561, _size558) = iprot.readListBegin()
          if _size558 >= 0:
            for _i562 in six.moves.range(_size558):
              _elem563 = FTClient()
              _elem563.read(iprot)
              self.clients.append(_elem563)
          else: 
            while iprot.peekList():
              _elem564 = FTClient()
              _elem564.read(iprot)
              self.clients.append(_elem564)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListFTClientsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.clients != None:
      oprot.writeFieldBegin('clients', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.clients))
      for iter565 in self.clients:
        iter565.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.clients is not None:
      value = pprint.pformat(self.clients, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clients=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Session:
  """
  Attributes:
   - session_id
   - create_time
   - update_time
   - user_name
   - space_name
   - graph_addr
   - timezone
   - client_ip
   - configs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.create_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.update_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.graph_addr = nebula2.common.ttypes.HostAddr()
          self.graph_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.timezone = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.configs = {}
          (_ktype567, _vtype568, _size566 ) = iprot.readMapBegin() 
          if _size566 >= 0:
            for _i570 in six.moves.range(_size566):
              _key571 = iprot.readString()
              _val572 = nebula2.common.ttypes.Value()
              _val572.read(iprot)
              self.configs[_key571] = _val572
          else: 
            while iprot.peekMap():
              _key573 = iprot.readString()
              _val574 = nebula2.common.ttypes.Value()
              _val574.read(iprot)
              self.configs[_key573] = _val574
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Session')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    if self.create_time != None:
      oprot.writeFieldBegin('create_time', TType.I64, 2)
      oprot.writeI64(self.create_time)
      oprot.writeFieldEnd()
    if self.update_time != None:
      oprot.writeFieldBegin('update_time', TType.I64, 3)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    if self.user_name != None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 5)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.graph_addr != None:
      oprot.writeFieldBegin('graph_addr', TType.STRUCT, 6)
      self.graph_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.timezone != None:
      oprot.writeFieldBegin('timezone', TType.I32, 7)
      oprot.writeI32(self.timezone)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 8)
      oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.configs != None:
      oprot.writeFieldBegin('configs', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.configs))
      for kiter575,viter576 in self.configs.items():
        oprot.writeString(kiter575)
        viter576.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    if self.create_time is not None:
      value = pprint.pformat(self.create_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    create_time=%s' % (value))
    if self.update_time is not None:
      value = pprint.pformat(self.update_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    update_time=%s' % (value))
    if self.user_name is not None:
      value = pprint.pformat(self.user_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user_name=%s' % (value))
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.graph_addr is not None:
      value = pprint.pformat(self.graph_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    graph_addr=%s' % (value))
    if self.timezone is not None:
      value = pprint.pformat(self.timezone, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timezone=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.configs is not None:
      value = pprint.pformat(self.configs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    configs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateSessionReq:
  """
  Attributes:
   - user
   - graph_addr
   - client_ip
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.graph_addr = nebula2.common.ttypes.HostAddr()
          self.graph_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSessionReq')
    if self.user != None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.graph_addr != None:
      oprot.writeFieldBegin('graph_addr', TType.STRUCT, 2)
      self.graph_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 3)
      oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.user is not None:
      value = pprint.pformat(self.user, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user=%s' % (value))
    if self.graph_addr is not None:
      value = pprint.pformat(self.graph_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    graph_addr=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class CreateSessionResp:
  """
  Attributes:
   - code
   - leader
   - session
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSessionResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UpdateSessionsReq:
  """
  Attributes:
   - sessions
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.sessions = []
          (_etype580, _size577) = iprot.readListBegin()
          if _size577 >= 0:
            for _i581 in six.moves.range(_size577):
              _elem582 = Session()
              _elem582.read(iprot)
              self.sessions.append(_elem582)
          else: 
            while iprot.peekList():
              _elem583 = Session()
              _elem583.read(iprot)
              self.sessions.append(_elem583)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateSessionsReq')
    if self.sessions != None:
      oprot.writeFieldBegin('sessions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.sessions))
      for iter584 in self.sessions:
        iter584.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessions is not None:
      value = pprint.pformat(self.sessions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessions=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListSessionsReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSessionsReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ListSessionsResp:
  """
  Attributes:
   - code
   - leader
   - sessions
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.sessions = []
          (_etype588, _size585) = iprot.readListBegin()
          if _size585 >= 0:
            for _i589 in six.moves.range(_size585):
              _elem590 = Session()
              _elem590.read(iprot)
              self.sessions.append(_elem590)
          else: 
            while iprot.peekList():
              _elem591 = Session()
              _elem591.read(iprot)
              self.sessions.append(_elem591)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSessionsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.sessions != None:
      oprot.writeFieldBegin('sessions', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.sessions))
      for iter592 in self.sessions:
        iter592.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.sessions is not None:
      value = pprint.pformat(self.sessions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessions=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetSessionReq:
  """
  Attributes:
   - session_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSessionReq')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class GetSessionResp:
  """
  Attributes:
   - code
   - leader
   - session
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula2.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSessionResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RemoveSessionReq:
  """
  Attributes:
   - session_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveSessionReq')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ReportTaskReq:
  """
  Attributes:
   - code
   - job_id
   - task_id
   - statis
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.statis = StatisItem()
          self.statis.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ReportTaskReq')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 2)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 3)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.statis != None:
      oprot.writeFieldBegin('statis', TType.STRUCT, 4)
      self.statis.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.statis is not None:
      value = pprint.pformat(self.statis, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    statis=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

SchemaVer = UnimplementedTypedef()
ClusterID = UnimplementedTypedef()
all_structs.append(ID)
ID.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'tag_id', None, None, 2, ), # 2
  (3, TType.I32, 'edge_type', None, None, 2, ), # 3
  (4, TType.I32, 'index_id', None, None, 2, ), # 4
  (5, TType.I64, 'cluster_id', None, None, 2, ), # 5
)

ID.thrift_struct_annotations = {
}
ID.thrift_field_annotations = {
}

def ID__init__(self, space_id=None, tag_id=None, edge_type=None, index_id=None, cluster_id=None,):
  self.field = 0
  self.value = None
  if space_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = space_id
  if tag_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = tag_id
  if edge_type is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = edge_type
  if index_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = index_id
  if cluster_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = cluster_id

ID.__init__ = ID__init__

all_structs.append(ColumnTypeDef)
ColumnTypeDef.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', PropertyType, None, 0, ), # 1
  (2, TType.I16, 'type_length', None, 0, 1, ), # 2
)

ColumnTypeDef.thrift_struct_annotations = {
}
ColumnTypeDef.thrift_field_annotations = {
}

def ColumnTypeDef__init__(self, type=None, type_length=ColumnTypeDef.thrift_spec[2][4],):
  self.type = type
  self.type_length = type_length

ColumnTypeDef.__init__ = ColumnTypeDef__init__

def ColumnTypeDef__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('type_length', 0)
  self.__dict__ = state

ColumnTypeDef.__getstate__ = lambda self: self.__dict__.copy()
ColumnTypeDef.__setstate__ = ColumnTypeDef__setstate__

all_structs.append(ColumnDef)
ColumnDef.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRUCT, 'type', [ColumnTypeDef, ColumnTypeDef.thrift_spec, False], None, 0, ), # 2
  (3, TType.STRING, 'default_value', False, None, 1, ), # 3
  (4, TType.BOOL, 'nullable', None, False, 1, ), # 4
)

ColumnDef.thrift_struct_annotations = {
}
ColumnDef.thrift_field_annotations = {
}

def ColumnDef__init__(self, name=None, type=None, default_value=None, nullable=ColumnDef.thrift_spec[4][4],):
  self.name = name
  self.type = type
  self.default_value = default_value
  self.nullable = nullable

ColumnDef.__init__ = ColumnDef__init__

def ColumnDef__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('type', None)
  state.setdefault('default_value', None)
  state.setdefault('nullable', False)
  self.__dict__ = state

ColumnDef.__getstate__ = lambda self: self.__dict__.copy()
ColumnDef.__setstate__ = ColumnDef__setstate__

all_structs.append(SchemaProp)
SchemaProp.thrift_spec = (
  None, # 0
  (1, TType.I64, 'ttl_duration', None, None, 1, ), # 1
  (2, TType.STRING, 'ttl_col', False, None, 1, ), # 2
)

SchemaProp.thrift_struct_annotations = {
}
SchemaProp.thrift_field_annotations = {
}

def SchemaProp__init__(self, ttl_duration=None, ttl_col=None,):
  self.ttl_duration = ttl_duration
  self.ttl_col = ttl_col

SchemaProp.__init__ = SchemaProp__init__

def SchemaProp__setstate__(self, state):
  state.setdefault('ttl_duration', None)
  state.setdefault('ttl_col', None)
  self.__dict__ = state

SchemaProp.__getstate__ = lambda self: self.__dict__.copy()
SchemaProp.__setstate__ = SchemaProp__setstate__

all_structs.append(Schema)
Schema.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'columns', (TType.STRUCT,[ColumnDef, ColumnDef.thrift_spec, False]), None, 2, ), # 1
  (2, TType.STRUCT, 'schema_prop', [SchemaProp, SchemaProp.thrift_spec, False], None, 2, ), # 2
)

Schema.thrift_struct_annotations = {
}
Schema.thrift_field_annotations = {
}

def Schema__init__(self, columns=None, schema_prop=None,):
  self.columns = columns
  self.schema_prop = schema_prop

Schema.__init__ = Schema__init__

def Schema__setstate__(self, state):
  state.setdefault('columns', None)
  state.setdefault('schema_prop', None)
  self.__dict__ = state

Schema.__getstate__ = lambda self: self.__dict__.copy()
Schema.__setstate__ = Schema__setstate__

all_structs.append(IdName)
IdName.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [ID, ID.thrift_spec, True], None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

IdName.thrift_struct_annotations = {
}
IdName.thrift_field_annotations = {
}

def IdName__init__(self, id=None, name=None,):
  self.id = id
  self.name = name

IdName.__init__ = IdName__init__

def IdName__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('name', None)
  self.__dict__ = state

IdName.__getstate__ = lambda self: self.__dict__.copy()
IdName.__setstate__ = IdName__setstate__

all_structs.append(SpaceDesc)
SpaceDesc.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
  (2, TType.I32, 'partition_num', None, 0, 2, ), # 2
  (3, TType.I32, 'replica_factor', None, 0, 2, ), # 3
  (4, TType.STRING, 'charset_name', False, None, 2, ), # 4
  (5, TType.STRING, 'collate_name', False, None, 2, ), # 5
  (6, TType.STRUCT, 'vid_type', [ColumnTypeDef, ColumnTypeDef.thrift_spec, False], ColumnTypeDef(**{
    "type" :     7,
    "type_length" : 8,
  }), 2, ), # 6
  (7, TType.STRING, 'group_name', False, None, 1, ), # 7
  (8, TType.I32, 'isolation_level', IsolationLevel, None, 1, ), # 8
)

SpaceDesc.thrift_struct_annotations = {
}
SpaceDesc.thrift_field_annotations = {
}

def SpaceDesc__init__(self, space_name=None, partition_num=SpaceDesc.thrift_spec[2][4], replica_factor=SpaceDesc.thrift_spec[3][4], charset_name=None, collate_name=None, vid_type=SpaceDesc.thrift_spec[6][4], group_name=None, isolation_level=None,):
  self.space_name = space_name
  self.partition_num = partition_num
  self.replica_factor = replica_factor
  self.charset_name = charset_name
  self.collate_name = collate_name
  if vid_type is self.thrift_spec[6][4]:
    vid_type = ColumnTypeDef(**{
    "type" :     7,
    "type_length" : 8,
  })
  self.vid_type = vid_type
  self.group_name = group_name
  self.isolation_level = isolation_level

SpaceDesc.__init__ = SpaceDesc__init__

def SpaceDesc__setstate__(self, state):
  state.setdefault('space_name', None)
  state.setdefault('partition_num', 0)
  state.setdefault('replica_factor', 0)
  state.setdefault('charset_name', None)
  state.setdefault('collate_name', None)
  state.setdefault('vid_type', ColumnTypeDef(**{
    "type" :     7,
    "type_length" : 8,
  }))
  state.setdefault('group_name', None)
  state.setdefault('isolation_level', None)
  self.__dict__ = state

SpaceDesc.__getstate__ = lambda self: self.__dict__.copy()
SpaceDesc.__setstate__ = SpaceDesc__setstate__

all_structs.append(SpaceItem)
SpaceItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRUCT, 'properties', [SpaceDesc, SpaceDesc.thrift_spec, False], None, 2, ), # 2
)

SpaceItem.thrift_struct_annotations = {
}
SpaceItem.thrift_field_annotations = {
}

def SpaceItem__init__(self, space_id=None, properties=None,):
  self.space_id = space_id
  self.properties = properties

SpaceItem.__init__ = SpaceItem__init__

def SpaceItem__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('properties', None)
  self.__dict__ = state

SpaceItem.__getstate__ = lambda self: self.__dict__.copy()
SpaceItem.__setstate__ = SpaceItem__setstate__

all_structs.append(TagItem)
TagItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
  (4, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 4
)

TagItem.thrift_struct_annotations = {
}
TagItem.thrift_field_annotations = {
}

def TagItem__init__(self, tag_id=None, tag_name=None, version=None, schema=None,):
  self.tag_id = tag_id
  self.tag_name = tag_name
  self.version = version
  self.schema = schema

TagItem.__init__ = TagItem__init__

def TagItem__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('version', None)
  state.setdefault('schema', None)
  self.__dict__ = state

TagItem.__getstate__ = lambda self: self.__dict__.copy()
TagItem.__setstate__ = TagItem__setstate__

all_structs.append(AlterSchemaItem)
AlterSchemaItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'op', AlterSchemaOp, None, 2, ), # 1
  (2, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 2
)

AlterSchemaItem.thrift_struct_annotations = {
}
AlterSchemaItem.thrift_field_annotations = {
}

def AlterSchemaItem__init__(self, op=None, schema=None,):
  self.op = op
  self.schema = schema

AlterSchemaItem.__init__ = AlterSchemaItem__init__

def AlterSchemaItem__setstate__(self, state):
  state.setdefault('op', None)
  state.setdefault('schema', None)
  self.__dict__ = state

AlterSchemaItem.__getstate__ = lambda self: self.__dict__.copy()
AlterSchemaItem.__setstate__ = AlterSchemaItem__setstate__

all_structs.append(EdgeItem)
EdgeItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'edge_type', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
  (4, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 4
)

EdgeItem.thrift_struct_annotations = {
}
EdgeItem.thrift_field_annotations = {
}

def EdgeItem__init__(self, edge_type=None, edge_name=None, version=None, schema=None,):
  self.edge_type = edge_type
  self.edge_name = edge_name
  self.version = version
  self.schema = schema

EdgeItem.__init__ = EdgeItem__init__

def EdgeItem__setstate__(self, state):
  state.setdefault('edge_type', None)
  state.setdefault('edge_name', None)
  state.setdefault('version', None)
  state.setdefault('schema', None)
  self.__dict__ = state

EdgeItem.__getstate__ = lambda self: self.__dict__.copy()
EdgeItem.__setstate__ = EdgeItem__setstate__

all_structs.append(SchemaID)
SchemaID.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
)

SchemaID.thrift_struct_annotations = {
}
SchemaID.thrift_field_annotations = {
}

def SchemaID__init__(self, tag_id=None, edge_type=None,):
  self.field = 0
  self.value = None
  if tag_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = tag_id
  if edge_type is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = edge_type

SchemaID.__init__ = SchemaID__init__

all_structs.append(IndexItem)
IndexItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'index_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'schema_id', [SchemaID, SchemaID.thrift_spec, True], None, 2, ), # 3
  (4, TType.STRING, 'schema_name', False, None, 2, ), # 4
  (5, TType.LIST, 'fields', (TType.STRUCT,[ColumnDef, ColumnDef.thrift_spec, False]), None, 2, ), # 5
)

IndexItem.thrift_struct_annotations = {
}
IndexItem.thrift_field_annotations = {
}

def IndexItem__init__(self, index_id=None, index_name=None, schema_id=None, schema_name=None, fields=None,):
  self.index_id = index_id
  self.index_name = index_name
  self.schema_id = schema_id
  self.schema_name = schema_name
  self.fields = fields

IndexItem.__init__ = IndexItem__init__

def IndexItem__setstate__(self, state):
  state.setdefault('index_id', None)
  state.setdefault('index_name', None)
  state.setdefault('schema_id', None)
  state.setdefault('schema_name', None)
  state.setdefault('fields', None)
  self.__dict__ = state

IndexItem.__getstate__ = lambda self: self.__dict__.copy()
IndexItem.__setstate__ = IndexItem__setstate__

all_structs.append(HostItem)
HostItem.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'hostAddr', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'status', HostStatus, None, 2, ), # 2
  (3, TType.MAP, 'leader_parts', (TType.STRING,False,TType.LIST,(TType.I32,None)), None, 2, ), # 3
  (4, TType.MAP, 'all_parts', (TType.STRING,False,TType.LIST,(TType.I32,None)), None, 2, ), # 4
  (5, TType.I32, 'role', HostRole, None, 2, ), # 5
  (6, TType.STRING, 'git_info_sha', False, None, 2, ), # 6
  (7, TType.STRING, 'zone_name', False, None, 1, ), # 7
)

HostItem.thrift_struct_annotations = {
}
HostItem.thrift_field_annotations = {
}

def HostItem__init__(self, hostAddr=None, status=None, leader_parts=None, all_parts=None, role=None, git_info_sha=None, zone_name=None,):
  self.hostAddr = hostAddr
  self.status = status
  self.leader_parts = leader_parts
  self.all_parts = all_parts
  self.role = role
  self.git_info_sha = git_info_sha
  self.zone_name = zone_name

HostItem.__init__ = HostItem__init__

def HostItem__setstate__(self, state):
  state.setdefault('hostAddr', None)
  state.setdefault('status', None)
  state.setdefault('leader_parts', None)
  state.setdefault('all_parts', None)
  state.setdefault('role', None)
  state.setdefault('git_info_sha', None)
  state.setdefault('zone_name', None)
  self.__dict__ = state

HostItem.__getstate__ = lambda self: self.__dict__.copy()
HostItem.__setstate__ = HostItem__setstate__

all_structs.append(UserItem)
UserItem.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.BOOL, 'is_lock', None, None, 2, ), # 2
  (3, TType.I32, 'max_queries_per_hour', None, None, 2, ), # 3
  (4, TType.I32, 'max_updates_per_hour', None, None, 2, ), # 4
  (5, TType.I32, 'max_connections_per_hour', None, None, 2, ), # 5
  (6, TType.I32, 'max_user_connections', None, None, 2, ), # 6
)

UserItem.thrift_struct_annotations = {
}
UserItem.thrift_field_annotations = {
}

def UserItem__init__(self, account=None, is_lock=None, max_queries_per_hour=None, max_updates_per_hour=None, max_connections_per_hour=None, max_user_connections=None,):
  self.account = account
  self.is_lock = is_lock
  self.max_queries_per_hour = max_queries_per_hour
  self.max_updates_per_hour = max_updates_per_hour
  self.max_connections_per_hour = max_connections_per_hour
  self.max_user_connections = max_user_connections

UserItem.__init__ = UserItem__init__

def UserItem__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('is_lock', None)
  state.setdefault('max_queries_per_hour', None)
  state.setdefault('max_updates_per_hour', None)
  state.setdefault('max_connections_per_hour', None)
  state.setdefault('max_user_connections', None)
  self.__dict__ = state

UserItem.__getstate__ = lambda self: self.__dict__.copy()
UserItem.__setstate__ = UserItem__setstate__

all_structs.append(RoleItem)
RoleItem.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'user_id', False, None, 2, ), # 1
  (2, TType.I32, 'space_id', None, None, 2, ), # 2
  (3, TType.I32, 'role_type', RoleType, None, 2, ), # 3
)

RoleItem.thrift_struct_annotations = {
}
RoleItem.thrift_field_annotations = {
}

def RoleItem__init__(self, user_id=None, space_id=None, role_type=None,):
  self.user_id = user_id
  self.space_id = space_id
  self.role_type = role_type

RoleItem.__init__ = RoleItem__init__

def RoleItem__setstate__(self, state):
  state.setdefault('user_id', None)
  state.setdefault('space_id', None)
  state.setdefault('role_type', None)
  self.__dict__ = state

RoleItem.__getstate__ = lambda self: self.__dict__.copy()
RoleItem.__setstate__ = RoleItem__setstate__

all_structs.append(ExecResp)
ExecResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'id', [ID, ID.thrift_spec, True], None, 2, ), # 2
  (3, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

ExecResp.thrift_struct_annotations = {
}
ExecResp.thrift_field_annotations = {
}

def ExecResp__init__(self, code=None, id=None, leader=None,):
  self.code = code
  self.id = id
  self.leader = leader

ExecResp.__init__ = ExecResp__init__

def ExecResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

ExecResp.__getstate__ = lambda self: self.__dict__.copy()
ExecResp.__setstate__ = ExecResp__setstate__

all_structs.append(AdminJobReq)
AdminJobReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'op', AdminJobOp, None, 2, ), # 1
  (2, TType.I32, 'cmd', AdminCmd, None, 2, ), # 2
  (3, TType.LIST, 'paras', (TType.STRING,False), None, 2, ), # 3
)

AdminJobReq.thrift_struct_annotations = {
}
AdminJobReq.thrift_field_annotations = {
}

def AdminJobReq__init__(self, op=None, cmd=None, paras=None,):
  self.op = op
  self.cmd = cmd
  self.paras = paras

AdminJobReq.__init__ = AdminJobReq__init__

def AdminJobReq__setstate__(self, state):
  state.setdefault('op', None)
  state.setdefault('cmd', None)
  state.setdefault('paras', None)
  self.__dict__ = state

AdminJobReq.__getstate__ = lambda self: self.__dict__.copy()
AdminJobReq.__setstate__ = AdminJobReq__setstate__

all_structs.append(JobDesc)
JobDesc.thrift_spec = (
  None, # 0
  (1, TType.I32, 'id', None, None, 2, ), # 1
  (2, TType.I32, 'cmd', AdminCmd, None, 2, ), # 2
  (3, TType.LIST, 'paras', (TType.STRING,True), None, 2, ), # 3
  (4, TType.I32, 'status', JobStatus, None, 2, ), # 4
  (5, TType.I64, 'start_time', None, None, 2, ), # 5
  (6, TType.I64, 'stop_time', None, None, 2, ), # 6
)

JobDesc.thrift_struct_annotations = {
}
JobDesc.thrift_field_annotations = {
}

def JobDesc__init__(self, id=None, cmd=None, paras=None, status=None, start_time=None, stop_time=None,):
  self.id = id
  self.cmd = cmd
  self.paras = paras
  self.status = status
  self.start_time = start_time
  self.stop_time = stop_time

JobDesc.__init__ = JobDesc__init__

def JobDesc__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('cmd', None)
  state.setdefault('paras', None)
  state.setdefault('status', None)
  state.setdefault('start_time', None)
  state.setdefault('stop_time', None)
  self.__dict__ = state

JobDesc.__getstate__ = lambda self: self.__dict__.copy()
JobDesc.__setstate__ = JobDesc__setstate__

all_structs.append(TaskDesc)
TaskDesc.thrift_spec = (
  None, # 0
  (1, TType.I32, 'task_id', None, None, 2, ), # 1
  (2, TType.STRUCT, 'host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'status', JobStatus, None, 2, ), # 3
  (4, TType.I64, 'start_time', None, None, 2, ), # 4
  (5, TType.I64, 'stop_time', None, None, 2, ), # 5
  (6, TType.I32, 'job_id', None, None, 2, ), # 6
)

TaskDesc.thrift_struct_annotations = {
}
TaskDesc.thrift_field_annotations = {
}

def TaskDesc__init__(self, task_id=None, host=None, status=None, start_time=None, stop_time=None, job_id=None,):
  self.task_id = task_id
  self.host = host
  self.status = status
  self.start_time = start_time
  self.stop_time = stop_time
  self.job_id = job_id

TaskDesc.__init__ = TaskDesc__init__

def TaskDesc__setstate__(self, state):
  state.setdefault('task_id', None)
  state.setdefault('host', None)
  state.setdefault('status', None)
  state.setdefault('start_time', None)
  state.setdefault('stop_time', None)
  state.setdefault('job_id', None)
  self.__dict__ = state

TaskDesc.__getstate__ = lambda self: self.__dict__.copy()
TaskDesc.__setstate__ = TaskDesc__setstate__

all_structs.append(AdminJobResult)
AdminJobResult.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_id', None, None, 1, ), # 1
  (2, TType.LIST, 'job_desc', (TType.STRUCT,[JobDesc, JobDesc.thrift_spec, False]), None, 1, ), # 2
  (3, TType.LIST, 'task_desc', (TType.STRUCT,[TaskDesc, TaskDesc.thrift_spec, False]), None, 1, ), # 3
  (4, TType.I32, 'recovered_job_num', None, None, 1, ), # 4
)

AdminJobResult.thrift_struct_annotations = {
}
AdminJobResult.thrift_field_annotations = {
}

def AdminJobResult__init__(self, job_id=None, job_desc=None, task_desc=None, recovered_job_num=None,):
  self.job_id = job_id
  self.job_desc = job_desc
  self.task_desc = task_desc
  self.recovered_job_num = recovered_job_num

AdminJobResult.__init__ = AdminJobResult__init__

def AdminJobResult__setstate__(self, state):
  state.setdefault('job_id', None)
  state.setdefault('job_desc', None)
  state.setdefault('task_desc', None)
  state.setdefault('recovered_job_num', None)
  self.__dict__ = state

AdminJobResult.__getstate__ = lambda self: self.__dict__.copy()
AdminJobResult.__setstate__ = AdminJobResult__setstate__

all_structs.append(AdminJobResp)
AdminJobResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'result', [AdminJobResult, AdminJobResult.thrift_spec, False], None, 2, ), # 3
)

AdminJobResp.thrift_struct_annotations = {
}
AdminJobResp.thrift_field_annotations = {
}

def AdminJobResp__init__(self, code=None, leader=None, result=None,):
  self.code = code
  self.leader = leader
  self.result = result

AdminJobResp.__init__ = AdminJobResp__init__

def AdminJobResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('result', None)
  self.__dict__ = state

AdminJobResp.__getstate__ = lambda self: self.__dict__.copy()
AdminJobResp.__setstate__ = AdminJobResp__setstate__

all_structs.append(Correlativity)
Correlativity.thrift_spec = (
  None, # 0
  (1, TType.I32, 'part_id', None, None, 2, ), # 1
  (2, TType.DOUBLE, 'proportion', None, None, 2, ), # 2
)

Correlativity.thrift_struct_annotations = {
}
Correlativity.thrift_field_annotations = {
}

def Correlativity__init__(self, part_id=None, proportion=None,):
  self.part_id = part_id
  self.proportion = proportion

Correlativity.__init__ = Correlativity__init__

def Correlativity__setstate__(self, state):
  state.setdefault('part_id', None)
  state.setdefault('proportion', None)
  self.__dict__ = state

Correlativity.__getstate__ = lambda self: self.__dict__.copy()
Correlativity.__setstate__ = Correlativity__setstate__

all_structs.append(StatisItem)
StatisItem.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'tag_vertices', (TType.STRING,False,TType.I64,None), None, 2, ), # 1
  (2, TType.MAP, 'edges', (TType.STRING,False,TType.I64,None), None, 2, ), # 2
  (3, TType.I64, 'space_vertices', None, None, 2, ), # 3
  (4, TType.I64, 'space_edges', None, None, 2, ), # 4
  (5, TType.MAP, 'part_corelativity', (TType.I32,None,TType.LIST,(TType.STRUCT,[Correlativity, Correlativity.thrift_spec, False])), None, 2, ), # 5
  (6, TType.I32, 'status', JobStatus, None, 2, ), # 6
)

StatisItem.thrift_struct_annotations = {
}
StatisItem.thrift_field_annotations = {
}

def StatisItem__init__(self, tag_vertices=None, edges=None, space_vertices=None, space_edges=None, part_corelativity=None, status=None,):
  self.tag_vertices = tag_vertices
  self.edges = edges
  self.space_vertices = space_vertices
  self.space_edges = space_edges
  self.part_corelativity = part_corelativity
  self.status = status

StatisItem.__init__ = StatisItem__init__

def StatisItem__setstate__(self, state):
  state.setdefault('tag_vertices', None)
  state.setdefault('edges', None)
  state.setdefault('space_vertices', None)
  state.setdefault('space_edges', None)
  state.setdefault('part_corelativity', None)
  state.setdefault('status', None)
  self.__dict__ = state

StatisItem.__getstate__ = lambda self: self.__dict__.copy()
StatisItem.__setstate__ = StatisItem__setstate__

all_structs.append(CreateSpaceReq)
CreateSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'properties', [SpaceDesc, SpaceDesc.thrift_spec, False], None, 2, ), # 1
  (2, TType.BOOL, 'if_not_exists', None, None, 2, ), # 2
)

CreateSpaceReq.thrift_struct_annotations = {
}
CreateSpaceReq.thrift_field_annotations = {
}

def CreateSpaceReq__init__(self, properties=None, if_not_exists=None,):
  self.properties = properties
  self.if_not_exists = if_not_exists

CreateSpaceReq.__init__ = CreateSpaceReq__init__

def CreateSpaceReq__setstate__(self, state):
  state.setdefault('properties', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
CreateSpaceReq.__setstate__ = CreateSpaceReq__setstate__

all_structs.append(DropSpaceReq)
DropSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
  (2, TType.BOOL, 'if_exists', None, None, 2, ), # 2
)

DropSpaceReq.thrift_struct_annotations = {
}
DropSpaceReq.thrift_field_annotations = {
}

def DropSpaceReq__init__(self, space_name=None, if_exists=None,):
  self.space_name = space_name
  self.if_exists = if_exists

DropSpaceReq.__init__ = DropSpaceReq__init__

def DropSpaceReq__setstate__(self, state):
  state.setdefault('space_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
DropSpaceReq.__setstate__ = DropSpaceReq__setstate__

all_structs.append(ListSpacesReq)
ListSpacesReq.thrift_spec = (
)

ListSpacesReq.thrift_struct_annotations = {
}
ListSpacesReq.thrift_field_annotations = {
}

all_structs.append(ListSpacesResp)
ListSpacesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'spaces', (TType.STRUCT,[IdName, IdName.thrift_spec, False]), None, 2, ), # 3
)

ListSpacesResp.thrift_struct_annotations = {
}
ListSpacesResp.thrift_field_annotations = {
}

def ListSpacesResp__init__(self, code=None, leader=None, spaces=None,):
  self.code = code
  self.leader = leader
  self.spaces = spaces

ListSpacesResp.__init__ = ListSpacesResp__init__

def ListSpacesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('spaces', None)
  self.__dict__ = state

ListSpacesResp.__getstate__ = lambda self: self.__dict__.copy()
ListSpacesResp.__setstate__ = ListSpacesResp__setstate__

all_structs.append(GetSpaceReq)
GetSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
)

GetSpaceReq.thrift_struct_annotations = {
}
GetSpaceReq.thrift_field_annotations = {
}

def GetSpaceReq__init__(self, space_name=None,):
  self.space_name = space_name

GetSpaceReq.__init__ = GetSpaceReq__init__

def GetSpaceReq__setstate__(self, state):
  state.setdefault('space_name', None)
  self.__dict__ = state

GetSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
GetSpaceReq.__setstate__ = GetSpaceReq__setstate__

all_structs.append(GetSpaceResp)
GetSpaceResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'item', [SpaceItem, SpaceItem.thrift_spec, False], None, 2, ), # 3
)

GetSpaceResp.thrift_struct_annotations = {
}
GetSpaceResp.thrift_field_annotations = {
}

def GetSpaceResp__init__(self, code=None, leader=None, item=None,):
  self.code = code
  self.leader = leader
  self.item = item

GetSpaceResp.__init__ = GetSpaceResp__init__

def GetSpaceResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('item', None)
  self.__dict__ = state

GetSpaceResp.__getstate__ = lambda self: self.__dict__.copy()
GetSpaceResp.__setstate__ = GetSpaceResp__setstate__

all_structs.append(CreateTagReq)
CreateTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
)

CreateTagReq.thrift_struct_annotations = {
}
CreateTagReq.thrift_field_annotations = {
}

def CreateTagReq__init__(self, space_id=None, tag_name=None, schema=None, if_not_exists=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.schema = schema
  self.if_not_exists = if_not_exists

CreateTagReq.__init__ = CreateTagReq__init__

def CreateTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('schema', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateTagReq.__getstate__ = lambda self: self.__dict__.copy()
CreateTagReq.__setstate__ = CreateTagReq__setstate__

all_structs.append(AlterTagReq)
AlterTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.LIST, 'tag_items', (TType.STRUCT,[AlterSchemaItem, AlterSchemaItem.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'schema_prop', [SchemaProp, SchemaProp.thrift_spec, False], None, 2, ), # 4
)

AlterTagReq.thrift_struct_annotations = {
}
AlterTagReq.thrift_field_annotations = {
}

def AlterTagReq__init__(self, space_id=None, tag_name=None, tag_items=None, schema_prop=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.tag_items = tag_items
  self.schema_prop = schema_prop

AlterTagReq.__init__ = AlterTagReq__init__

def AlterTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('tag_items', None)
  state.setdefault('schema_prop', None)
  self.__dict__ = state

AlterTagReq.__getstate__ = lambda self: self.__dict__.copy()
AlterTagReq.__setstate__ = AlterTagReq__setstate__

all_structs.append(DropTagReq)
DropTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropTagReq.thrift_struct_annotations = {
}
DropTagReq.thrift_field_annotations = {
}

def DropTagReq__init__(self, space_id=None, tag_name=None, if_exists=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.if_exists = if_exists

DropTagReq.__init__ = DropTagReq__init__

def DropTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropTagReq.__getstate__ = lambda self: self.__dict__.copy()
DropTagReq.__setstate__ = DropTagReq__setstate__

all_structs.append(ListTagsReq)
ListTagsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListTagsReq.thrift_struct_annotations = {
}
ListTagsReq.thrift_field_annotations = {
}

def ListTagsReq__init__(self, space_id=None,):
  self.space_id = space_id

ListTagsReq.__init__ = ListTagsReq__init__

def ListTagsReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListTagsReq.__getstate__ = lambda self: self.__dict__.copy()
ListTagsReq.__setstate__ = ListTagsReq__setstate__

all_structs.append(ListTagsResp)
ListTagsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'tags', (TType.STRUCT,[TagItem, TagItem.thrift_spec, False]), None, 2, ), # 3
)

ListTagsResp.thrift_struct_annotations = {
}
ListTagsResp.thrift_field_annotations = {
}

def ListTagsResp__init__(self, code=None, leader=None, tags=None,):
  self.code = code
  self.leader = leader
  self.tags = tags

ListTagsResp.__init__ = ListTagsResp__init__

def ListTagsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('tags', None)
  self.__dict__ = state

ListTagsResp.__getstate__ = lambda self: self.__dict__.copy()
ListTagsResp.__setstate__ = ListTagsResp__setstate__

all_structs.append(GetTagReq)
GetTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
)

GetTagReq.thrift_struct_annotations = {
}
GetTagReq.thrift_field_annotations = {
}

def GetTagReq__init__(self, space_id=None, tag_name=None, version=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.version = version

GetTagReq.__init__ = GetTagReq__init__

def GetTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('version', None)
  self.__dict__ = state

GetTagReq.__getstate__ = lambda self: self.__dict__.copy()
GetTagReq.__setstate__ = GetTagReq__setstate__

all_structs.append(GetTagResp)
GetTagResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
)

GetTagResp.thrift_struct_annotations = {
}
GetTagResp.thrift_field_annotations = {
}

def GetTagResp__init__(self, code=None, leader=None, schema=None,):
  self.code = code
  self.leader = leader
  self.schema = schema

GetTagResp.__init__ = GetTagResp__init__

def GetTagResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('schema', None)
  self.__dict__ = state

GetTagResp.__getstate__ = lambda self: self.__dict__.copy()
GetTagResp.__setstate__ = GetTagResp__setstate__

all_structs.append(CreateEdgeReq)
CreateEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
)

CreateEdgeReq.thrift_struct_annotations = {
}
CreateEdgeReq.thrift_field_annotations = {
}

def CreateEdgeReq__init__(self, space_id=None, edge_name=None, schema=None, if_not_exists=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.schema = schema
  self.if_not_exists = if_not_exists

CreateEdgeReq.__init__ = CreateEdgeReq__init__

def CreateEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('schema', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
CreateEdgeReq.__setstate__ = CreateEdgeReq__setstate__

all_structs.append(AlterEdgeReq)
AlterEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.LIST, 'edge_items', (TType.STRUCT,[AlterSchemaItem, AlterSchemaItem.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'schema_prop', [SchemaProp, SchemaProp.thrift_spec, False], None, 2, ), # 4
)

AlterEdgeReq.thrift_struct_annotations = {
}
AlterEdgeReq.thrift_field_annotations = {
}

def AlterEdgeReq__init__(self, space_id=None, edge_name=None, edge_items=None, schema_prop=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.edge_items = edge_items
  self.schema_prop = schema_prop

AlterEdgeReq.__init__ = AlterEdgeReq__init__

def AlterEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('edge_items', None)
  state.setdefault('schema_prop', None)
  self.__dict__ = state

AlterEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
AlterEdgeReq.__setstate__ = AlterEdgeReq__setstate__

all_structs.append(GetEdgeReq)
GetEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
)

GetEdgeReq.thrift_struct_annotations = {
}
GetEdgeReq.thrift_field_annotations = {
}

def GetEdgeReq__init__(self, space_id=None, edge_name=None, version=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.version = version

GetEdgeReq.__init__ = GetEdgeReq__init__

def GetEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('version', None)
  self.__dict__ = state

GetEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeReq.__setstate__ = GetEdgeReq__setstate__

all_structs.append(GetEdgeResp)
GetEdgeResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
)

GetEdgeResp.thrift_struct_annotations = {
}
GetEdgeResp.thrift_field_annotations = {
}

def GetEdgeResp__init__(self, code=None, leader=None, schema=None,):
  self.code = code
  self.leader = leader
  self.schema = schema

GetEdgeResp.__init__ = GetEdgeResp__init__

def GetEdgeResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('schema', None)
  self.__dict__ = state

GetEdgeResp.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeResp.__setstate__ = GetEdgeResp__setstate__

all_structs.append(DropEdgeReq)
DropEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropEdgeReq.thrift_struct_annotations = {
}
DropEdgeReq.thrift_field_annotations = {
}

def DropEdgeReq__init__(self, space_id=None, edge_name=None, if_exists=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.if_exists = if_exists

DropEdgeReq.__init__ = DropEdgeReq__init__

def DropEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
DropEdgeReq.__setstate__ = DropEdgeReq__setstate__

all_structs.append(ListEdgesReq)
ListEdgesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListEdgesReq.thrift_struct_annotations = {
}
ListEdgesReq.thrift_field_annotations = {
}

def ListEdgesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListEdgesReq.__init__ = ListEdgesReq__init__

def ListEdgesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListEdgesReq.__getstate__ = lambda self: self.__dict__.copy()
ListEdgesReq.__setstate__ = ListEdgesReq__setstate__

all_structs.append(ListEdgesResp)
ListEdgesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'edges', (TType.STRUCT,[EdgeItem, EdgeItem.thrift_spec, False]), None, 2, ), # 3
)

ListEdgesResp.thrift_struct_annotations = {
}
ListEdgesResp.thrift_field_annotations = {
}

def ListEdgesResp__init__(self, code=None, leader=None, edges=None,):
  self.code = code
  self.leader = leader
  self.edges = edges

ListEdgesResp.__init__ = ListEdgesResp__init__

def ListEdgesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('edges', None)
  self.__dict__ = state

ListEdgesResp.__getstate__ = lambda self: self.__dict__.copy()
ListEdgesResp.__setstate__ = ListEdgesResp__setstate__

all_structs.append(ListHostsReq)
ListHostsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ListHostType, None, 2, ), # 1
)

ListHostsReq.thrift_struct_annotations = {
}
ListHostsReq.thrift_field_annotations = {
}

def ListHostsReq__init__(self, type=None,):
  self.type = type

ListHostsReq.__init__ = ListHostsReq__init__

def ListHostsReq__setstate__(self, state):
  state.setdefault('type', None)
  self.__dict__ = state

ListHostsReq.__getstate__ = lambda self: self.__dict__.copy()
ListHostsReq.__setstate__ = ListHostsReq__setstate__

all_structs.append(ListHostsResp)
ListHostsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'hosts', (TType.STRUCT,[HostItem, HostItem.thrift_spec, False]), None, 2, ), # 3
)

ListHostsResp.thrift_struct_annotations = {
}
ListHostsResp.thrift_field_annotations = {
}

def ListHostsResp__init__(self, code=None, leader=None, hosts=None,):
  self.code = code
  self.leader = leader
  self.hosts = hosts

ListHostsResp.__init__ = ListHostsResp__init__

def ListHostsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

ListHostsResp.__getstate__ = lambda self: self.__dict__.copy()
ListHostsResp.__setstate__ = ListHostsResp__setstate__

all_structs.append(PartItem)
PartItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'part_id', None, None, 0, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 0, ), # 3
  (4, TType.LIST, 'losts', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 0, ), # 4
)

PartItem.thrift_struct_annotations = {
}
PartItem.thrift_field_annotations = {
}

def PartItem__init__(self, part_id=None, leader=None, peers=None, losts=None,):
  self.part_id = part_id
  self.leader = leader
  self.peers = peers
  self.losts = losts

PartItem.__init__ = PartItem__init__

def PartItem__setstate__(self, state):
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  state.setdefault('peers', None)
  state.setdefault('losts', None)
  self.__dict__ = state

PartItem.__getstate__ = lambda self: self.__dict__.copy()
PartItem.__setstate__ = PartItem__setstate__

all_structs.append(ListPartsReq)
ListPartsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'part_ids', (TType.I32,None), None, 2, ), # 2
)

ListPartsReq.thrift_struct_annotations = {
}
ListPartsReq.thrift_field_annotations = {
}

def ListPartsReq__init__(self, space_id=None, part_ids=None,):
  self.space_id = space_id
  self.part_ids = part_ids

ListPartsReq.__init__ = ListPartsReq__init__

def ListPartsReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_ids', None)
  self.__dict__ = state

ListPartsReq.__getstate__ = lambda self: self.__dict__.copy()
ListPartsReq.__setstate__ = ListPartsReq__setstate__

all_structs.append(ListPartsResp)
ListPartsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'parts', (TType.STRUCT,[PartItem, PartItem.thrift_spec, False]), None, 2, ), # 3
)

ListPartsResp.thrift_struct_annotations = {
}
ListPartsResp.thrift_field_annotations = {
}

def ListPartsResp__init__(self, code=None, leader=None, parts=None,):
  self.code = code
  self.leader = leader
  self.parts = parts

ListPartsResp.__init__ = ListPartsResp__init__

def ListPartsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('parts', None)
  self.__dict__ = state

ListPartsResp.__getstate__ = lambda self: self.__dict__.copy()
ListPartsResp.__setstate__ = ListPartsResp__setstate__

all_structs.append(GetPartsAllocReq)
GetPartsAllocReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

GetPartsAllocReq.thrift_struct_annotations = {
}
GetPartsAllocReq.thrift_field_annotations = {
}

def GetPartsAllocReq__init__(self, space_id=None,):
  self.space_id = space_id

GetPartsAllocReq.__init__ = GetPartsAllocReq__init__

def GetPartsAllocReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

GetPartsAllocReq.__getstate__ = lambda self: self.__dict__.copy()
GetPartsAllocReq.__setstate__ = GetPartsAllocReq__setstate__

all_structs.append(GetPartsAllocResp)
GetPartsAllocResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False])), None, 2, ), # 3
)

GetPartsAllocResp.thrift_struct_annotations = {
}
GetPartsAllocResp.thrift_field_annotations = {
}

def GetPartsAllocResp__init__(self, code=None, leader=None, parts=None,):
  self.code = code
  self.leader = leader
  self.parts = parts

GetPartsAllocResp.__init__ = GetPartsAllocResp__init__

def GetPartsAllocResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('parts', None)
  self.__dict__ = state

GetPartsAllocResp.__getstate__ = lambda self: self.__dict__.copy()
GetPartsAllocResp.__setstate__ = GetPartsAllocResp__setstate__

all_structs.append(MultiPutReq)
MultiPutReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.LIST, 'pairs', (TType.STRUCT,[nebula2.common.ttypes.KeyValue, nebula2.common.ttypes.KeyValue.thrift_spec, False]), None, 2, ), # 2
)

MultiPutReq.thrift_struct_annotations = {
}
MultiPutReq.thrift_field_annotations = {
}

def MultiPutReq__init__(self, segment=None, pairs=None,):
  self.segment = segment
  self.pairs = pairs

MultiPutReq.__init__ = MultiPutReq__init__

def MultiPutReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('pairs', None)
  self.__dict__ = state

MultiPutReq.__getstate__ = lambda self: self.__dict__.copy()
MultiPutReq.__setstate__ = MultiPutReq__setstate__

all_structs.append(GetReq)
GetReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'key', False, None, 2, ), # 2
)

GetReq.thrift_struct_annotations = {
}
GetReq.thrift_field_annotations = {
}

def GetReq__init__(self, segment=None, key=None,):
  self.segment = segment
  self.key = key

GetReq.__init__ = GetReq__init__

def GetReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('key', None)
  self.__dict__ = state

GetReq.__getstate__ = lambda self: self.__dict__.copy()
GetReq.__setstate__ = GetReq__setstate__

all_structs.append(GetResp)
GetResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'value', False, None, 2, ), # 3
)

GetResp.thrift_struct_annotations = {
}
GetResp.thrift_field_annotations = {
}

def GetResp__init__(self, code=None, leader=None, value=None,):
  self.code = code
  self.leader = leader
  self.value = value

GetResp.__init__ = GetResp__init__

def GetResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('value', None)
  self.__dict__ = state

GetResp.__getstate__ = lambda self: self.__dict__.copy()
GetResp.__setstate__ = GetResp__setstate__

all_structs.append(MultiGetReq)
MultiGetReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.LIST, 'keys', (TType.STRING,False), None, 2, ), # 2
)

MultiGetReq.thrift_struct_annotations = {
}
MultiGetReq.thrift_field_annotations = {
}

def MultiGetReq__init__(self, segment=None, keys=None,):
  self.segment = segment
  self.keys = keys

MultiGetReq.__init__ = MultiGetReq__init__

def MultiGetReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('keys', None)
  self.__dict__ = state

MultiGetReq.__getstate__ = lambda self: self.__dict__.copy()
MultiGetReq.__setstate__ = MultiGetReq__setstate__

all_structs.append(MultiGetResp)
MultiGetResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'values', (TType.STRING,False), None, 2, ), # 3
)

MultiGetResp.thrift_struct_annotations = {
}
MultiGetResp.thrift_field_annotations = {
}

def MultiGetResp__init__(self, code=None, leader=None, values=None,):
  self.code = code
  self.leader = leader
  self.values = values

MultiGetResp.__init__ = MultiGetResp__init__

def MultiGetResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('values', None)
  self.__dict__ = state

MultiGetResp.__getstate__ = lambda self: self.__dict__.copy()
MultiGetResp.__setstate__ = MultiGetResp__setstate__

all_structs.append(RemoveReq)
RemoveReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'key', False, None, 2, ), # 2
)

RemoveReq.thrift_struct_annotations = {
}
RemoveReq.thrift_field_annotations = {
}

def RemoveReq__init__(self, segment=None, key=None,):
  self.segment = segment
  self.key = key

RemoveReq.__init__ = RemoveReq__init__

def RemoveReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('key', None)
  self.__dict__ = state

RemoveReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveReq.__setstate__ = RemoveReq__setstate__

all_structs.append(RemoveRangeReq)
RemoveRangeReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'start', False, None, 2, ), # 2
  (3, TType.STRING, 'end', False, None, 2, ), # 3
)

RemoveRangeReq.thrift_struct_annotations = {
}
RemoveRangeReq.thrift_field_annotations = {
}

def RemoveRangeReq__init__(self, segment=None, start=None, end=None,):
  self.segment = segment
  self.start = start
  self.end = end

RemoveRangeReq.__init__ = RemoveRangeReq__init__

def RemoveRangeReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('start', None)
  state.setdefault('end', None)
  self.__dict__ = state

RemoveRangeReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveRangeReq.__setstate__ = RemoveRangeReq__setstate__

all_structs.append(ScanReq)
ScanReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'start', False, None, 2, ), # 2
  (3, TType.STRING, 'end', False, None, 2, ), # 3
)

ScanReq.thrift_struct_annotations = {
}
ScanReq.thrift_field_annotations = {
}

def ScanReq__init__(self, segment=None, start=None, end=None,):
  self.segment = segment
  self.start = start
  self.end = end

ScanReq.__init__ = ScanReq__init__

def ScanReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('start', None)
  state.setdefault('end', None)
  self.__dict__ = state

ScanReq.__getstate__ = lambda self: self.__dict__.copy()
ScanReq.__setstate__ = ScanReq__setstate__

all_structs.append(ScanResp)
ScanResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'values', (TType.STRING,False), None, 2, ), # 3
)

ScanResp.thrift_struct_annotations = {
}
ScanResp.thrift_field_annotations = {
}

def ScanResp__init__(self, code=None, leader=None, values=None,):
  self.code = code
  self.leader = leader
  self.values = values

ScanResp.__init__ = ScanResp__init__

def ScanResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('values', None)
  self.__dict__ = state

ScanResp.__getstate__ = lambda self: self.__dict__.copy()
ScanResp.__setstate__ = ScanResp__setstate__

all_structs.append(HBResp)
HBResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I64, 'cluster_id', None, None, 2, ), # 3
  (4, TType.I64, 'last_update_time_in_ms', None, None, 2, ), # 4
)

HBResp.thrift_struct_annotations = {
}
HBResp.thrift_field_annotations = {
}

def HBResp__init__(self, code=None, leader=None, cluster_id=None, last_update_time_in_ms=None,):
  self.code = code
  self.leader = leader
  self.cluster_id = cluster_id
  self.last_update_time_in_ms = last_update_time_in_ms

HBResp.__init__ = HBResp__init__

def HBResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('cluster_id', None)
  state.setdefault('last_update_time_in_ms', None)
  self.__dict__ = state

HBResp.__getstate__ = lambda self: self.__dict__.copy()
HBResp.__setstate__ = HBResp__setstate__

all_structs.append(HBReq)
HBReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'role', HostRole, None, 2, ), # 1
  (2, TType.STRUCT, 'host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I64, 'cluster_id', None, None, 2, ), # 3
  (4, TType.MAP, 'leader_partIds', (TType.I32,None,TType.LIST,(TType.I32,None)), None, 1, ), # 4
  (5, TType.STRING, 'git_info_sha', False, None, 2, ), # 5
)

HBReq.thrift_struct_annotations = {
}
HBReq.thrift_field_annotations = {
}

def HBReq__init__(self, role=None, host=None, cluster_id=None, leader_partIds=None, git_info_sha=None,):
  self.role = role
  self.host = host
  self.cluster_id = cluster_id
  self.leader_partIds = leader_partIds
  self.git_info_sha = git_info_sha

HBReq.__init__ = HBReq__init__

def HBReq__setstate__(self, state):
  state.setdefault('role', None)
  state.setdefault('host', None)
  state.setdefault('cluster_id', None)
  state.setdefault('leader_partIds', None)
  state.setdefault('git_info_sha', None)
  self.__dict__ = state

HBReq.__getstate__ = lambda self: self.__dict__.copy()
HBReq.__setstate__ = HBReq__setstate__

all_structs.append(IndexFieldDef)
IndexFieldDef.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.I16, 'type_length', None, None, 1, ), # 2
)

IndexFieldDef.thrift_struct_annotations = {
}
IndexFieldDef.thrift_field_annotations = {
}

def IndexFieldDef__init__(self, name=None, type_length=None,):
  self.name = name
  self.type_length = type_length

IndexFieldDef.__init__ = IndexFieldDef__init__

def IndexFieldDef__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('type_length', None)
  self.__dict__ = state

IndexFieldDef.__getstate__ = lambda self: self.__dict__.copy()
IndexFieldDef.__setstate__ = IndexFieldDef__setstate__

all_structs.append(CreateTagIndexReq)
CreateTagIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.STRING, 'tag_name', False, None, 2, ), # 3
  (4, TType.LIST, 'fields', (TType.STRUCT,[IndexFieldDef, IndexFieldDef.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'if_not_exists', None, None, 2, ), # 5
)

CreateTagIndexReq.thrift_struct_annotations = {
}
CreateTagIndexReq.thrift_field_annotations = {
}

def CreateTagIndexReq__init__(self, space_id=None, index_name=None, tag_name=None, fields=None, if_not_exists=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.tag_name = tag_name
  self.fields = fields
  self.if_not_exists = if_not_exists

CreateTagIndexReq.__init__ = CreateTagIndexReq__init__

def CreateTagIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('tag_name', None)
  state.setdefault('fields', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateTagIndexReq.__getstate__ = lambda self: self.__dict__.copy()
CreateTagIndexReq.__setstate__ = CreateTagIndexReq__setstate__

all_structs.append(DropTagIndexReq)
DropTagIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropTagIndexReq.thrift_struct_annotations = {
}
DropTagIndexReq.thrift_field_annotations = {
}

def DropTagIndexReq__init__(self, space_id=None, index_name=None, if_exists=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.if_exists = if_exists

DropTagIndexReq.__init__ = DropTagIndexReq__init__

def DropTagIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropTagIndexReq.__getstate__ = lambda self: self.__dict__.copy()
DropTagIndexReq.__setstate__ = DropTagIndexReq__setstate__

all_structs.append(GetTagIndexReq)
GetTagIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
)

GetTagIndexReq.thrift_struct_annotations = {
}
GetTagIndexReq.thrift_field_annotations = {
}

def GetTagIndexReq__init__(self, space_id=None, index_name=None,):
  self.space_id = space_id
  self.index_name = index_name

GetTagIndexReq.__init__ = GetTagIndexReq__init__

def GetTagIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  self.__dict__ = state

GetTagIndexReq.__getstate__ = lambda self: self.__dict__.copy()
GetTagIndexReq.__setstate__ = GetTagIndexReq__setstate__

all_structs.append(GetTagIndexResp)
GetTagIndexResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'item', [IndexItem, IndexItem.thrift_spec, False], None, 2, ), # 3
)

GetTagIndexResp.thrift_struct_annotations = {
}
GetTagIndexResp.thrift_field_annotations = {
}

def GetTagIndexResp__init__(self, code=None, leader=None, item=None,):
  self.code = code
  self.leader = leader
  self.item = item

GetTagIndexResp.__init__ = GetTagIndexResp__init__

def GetTagIndexResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('item', None)
  self.__dict__ = state

GetTagIndexResp.__getstate__ = lambda self: self.__dict__.copy()
GetTagIndexResp.__setstate__ = GetTagIndexResp__setstate__

all_structs.append(ListTagIndexesReq)
ListTagIndexesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListTagIndexesReq.thrift_struct_annotations = {
}
ListTagIndexesReq.thrift_field_annotations = {
}

def ListTagIndexesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListTagIndexesReq.__init__ = ListTagIndexesReq__init__

def ListTagIndexesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListTagIndexesReq.__getstate__ = lambda self: self.__dict__.copy()
ListTagIndexesReq.__setstate__ = ListTagIndexesReq__setstate__

all_structs.append(ListTagIndexesResp)
ListTagIndexesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[IndexItem, IndexItem.thrift_spec, False]), None, 2, ), # 3
)

ListTagIndexesResp.thrift_struct_annotations = {
}
ListTagIndexesResp.thrift_field_annotations = {
}

def ListTagIndexesResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

ListTagIndexesResp.__init__ = ListTagIndexesResp__init__

def ListTagIndexesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

ListTagIndexesResp.__getstate__ = lambda self: self.__dict__.copy()
ListTagIndexesResp.__setstate__ = ListTagIndexesResp__setstate__

all_structs.append(CreateEdgeIndexReq)
CreateEdgeIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.STRING, 'edge_name', False, None, 2, ), # 3
  (4, TType.LIST, 'fields', (TType.STRUCT,[IndexFieldDef, IndexFieldDef.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'if_not_exists', None, None, 2, ), # 5
)

CreateEdgeIndexReq.thrift_struct_annotations = {
}
CreateEdgeIndexReq.thrift_field_annotations = {
}

def CreateEdgeIndexReq__init__(self, space_id=None, index_name=None, edge_name=None, fields=None, if_not_exists=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.edge_name = edge_name
  self.fields = fields
  self.if_not_exists = if_not_exists

CreateEdgeIndexReq.__init__ = CreateEdgeIndexReq__init__

def CreateEdgeIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('edge_name', None)
  state.setdefault('fields', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateEdgeIndexReq.__getstate__ = lambda self: self.__dict__.copy()
CreateEdgeIndexReq.__setstate__ = CreateEdgeIndexReq__setstate__

all_structs.append(DropEdgeIndexReq)
DropEdgeIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropEdgeIndexReq.thrift_struct_annotations = {
}
DropEdgeIndexReq.thrift_field_annotations = {
}

def DropEdgeIndexReq__init__(self, space_id=None, index_name=None, if_exists=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.if_exists = if_exists

DropEdgeIndexReq.__init__ = DropEdgeIndexReq__init__

def DropEdgeIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropEdgeIndexReq.__getstate__ = lambda self: self.__dict__.copy()
DropEdgeIndexReq.__setstate__ = DropEdgeIndexReq__setstate__

all_structs.append(GetEdgeIndexReq)
GetEdgeIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
)

GetEdgeIndexReq.thrift_struct_annotations = {
}
GetEdgeIndexReq.thrift_field_annotations = {
}

def GetEdgeIndexReq__init__(self, space_id=None, index_name=None,):
  self.space_id = space_id
  self.index_name = index_name

GetEdgeIndexReq.__init__ = GetEdgeIndexReq__init__

def GetEdgeIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  self.__dict__ = state

GetEdgeIndexReq.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeIndexReq.__setstate__ = GetEdgeIndexReq__setstate__

all_structs.append(GetEdgeIndexResp)
GetEdgeIndexResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'item', [IndexItem, IndexItem.thrift_spec, False], None, 2, ), # 3
)

GetEdgeIndexResp.thrift_struct_annotations = {
}
GetEdgeIndexResp.thrift_field_annotations = {
}

def GetEdgeIndexResp__init__(self, code=None, leader=None, item=None,):
  self.code = code
  self.leader = leader
  self.item = item

GetEdgeIndexResp.__init__ = GetEdgeIndexResp__init__

def GetEdgeIndexResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('item', None)
  self.__dict__ = state

GetEdgeIndexResp.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeIndexResp.__setstate__ = GetEdgeIndexResp__setstate__

all_structs.append(ListEdgeIndexesReq)
ListEdgeIndexesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListEdgeIndexesReq.thrift_struct_annotations = {
}
ListEdgeIndexesReq.thrift_field_annotations = {
}

def ListEdgeIndexesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListEdgeIndexesReq.__init__ = ListEdgeIndexesReq__init__

def ListEdgeIndexesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListEdgeIndexesReq.__getstate__ = lambda self: self.__dict__.copy()
ListEdgeIndexesReq.__setstate__ = ListEdgeIndexesReq__setstate__

all_structs.append(ListEdgeIndexesResp)
ListEdgeIndexesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[IndexItem, IndexItem.thrift_spec, False]), None, 2, ), # 3
)

ListEdgeIndexesResp.thrift_struct_annotations = {
}
ListEdgeIndexesResp.thrift_field_annotations = {
}

def ListEdgeIndexesResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

ListEdgeIndexesResp.__init__ = ListEdgeIndexesResp__init__

def ListEdgeIndexesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

ListEdgeIndexesResp.__getstate__ = lambda self: self.__dict__.copy()
ListEdgeIndexesResp.__setstate__ = ListEdgeIndexesResp__setstate__

all_structs.append(RebuildIndexReq)
RebuildIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
)

RebuildIndexReq.thrift_struct_annotations = {
}
RebuildIndexReq.thrift_field_annotations = {
}

def RebuildIndexReq__init__(self, space_id=None, index_name=None,):
  self.space_id = space_id
  self.index_name = index_name

RebuildIndexReq.__init__ = RebuildIndexReq__init__

def RebuildIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  self.__dict__ = state

RebuildIndexReq.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexReq.__setstate__ = RebuildIndexReq__setstate__

all_structs.append(CreateUserReq)
CreateUserReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.STRING, 'encoded_pwd', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_not_exists', None, None, 2, ), # 3
)

CreateUserReq.thrift_struct_annotations = {
}
CreateUserReq.thrift_field_annotations = {
}

def CreateUserReq__init__(self, account=None, encoded_pwd=None, if_not_exists=None,):
  self.account = account
  self.encoded_pwd = encoded_pwd
  self.if_not_exists = if_not_exists

CreateUserReq.__init__ = CreateUserReq__init__

def CreateUserReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('encoded_pwd', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateUserReq.__getstate__ = lambda self: self.__dict__.copy()
CreateUserReq.__setstate__ = CreateUserReq__setstate__

all_structs.append(DropUserReq)
DropUserReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.BOOL, 'if_exists', None, None, 2, ), # 2
)

DropUserReq.thrift_struct_annotations = {
}
DropUserReq.thrift_field_annotations = {
}

def DropUserReq__init__(self, account=None, if_exists=None,):
  self.account = account
  self.if_exists = if_exists

DropUserReq.__init__ = DropUserReq__init__

def DropUserReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropUserReq.__getstate__ = lambda self: self.__dict__.copy()
DropUserReq.__setstate__ = DropUserReq__setstate__

all_structs.append(AlterUserReq)
AlterUserReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.STRING, 'encoded_pwd', False, None, 2, ), # 2
)

AlterUserReq.thrift_struct_annotations = {
}
AlterUserReq.thrift_field_annotations = {
}

def AlterUserReq__init__(self, account=None, encoded_pwd=None,):
  self.account = account
  self.encoded_pwd = encoded_pwd

AlterUserReq.__init__ = AlterUserReq__init__

def AlterUserReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('encoded_pwd', None)
  self.__dict__ = state

AlterUserReq.__getstate__ = lambda self: self.__dict__.copy()
AlterUserReq.__setstate__ = AlterUserReq__setstate__

all_structs.append(GrantRoleReq)
GrantRoleReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'role_item', [RoleItem, RoleItem.thrift_spec, False], None, 2, ), # 1
)

GrantRoleReq.thrift_struct_annotations = {
}
GrantRoleReq.thrift_field_annotations = {
}

def GrantRoleReq__init__(self, role_item=None,):
  self.role_item = role_item

GrantRoleReq.__init__ = GrantRoleReq__init__

def GrantRoleReq__setstate__(self, state):
  state.setdefault('role_item', None)
  self.__dict__ = state

GrantRoleReq.__getstate__ = lambda self: self.__dict__.copy()
GrantRoleReq.__setstate__ = GrantRoleReq__setstate__

all_structs.append(RevokeRoleReq)
RevokeRoleReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'role_item', [RoleItem, RoleItem.thrift_spec, False], None, 2, ), # 1
)

RevokeRoleReq.thrift_struct_annotations = {
}
RevokeRoleReq.thrift_field_annotations = {
}

def RevokeRoleReq__init__(self, role_item=None,):
  self.role_item = role_item

RevokeRoleReq.__init__ = RevokeRoleReq__init__

def RevokeRoleReq__setstate__(self, state):
  state.setdefault('role_item', None)
  self.__dict__ = state

RevokeRoleReq.__getstate__ = lambda self: self.__dict__.copy()
RevokeRoleReq.__setstate__ = RevokeRoleReq__setstate__

all_structs.append(ListUsersReq)
ListUsersReq.thrift_spec = (
)

ListUsersReq.thrift_struct_annotations = {
}
ListUsersReq.thrift_field_annotations = {
}

all_structs.append(ListUsersResp)
ListUsersResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'users', (TType.STRING,False,TType.STRING,False), None, 2, ), # 3
)

ListUsersResp.thrift_struct_annotations = {
}
ListUsersResp.thrift_field_annotations = {
}

def ListUsersResp__init__(self, code=None, leader=None, users=None,):
  self.code = code
  self.leader = leader
  self.users = users

ListUsersResp.__init__ = ListUsersResp__init__

def ListUsersResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('users', None)
  self.__dict__ = state

ListUsersResp.__getstate__ = lambda self: self.__dict__.copy()
ListUsersResp.__setstate__ = ListUsersResp__setstate__

all_structs.append(ListRolesReq)
ListRolesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListRolesReq.thrift_struct_annotations = {
}
ListRolesReq.thrift_field_annotations = {
}

def ListRolesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListRolesReq.__init__ = ListRolesReq__init__

def ListRolesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListRolesReq.__getstate__ = lambda self: self.__dict__.copy()
ListRolesReq.__setstate__ = ListRolesReq__setstate__

all_structs.append(ListRolesResp)
ListRolesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'roles', (TType.STRUCT,[RoleItem, RoleItem.thrift_spec, False]), None, 2, ), # 3
)

ListRolesResp.thrift_struct_annotations = {
}
ListRolesResp.thrift_field_annotations = {
}

def ListRolesResp__init__(self, code=None, leader=None, roles=None,):
  self.code = code
  self.leader = leader
  self.roles = roles

ListRolesResp.__init__ = ListRolesResp__init__

def ListRolesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('roles', None)
  self.__dict__ = state

ListRolesResp.__getstate__ = lambda self: self.__dict__.copy()
ListRolesResp.__setstate__ = ListRolesResp__setstate__

all_structs.append(GetUserRolesReq)
GetUserRolesReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
)

GetUserRolesReq.thrift_struct_annotations = {
}
GetUserRolesReq.thrift_field_annotations = {
}

def GetUserRolesReq__init__(self, account=None,):
  self.account = account

GetUserRolesReq.__init__ = GetUserRolesReq__init__

def GetUserRolesReq__setstate__(self, state):
  state.setdefault('account', None)
  self.__dict__ = state

GetUserRolesReq.__getstate__ = lambda self: self.__dict__.copy()
GetUserRolesReq.__setstate__ = GetUserRolesReq__setstate__

all_structs.append(ChangePasswordReq)
ChangePasswordReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.STRING, 'new_encoded_pwd', False, None, 2, ), # 2
  (3, TType.STRING, 'old_encoded_pwd', False, None, 2, ), # 3
)

ChangePasswordReq.thrift_struct_annotations = {
}
ChangePasswordReq.thrift_field_annotations = {
}

def ChangePasswordReq__init__(self, account=None, new_encoded_pwd=None, old_encoded_pwd=None,):
  self.account = account
  self.new_encoded_pwd = new_encoded_pwd
  self.old_encoded_pwd = old_encoded_pwd

ChangePasswordReq.__init__ = ChangePasswordReq__init__

def ChangePasswordReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('new_encoded_pwd', None)
  state.setdefault('old_encoded_pwd', None)
  self.__dict__ = state

ChangePasswordReq.__getstate__ = lambda self: self.__dict__.copy()
ChangePasswordReq.__setstate__ = ChangePasswordReq__setstate__

all_structs.append(BalanceReq)
BalanceReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 1, ), # 1
  (2, TType.I64, 'id', None, None, 1, ), # 2
  (3, TType.LIST, 'host_del', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 1, ), # 3
  (4, TType.BOOL, 'stop', None, None, 1, ), # 4
  (5, TType.BOOL, 'reset', None, None, 1, ), # 5
)

BalanceReq.thrift_struct_annotations = {
}
BalanceReq.thrift_field_annotations = {
}

def BalanceReq__init__(self, space_id=None, id=None, host_del=None, stop=None, reset=None,):
  self.space_id = space_id
  self.id = id
  self.host_del = host_del
  self.stop = stop
  self.reset = reset

BalanceReq.__init__ = BalanceReq__init__

def BalanceReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('id', None)
  state.setdefault('host_del', None)
  state.setdefault('stop', None)
  state.setdefault('reset', None)
  self.__dict__ = state

BalanceReq.__getstate__ = lambda self: self.__dict__.copy()
BalanceReq.__setstate__ = BalanceReq__setstate__

all_structs.append(BalanceTask)
BalanceTask.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'id', False, None, 2, ), # 1
  (2, TType.I32, 'result', TaskResult, None, 2, ), # 2
)

BalanceTask.thrift_struct_annotations = {
}
BalanceTask.thrift_field_annotations = {
}

def BalanceTask__init__(self, id=None, result=None,):
  self.id = id
  self.result = result

BalanceTask.__init__ = BalanceTask__init__

def BalanceTask__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('result', None)
  self.__dict__ = state

BalanceTask.__getstate__ = lambda self: self.__dict__.copy()
BalanceTask.__setstate__ = BalanceTask__setstate__

all_structs.append(BalanceResp)
BalanceResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.I64, 'id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'tasks', (TType.STRUCT,[BalanceTask, BalanceTask.thrift_spec, False]), None, 2, ), # 4
)

BalanceResp.thrift_struct_annotations = {
}
BalanceResp.thrift_field_annotations = {
}

def BalanceResp__init__(self, code=None, id=None, leader=None, tasks=None,):
  self.code = code
  self.id = id
  self.leader = leader
  self.tasks = tasks

BalanceResp.__init__ = BalanceResp__init__

def BalanceResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('id', None)
  state.setdefault('leader', None)
  state.setdefault('tasks', None)
  self.__dict__ = state

BalanceResp.__getstate__ = lambda self: self.__dict__.copy()
BalanceResp.__setstate__ = BalanceResp__setstate__

all_structs.append(LeaderBalanceReq)
LeaderBalanceReq.thrift_spec = (
)

LeaderBalanceReq.thrift_struct_annotations = {
}
LeaderBalanceReq.thrift_field_annotations = {
}

all_structs.append(ConfigItem)
ConfigItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'module', ConfigModule, None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
  (3, TType.I32, 'mode', ConfigMode, None, 2, ), # 3
  (4, TType.STRUCT, 'value', [nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

ConfigItem.thrift_struct_annotations = {
}
ConfigItem.thrift_field_annotations = {
}

def ConfigItem__init__(self, module=None, name=None, mode=None, value=None,):
  self.module = module
  self.name = name
  self.mode = mode
  self.value = value

ConfigItem.__init__ = ConfigItem__init__

def ConfigItem__setstate__(self, state):
  state.setdefault('module', None)
  state.setdefault('name', None)
  state.setdefault('mode', None)
  state.setdefault('value', None)
  self.__dict__ = state

ConfigItem.__getstate__ = lambda self: self.__dict__.copy()
ConfigItem.__setstate__ = ConfigItem__setstate__

all_structs.append(RegConfigReq)
RegConfigReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'items', (TType.STRUCT,[ConfigItem, ConfigItem.thrift_spec, False]), None, 2, ), # 1
)

RegConfigReq.thrift_struct_annotations = {
}
RegConfigReq.thrift_field_annotations = {
}

def RegConfigReq__init__(self, items=None,):
  self.items = items

RegConfigReq.__init__ = RegConfigReq__init__

def RegConfigReq__setstate__(self, state):
  state.setdefault('items', None)
  self.__dict__ = state

RegConfigReq.__getstate__ = lambda self: self.__dict__.copy()
RegConfigReq.__setstate__ = RegConfigReq__setstate__

all_structs.append(GetConfigReq)
GetConfigReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'item', [ConfigItem, ConfigItem.thrift_spec, False], None, 2, ), # 1
)

GetConfigReq.thrift_struct_annotations = {
}
GetConfigReq.thrift_field_annotations = {
}

def GetConfigReq__init__(self, item=None,):
  self.item = item

GetConfigReq.__init__ = GetConfigReq__init__

def GetConfigReq__setstate__(self, state):
  state.setdefault('item', None)
  self.__dict__ = state

GetConfigReq.__getstate__ = lambda self: self.__dict__.copy()
GetConfigReq.__setstate__ = GetConfigReq__setstate__

all_structs.append(GetConfigResp)
GetConfigResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[ConfigItem, ConfigItem.thrift_spec, False]), None, 2, ), # 3
)

GetConfigResp.thrift_struct_annotations = {
}
GetConfigResp.thrift_field_annotations = {
}

def GetConfigResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

GetConfigResp.__init__ = GetConfigResp__init__

def GetConfigResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

GetConfigResp.__getstate__ = lambda self: self.__dict__.copy()
GetConfigResp.__setstate__ = GetConfigResp__setstate__

all_structs.append(SetConfigReq)
SetConfigReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'item', [ConfigItem, ConfigItem.thrift_spec, False], None, 2, ), # 1
)

SetConfigReq.thrift_struct_annotations = {
}
SetConfigReq.thrift_field_annotations = {
}

def SetConfigReq__init__(self, item=None,):
  self.item = item

SetConfigReq.__init__ = SetConfigReq__init__

def SetConfigReq__setstate__(self, state):
  state.setdefault('item', None)
  self.__dict__ = state

SetConfigReq.__getstate__ = lambda self: self.__dict__.copy()
SetConfigReq.__setstate__ = SetConfigReq__setstate__

all_structs.append(ListConfigsReq)
ListConfigsReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space', False, None, 2, ), # 1
  (2, TType.I32, 'module', ConfigModule, None, 2, ), # 2
)

ListConfigsReq.thrift_struct_annotations = {
}
ListConfigsReq.thrift_field_annotations = {
}

def ListConfigsReq__init__(self, space=None, module=None,):
  self.space = space
  self.module = module

ListConfigsReq.__init__ = ListConfigsReq__init__

def ListConfigsReq__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('module', None)
  self.__dict__ = state

ListConfigsReq.__getstate__ = lambda self: self.__dict__.copy()
ListConfigsReq.__setstate__ = ListConfigsReq__setstate__

all_structs.append(ListConfigsResp)
ListConfigsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[ConfigItem, ConfigItem.thrift_spec, False]), None, 2, ), # 3
)

ListConfigsResp.thrift_struct_annotations = {
}
ListConfigsResp.thrift_field_annotations = {
}

def ListConfigsResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

ListConfigsResp.__init__ = ListConfigsResp__init__

def ListConfigsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

ListConfigsResp.__getstate__ = lambda self: self.__dict__.copy()
ListConfigsResp.__setstate__ = ListConfigsResp__setstate__

all_structs.append(CreateSnapshotReq)
CreateSnapshotReq.thrift_spec = (
)

CreateSnapshotReq.thrift_struct_annotations = {
}
CreateSnapshotReq.thrift_field_annotations = {
}

all_structs.append(DropSnapshotReq)
DropSnapshotReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
)

DropSnapshotReq.thrift_struct_annotations = {
}
DropSnapshotReq.thrift_field_annotations = {
}

def DropSnapshotReq__init__(self, name=None,):
  self.name = name

DropSnapshotReq.__init__ = DropSnapshotReq__init__

def DropSnapshotReq__setstate__(self, state):
  state.setdefault('name', None)
  self.__dict__ = state

DropSnapshotReq.__getstate__ = lambda self: self.__dict__.copy()
DropSnapshotReq.__setstate__ = DropSnapshotReq__setstate__

all_structs.append(ListSnapshotsReq)
ListSnapshotsReq.thrift_spec = (
)

ListSnapshotsReq.thrift_struct_annotations = {
}
ListSnapshotsReq.thrift_field_annotations = {
}

all_structs.append(Snapshot)
Snapshot.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.I32, 'status', SnapshotStatus, None, 2, ), # 2
  (3, TType.STRING, 'hosts', False, None, 2, ), # 3
)

Snapshot.thrift_struct_annotations = {
}
Snapshot.thrift_field_annotations = {
}

def Snapshot__init__(self, name=None, status=None, hosts=None,):
  self.name = name
  self.status = status
  self.hosts = hosts

Snapshot.__init__ = Snapshot__init__

def Snapshot__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('status', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

Snapshot.__getstate__ = lambda self: self.__dict__.copy()
Snapshot.__setstate__ = Snapshot__setstate__

all_structs.append(ListSnapshotsResp)
ListSnapshotsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'snapshots', (TType.STRUCT,[Snapshot, Snapshot.thrift_spec, False]), None, 2, ), # 3
)

ListSnapshotsResp.thrift_struct_annotations = {
}
ListSnapshotsResp.thrift_field_annotations = {
}

def ListSnapshotsResp__init__(self, code=None, leader=None, snapshots=None,):
  self.code = code
  self.leader = leader
  self.snapshots = snapshots

ListSnapshotsResp.__init__ = ListSnapshotsResp__init__

def ListSnapshotsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('snapshots', None)
  self.__dict__ = state

ListSnapshotsResp.__getstate__ = lambda self: self.__dict__.copy()
ListSnapshotsResp.__setstate__ = ListSnapshotsResp__setstate__

all_structs.append(ListIndexStatusReq)
ListIndexStatusReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListIndexStatusReq.thrift_struct_annotations = {
}
ListIndexStatusReq.thrift_field_annotations = {
}

def ListIndexStatusReq__init__(self, space_id=None,):
  self.space_id = space_id

ListIndexStatusReq.__init__ = ListIndexStatusReq__init__

def ListIndexStatusReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListIndexStatusReq.__getstate__ = lambda self: self.__dict__.copy()
ListIndexStatusReq.__setstate__ = ListIndexStatusReq__setstate__

all_structs.append(IndexStatus)
IndexStatus.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.STRING, 'status', False, None, 2, ), # 2
)

IndexStatus.thrift_struct_annotations = {
}
IndexStatus.thrift_field_annotations = {
}

def IndexStatus__init__(self, name=None, status=None,):
  self.name = name
  self.status = status

IndexStatus.__init__ = IndexStatus__init__

def IndexStatus__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('status', None)
  self.__dict__ = state

IndexStatus.__getstate__ = lambda self: self.__dict__.copy()
IndexStatus.__setstate__ = IndexStatus__setstate__

all_structs.append(ListIndexStatusResp)
ListIndexStatusResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'statuses', (TType.STRUCT,[IndexStatus, IndexStatus.thrift_spec, False]), None, 2, ), # 3
)

ListIndexStatusResp.thrift_struct_annotations = {
}
ListIndexStatusResp.thrift_field_annotations = {
}

def ListIndexStatusResp__init__(self, code=None, leader=None, statuses=None,):
  self.code = code
  self.leader = leader
  self.statuses = statuses

ListIndexStatusResp.__init__ = ListIndexStatusResp__init__

def ListIndexStatusResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('statuses', None)
  self.__dict__ = state

ListIndexStatusResp.__getstate__ = lambda self: self.__dict__.copy()
ListIndexStatusResp.__setstate__ = ListIndexStatusResp__setstate__

all_structs.append(AddZoneReq)
AddZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
  (2, TType.LIST, 'nodes', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 2
)

AddZoneReq.thrift_struct_annotations = {
}
AddZoneReq.thrift_field_annotations = {
}

def AddZoneReq__init__(self, zone_name=None, nodes=None,):
  self.zone_name = zone_name
  self.nodes = nodes

AddZoneReq.__init__ = AddZoneReq__init__

def AddZoneReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  state.setdefault('nodes', None)
  self.__dict__ = state

AddZoneReq.__getstate__ = lambda self: self.__dict__.copy()
AddZoneReq.__setstate__ = AddZoneReq__setstate__

all_structs.append(DropZoneReq)
DropZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
)

DropZoneReq.thrift_struct_annotations = {
}
DropZoneReq.thrift_field_annotations = {
}

def DropZoneReq__init__(self, zone_name=None,):
  self.zone_name = zone_name

DropZoneReq.__init__ = DropZoneReq__init__

def DropZoneReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  self.__dict__ = state

DropZoneReq.__getstate__ = lambda self: self.__dict__.copy()
DropZoneReq.__setstate__ = DropZoneReq__setstate__

all_structs.append(AddHostIntoZoneReq)
AddHostIntoZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'node', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'zone_name', False, None, 2, ), # 2
)

AddHostIntoZoneReq.thrift_struct_annotations = {
}
AddHostIntoZoneReq.thrift_field_annotations = {
}

def AddHostIntoZoneReq__init__(self, node=None, zone_name=None,):
  self.node = node
  self.zone_name = zone_name

AddHostIntoZoneReq.__init__ = AddHostIntoZoneReq__init__

def AddHostIntoZoneReq__setstate__(self, state):
  state.setdefault('node', None)
  state.setdefault('zone_name', None)
  self.__dict__ = state

AddHostIntoZoneReq.__getstate__ = lambda self: self.__dict__.copy()
AddHostIntoZoneReq.__setstate__ = AddHostIntoZoneReq__setstate__

all_structs.append(DropHostFromZoneReq)
DropHostFromZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'node', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'zone_name', False, None, 2, ), # 2
)

DropHostFromZoneReq.thrift_struct_annotations = {
}
DropHostFromZoneReq.thrift_field_annotations = {
}

def DropHostFromZoneReq__init__(self, node=None, zone_name=None,):
  self.node = node
  self.zone_name = zone_name

DropHostFromZoneReq.__init__ = DropHostFromZoneReq__init__

def DropHostFromZoneReq__setstate__(self, state):
  state.setdefault('node', None)
  state.setdefault('zone_name', None)
  self.__dict__ = state

DropHostFromZoneReq.__getstate__ = lambda self: self.__dict__.copy()
DropHostFromZoneReq.__setstate__ = DropHostFromZoneReq__setstate__

all_structs.append(GetZoneReq)
GetZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
)

GetZoneReq.thrift_struct_annotations = {
}
GetZoneReq.thrift_field_annotations = {
}

def GetZoneReq__init__(self, zone_name=None,):
  self.zone_name = zone_name

GetZoneReq.__init__ = GetZoneReq__init__

def GetZoneReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  self.__dict__ = state

GetZoneReq.__getstate__ = lambda self: self.__dict__.copy()
GetZoneReq.__setstate__ = GetZoneReq__setstate__

all_structs.append(GetZoneResp)
GetZoneResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'hosts', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

GetZoneResp.thrift_struct_annotations = {
}
GetZoneResp.thrift_field_annotations = {
}

def GetZoneResp__init__(self, code=None, leader=None, hosts=None,):
  self.code = code
  self.leader = leader
  self.hosts = hosts

GetZoneResp.__init__ = GetZoneResp__init__

def GetZoneResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

GetZoneResp.__getstate__ = lambda self: self.__dict__.copy()
GetZoneResp.__setstate__ = GetZoneResp__setstate__

all_structs.append(ListZonesReq)
ListZonesReq.thrift_spec = (
)

ListZonesReq.thrift_struct_annotations = {
}
ListZonesReq.thrift_field_annotations = {
}

all_structs.append(Zone)
Zone.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
  (2, TType.LIST, 'nodes', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 2
)

Zone.thrift_struct_annotations = {
}
Zone.thrift_field_annotations = {
}

def Zone__init__(self, zone_name=None, nodes=None,):
  self.zone_name = zone_name
  self.nodes = nodes

Zone.__init__ = Zone__init__

def Zone__setstate__(self, state):
  state.setdefault('zone_name', None)
  state.setdefault('nodes', None)
  self.__dict__ = state

Zone.__getstate__ = lambda self: self.__dict__.copy()
Zone.__setstate__ = Zone__setstate__

all_structs.append(ListZonesResp)
ListZonesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'zones', (TType.STRUCT,[Zone, Zone.thrift_spec, False]), None, 2, ), # 3
)

ListZonesResp.thrift_struct_annotations = {
}
ListZonesResp.thrift_field_annotations = {
}

def ListZonesResp__init__(self, code=None, leader=None, zones=None,):
  self.code = code
  self.leader = leader
  self.zones = zones

ListZonesResp.__init__ = ListZonesResp__init__

def ListZonesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('zones', None)
  self.__dict__ = state

ListZonesResp.__getstate__ = lambda self: self.__dict__.copy()
ListZonesResp.__setstate__ = ListZonesResp__setstate__

all_structs.append(AddGroupReq)
AddGroupReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'group_name', False, None, 2, ), # 1
  (2, TType.LIST, 'zone_names', (TType.STRING,False), None, 2, ), # 2
)

AddGroupReq.thrift_struct_annotations = {
}
AddGroupReq.thrift_field_annotations = {
}

def AddGroupReq__init__(self, group_name=None, zone_names=None,):
  self.group_name = group_name
  self.zone_names = zone_names

AddGroupReq.__init__ = AddGroupReq__init__

def AddGroupReq__setstate__(self, state):
  state.setdefault('group_name', None)
  state.setdefault('zone_names', None)
  self.__dict__ = state

AddGroupReq.__getstate__ = lambda self: self.__dict__.copy()
AddGroupReq.__setstate__ = AddGroupReq__setstate__

all_structs.append(DropGroupReq)
DropGroupReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'group_name', False, None, 2, ), # 1
)

DropGroupReq.thrift_struct_annotations = {
}
DropGroupReq.thrift_field_annotations = {
}

def DropGroupReq__init__(self, group_name=None,):
  self.group_name = group_name

DropGroupReq.__init__ = DropGroupReq__init__

def DropGroupReq__setstate__(self, state):
  state.setdefault('group_name', None)
  self.__dict__ = state

DropGroupReq.__getstate__ = lambda self: self.__dict__.copy()
DropGroupReq.__setstate__ = DropGroupReq__setstate__

all_structs.append(AddZoneIntoGroupReq)
AddZoneIntoGroupReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
  (2, TType.STRING, 'group_name', False, None, 2, ), # 2
)

AddZoneIntoGroupReq.thrift_struct_annotations = {
}
AddZoneIntoGroupReq.thrift_field_annotations = {
}

def AddZoneIntoGroupReq__init__(self, zone_name=None, group_name=None,):
  self.zone_name = zone_name
  self.group_name = group_name

AddZoneIntoGroupReq.__init__ = AddZoneIntoGroupReq__init__

def AddZoneIntoGroupReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  state.setdefault('group_name', None)
  self.__dict__ = state

AddZoneIntoGroupReq.__getstate__ = lambda self: self.__dict__.copy()
AddZoneIntoGroupReq.__setstate__ = AddZoneIntoGroupReq__setstate__

all_structs.append(DropZoneFromGroupReq)
DropZoneFromGroupReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
  (2, TType.STRING, 'group_name', False, None, 2, ), # 2
)

DropZoneFromGroupReq.thrift_struct_annotations = {
}
DropZoneFromGroupReq.thrift_field_annotations = {
}

def DropZoneFromGroupReq__init__(self, zone_name=None, group_name=None,):
  self.zone_name = zone_name
  self.group_name = group_name

DropZoneFromGroupReq.__init__ = DropZoneFromGroupReq__init__

def DropZoneFromGroupReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  state.setdefault('group_name', None)
  self.__dict__ = state

DropZoneFromGroupReq.__getstate__ = lambda self: self.__dict__.copy()
DropZoneFromGroupReq.__setstate__ = DropZoneFromGroupReq__setstate__

all_structs.append(GetGroupReq)
GetGroupReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'group_name', False, None, 2, ), # 1
)

GetGroupReq.thrift_struct_annotations = {
}
GetGroupReq.thrift_field_annotations = {
}

def GetGroupReq__init__(self, group_name=None,):
  self.group_name = group_name

GetGroupReq.__init__ = GetGroupReq__init__

def GetGroupReq__setstate__(self, state):
  state.setdefault('group_name', None)
  self.__dict__ = state

GetGroupReq.__getstate__ = lambda self: self.__dict__.copy()
GetGroupReq.__setstate__ = GetGroupReq__setstate__

all_structs.append(GetGroupResp)
GetGroupResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'zone_names', (TType.STRING,False), None, 2, ), # 3
)

GetGroupResp.thrift_struct_annotations = {
}
GetGroupResp.thrift_field_annotations = {
}

def GetGroupResp__init__(self, code=None, leader=None, zone_names=None,):
  self.code = code
  self.leader = leader
  self.zone_names = zone_names

GetGroupResp.__init__ = GetGroupResp__init__

def GetGroupResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('zone_names', None)
  self.__dict__ = state

GetGroupResp.__getstate__ = lambda self: self.__dict__.copy()
GetGroupResp.__setstate__ = GetGroupResp__setstate__

all_structs.append(ListGroupsReq)
ListGroupsReq.thrift_spec = (
)

ListGroupsReq.thrift_struct_annotations = {
}
ListGroupsReq.thrift_field_annotations = {
}

all_structs.append(Group)
Group.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'group_name', False, None, 2, ), # 1
  (2, TType.LIST, 'zone_names', (TType.STRING,False), None, 2, ), # 2
)

Group.thrift_struct_annotations = {
}
Group.thrift_field_annotations = {
}

def Group__init__(self, group_name=None, zone_names=None,):
  self.group_name = group_name
  self.zone_names = zone_names

Group.__init__ = Group__init__

def Group__setstate__(self, state):
  state.setdefault('group_name', None)
  state.setdefault('zone_names', None)
  self.__dict__ = state

Group.__getstate__ = lambda self: self.__dict__.copy()
Group.__setstate__ = Group__setstate__

all_structs.append(ListGroupsResp)
ListGroupsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'groups', (TType.STRUCT,[Group, Group.thrift_spec, False]), None, 2, ), # 3
)

ListGroupsResp.thrift_struct_annotations = {
}
ListGroupsResp.thrift_field_annotations = {
}

def ListGroupsResp__init__(self, code=None, leader=None, groups=None,):
  self.code = code
  self.leader = leader
  self.groups = groups

ListGroupsResp.__init__ = ListGroupsResp__init__

def ListGroupsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('groups', None)
  self.__dict__ = state

ListGroupsResp.__getstate__ = lambda self: self.__dict__.copy()
ListGroupsResp.__setstate__ = ListGroupsResp__setstate__

all_structs.append(AddListenerReq)
AddListenerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'type', ListenerType, None, 2, ), # 2
  (3, TType.LIST, 'hosts', (TType.STRUCT,[nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

AddListenerReq.thrift_struct_annotations = {
}
AddListenerReq.thrift_field_annotations = {
}

def AddListenerReq__init__(self, space_id=None, type=None, hosts=None,):
  self.space_id = space_id
  self.type = type
  self.hosts = hosts

AddListenerReq.__init__ = AddListenerReq__init__

def AddListenerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('type', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

AddListenerReq.__getstate__ = lambda self: self.__dict__.copy()
AddListenerReq.__setstate__ = AddListenerReq__setstate__

all_structs.append(RemoveListenerReq)
RemoveListenerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'type', ListenerType, None, 2, ), # 2
)

RemoveListenerReq.thrift_struct_annotations = {
}
RemoveListenerReq.thrift_field_annotations = {
}

def RemoveListenerReq__init__(self, space_id=None, type=None,):
  self.space_id = space_id
  self.type = type

RemoveListenerReq.__init__ = RemoveListenerReq__init__

def RemoveListenerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('type', None)
  self.__dict__ = state

RemoveListenerReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveListenerReq.__setstate__ = RemoveListenerReq__setstate__

all_structs.append(ListListenerReq)
ListListenerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListListenerReq.thrift_struct_annotations = {
}
ListListenerReq.thrift_field_annotations = {
}

def ListListenerReq__init__(self, space_id=None,):
  self.space_id = space_id

ListListenerReq.__init__ = ListListenerReq__init__

def ListListenerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListListenerReq.__getstate__ = lambda self: self.__dict__.copy()
ListListenerReq.__setstate__ = ListListenerReq__setstate__

all_structs.append(ListenerInfo)
ListenerInfo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ListenerType, None, 2, ), # 1
  (2, TType.STRUCT, 'host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'part_id', None, None, 2, ), # 3
  (4, TType.I32, 'status', HostStatus, None, 2, ), # 4
)

ListenerInfo.thrift_struct_annotations = {
}
ListenerInfo.thrift_field_annotations = {
}

def ListenerInfo__init__(self, type=None, host=None, part_id=None, status=None,):
  self.type = type
  self.host = host
  self.part_id = part_id
  self.status = status

ListenerInfo.__init__ = ListenerInfo__init__

def ListenerInfo__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('host', None)
  state.setdefault('part_id', None)
  state.setdefault('status', None)
  self.__dict__ = state

ListenerInfo.__getstate__ = lambda self: self.__dict__.copy()
ListenerInfo.__setstate__ = ListenerInfo__setstate__

all_structs.append(ListListenerResp)
ListListenerResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'listeners', (TType.STRUCT,[ListenerInfo, ListenerInfo.thrift_spec, False]), None, 2, ), # 3
)

ListListenerResp.thrift_struct_annotations = {
}
ListListenerResp.thrift_field_annotations = {
}

def ListListenerResp__init__(self, code=None, leader=None, listeners=None,):
  self.code = code
  self.leader = leader
  self.listeners = listeners

ListListenerResp.__init__ = ListListenerResp__init__

def ListListenerResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('listeners', None)
  self.__dict__ = state

ListListenerResp.__getstate__ = lambda self: self.__dict__.copy()
ListListenerResp.__setstate__ = ListListenerResp__setstate__

all_structs.append(GetStatisReq)
GetStatisReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

GetStatisReq.thrift_struct_annotations = {
}
GetStatisReq.thrift_field_annotations = {
}

def GetStatisReq__init__(self, space_id=None,):
  self.space_id = space_id

GetStatisReq.__init__ = GetStatisReq__init__

def GetStatisReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

GetStatisReq.__getstate__ = lambda self: self.__dict__.copy()
GetStatisReq.__setstate__ = GetStatisReq__setstate__

all_structs.append(GetStatisResp)
GetStatisResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'statis', [StatisItem, StatisItem.thrift_spec, False], None, 2, ), # 3
)

GetStatisResp.thrift_struct_annotations = {
}
GetStatisResp.thrift_field_annotations = {
}

def GetStatisResp__init__(self, code=None, leader=None, statis=None,):
  self.code = code
  self.leader = leader
  self.statis = statis

GetStatisResp.__init__ = GetStatisResp__init__

def GetStatisResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('statis', None)
  self.__dict__ = state

GetStatisResp.__getstate__ = lambda self: self.__dict__.copy()
GetStatisResp.__setstate__ = GetStatisResp__setstate__

all_structs.append(CheckpointInfo)
CheckpointInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'checkpoint_dir', False, None, 2, ), # 2
)

CheckpointInfo.thrift_struct_annotations = {
}
CheckpointInfo.thrift_field_annotations = {
}

def CheckpointInfo__init__(self, host=None, checkpoint_dir=None,):
  self.host = host
  self.checkpoint_dir = checkpoint_dir

CheckpointInfo.__init__ = CheckpointInfo__init__

def CheckpointInfo__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('checkpoint_dir', None)
  self.__dict__ = state

CheckpointInfo.__getstate__ = lambda self: self.__dict__.copy()
CheckpointInfo.__setstate__ = CheckpointInfo__setstate__

all_structs.append(SpaceBackupInfo)
SpaceBackupInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'space', [SpaceDesc, SpaceDesc.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'partition_info', [nebula2.common.ttypes.PartitionBackupInfo, nebula2.common.ttypes.PartitionBackupInfo.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'cp_dirs', (TType.STRUCT,[CheckpointInfo, CheckpointInfo.thrift_spec, False]), None, 2, ), # 3
)

SpaceBackupInfo.thrift_struct_annotations = {
}
SpaceBackupInfo.thrift_field_annotations = {
}

def SpaceBackupInfo__init__(self, space=None, partition_info=None, cp_dirs=None,):
  self.space = space
  self.partition_info = partition_info
  self.cp_dirs = cp_dirs

SpaceBackupInfo.__init__ = SpaceBackupInfo__init__

def SpaceBackupInfo__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('partition_info', None)
  state.setdefault('cp_dirs', None)
  self.__dict__ = state

SpaceBackupInfo.__getstate__ = lambda self: self.__dict__.copy()
SpaceBackupInfo.__setstate__ = SpaceBackupInfo__setstate__

all_structs.append(BackupMeta)
BackupMeta.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'backup_info', (TType.I32,None,TType.STRUCT,[SpaceBackupInfo, SpaceBackupInfo.thrift_spec, False]), None, 2, ), # 1
  (2, TType.LIST, 'meta_files', (TType.STRING,False), None, 2, ), # 2
  (3, TType.STRING, 'backup_name', False, None, 2, ), # 3
)

BackupMeta.thrift_struct_annotations = {
}
BackupMeta.thrift_field_annotations = {
}

def BackupMeta__init__(self, backup_info=None, meta_files=None, backup_name=None,):
  self.backup_info = backup_info
  self.meta_files = meta_files
  self.backup_name = backup_name

BackupMeta.__init__ = BackupMeta__init__

def BackupMeta__setstate__(self, state):
  state.setdefault('backup_info', None)
  state.setdefault('meta_files', None)
  state.setdefault('backup_name', None)
  self.__dict__ = state

BackupMeta.__getstate__ = lambda self: self.__dict__.copy()
BackupMeta.__setstate__ = BackupMeta__setstate__

all_structs.append(CreateBackupReq)
CreateBackupReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'spaces', (TType.STRING,False), None, 1, ), # 1
)

CreateBackupReq.thrift_struct_annotations = {
}
CreateBackupReq.thrift_field_annotations = {
}

def CreateBackupReq__init__(self, spaces=None,):
  self.spaces = spaces

CreateBackupReq.__init__ = CreateBackupReq__init__

def CreateBackupReq__setstate__(self, state):
  state.setdefault('spaces', None)
  self.__dict__ = state

CreateBackupReq.__getstate__ = lambda self: self.__dict__.copy()
CreateBackupReq.__setstate__ = CreateBackupReq__setstate__

all_structs.append(CreateBackupResp)
CreateBackupResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'meta', [BackupMeta, BackupMeta.thrift_spec, False], None, 2, ), # 3
)

CreateBackupResp.thrift_struct_annotations = {
}
CreateBackupResp.thrift_field_annotations = {
}

def CreateBackupResp__init__(self, code=None, leader=None, meta=None,):
  self.code = code
  self.leader = leader
  self.meta = meta

CreateBackupResp.__init__ = CreateBackupResp__init__

def CreateBackupResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('meta', None)
  self.__dict__ = state

CreateBackupResp.__getstate__ = lambda self: self.__dict__.copy()
CreateBackupResp.__setstate__ = CreateBackupResp__setstate__

all_structs.append(HostPair)
HostPair.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'from_host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'to_host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
)

HostPair.thrift_struct_annotations = {
}
HostPair.thrift_field_annotations = {
}

def HostPair__init__(self, from_host=None, to_host=None,):
  self.from_host = from_host
  self.to_host = to_host

HostPair.__init__ = HostPair__init__

def HostPair__setstate__(self, state):
  state.setdefault('from_host', None)
  state.setdefault('to_host', None)
  self.__dict__ = state

HostPair.__getstate__ = lambda self: self.__dict__.copy()
HostPair.__setstate__ = HostPair__setstate__

all_structs.append(RestoreMetaReq)
RestoreMetaReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'files', (TType.STRING,False), None, 2, ), # 1
  (2, TType.LIST, 'hosts', (TType.STRUCT,[HostPair, HostPair.thrift_spec, False]), None, 2, ), # 2
)

RestoreMetaReq.thrift_struct_annotations = {
}
RestoreMetaReq.thrift_field_annotations = {
}

def RestoreMetaReq__init__(self, files=None, hosts=None,):
  self.files = files
  self.hosts = hosts

RestoreMetaReq.__init__ = RestoreMetaReq__init__

def RestoreMetaReq__setstate__(self, state):
  state.setdefault('files', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

RestoreMetaReq.__getstate__ = lambda self: self.__dict__.copy()
RestoreMetaReq.__setstate__ = RestoreMetaReq__setstate__

all_structs.append(FTClient)
FTClient.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'host', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'user', False, None, 1, ), # 2
  (3, TType.STRING, 'pwd', False, None, 1, ), # 3
)

FTClient.thrift_struct_annotations = {
}
FTClient.thrift_field_annotations = {
}

def FTClient__init__(self, host=None, user=None, pwd=None,):
  self.host = host
  self.user = user
  self.pwd = pwd

FTClient.__init__ = FTClient__init__

def FTClient__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('user', None)
  state.setdefault('pwd', None)
  self.__dict__ = state

FTClient.__getstate__ = lambda self: self.__dict__.copy()
FTClient.__setstate__ = FTClient__setstate__

all_structs.append(SignInFTServiceReq)
SignInFTServiceReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', FTServiceType, None, 2, ), # 1
  (2, TType.LIST, 'clients', (TType.STRUCT,[FTClient, FTClient.thrift_spec, False]), None, 2, ), # 2
)

SignInFTServiceReq.thrift_struct_annotations = {
}
SignInFTServiceReq.thrift_field_annotations = {
}

def SignInFTServiceReq__init__(self, type=None, clients=None,):
  self.type = type
  self.clients = clients

SignInFTServiceReq.__init__ = SignInFTServiceReq__init__

def SignInFTServiceReq__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('clients', None)
  self.__dict__ = state

SignInFTServiceReq.__getstate__ = lambda self: self.__dict__.copy()
SignInFTServiceReq.__setstate__ = SignInFTServiceReq__setstate__

all_structs.append(SignOutFTServiceReq)
SignOutFTServiceReq.thrift_spec = (
)

SignOutFTServiceReq.thrift_struct_annotations = {
}
SignOutFTServiceReq.thrift_field_annotations = {
}

all_structs.append(ListFTClientsReq)
ListFTClientsReq.thrift_spec = (
)

ListFTClientsReq.thrift_struct_annotations = {
}
ListFTClientsReq.thrift_field_annotations = {
}

all_structs.append(ListFTClientsResp)
ListFTClientsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'clients', (TType.STRUCT,[FTClient, FTClient.thrift_spec, False]), None, 2, ), # 3
)

ListFTClientsResp.thrift_struct_annotations = {
}
ListFTClientsResp.thrift_field_annotations = {
}

def ListFTClientsResp__init__(self, code=None, leader=None, clients=None,):
  self.code = code
  self.leader = leader
  self.clients = clients

ListFTClientsResp.__init__ = ListFTClientsResp__init__

def ListFTClientsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('clients', None)
  self.__dict__ = state

ListFTClientsResp.__getstate__ = lambda self: self.__dict__.copy()
ListFTClientsResp.__setstate__ = ListFTClientsResp__setstate__

all_structs.append(Session)
Session.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 2, ), # 1
  (2, TType.I64, 'create_time', None, None, 2, ), # 2
  (3, TType.I64, 'update_time', None, None, 2, ), # 3
  (4, TType.STRING, 'user_name', False, None, 2, ), # 4
  (5, TType.STRING, 'space_name', False, None, 2, ), # 5
  (6, TType.STRUCT, 'graph_addr', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 6
  (7, TType.I32, 'timezone', None, None, 2, ), # 7
  (8, TType.STRING, 'client_ip', False, None, 2, ), # 8
  (9, TType.MAP, 'configs', (TType.STRING,False,TType.STRUCT,[nebula2.common.ttypes.Value, nebula2.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 9
)

Session.thrift_struct_annotations = {
}
Session.thrift_field_annotations = {
}

def Session__init__(self, session_id=None, create_time=None, update_time=None, user_name=None, space_name=None, graph_addr=None, timezone=None, client_ip=None, configs=None,):
  self.session_id = session_id
  self.create_time = create_time
  self.update_time = update_time
  self.user_name = user_name
  self.space_name = space_name
  self.graph_addr = graph_addr
  self.timezone = timezone
  self.client_ip = client_ip
  self.configs = configs

Session.__init__ = Session__init__

def Session__setstate__(self, state):
  state.setdefault('session_id', None)
  state.setdefault('create_time', None)
  state.setdefault('update_time', None)
  state.setdefault('user_name', None)
  state.setdefault('space_name', None)
  state.setdefault('graph_addr', None)
  state.setdefault('timezone', None)
  state.setdefault('client_ip', None)
  state.setdefault('configs', None)
  self.__dict__ = state

Session.__getstate__ = lambda self: self.__dict__.copy()
Session.__setstate__ = Session__setstate__

all_structs.append(CreateSessionReq)
CreateSessionReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'user', False, None, 2, ), # 1
  (2, TType.STRUCT, 'graph_addr', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'client_ip', False, None, 2, ), # 3
)

CreateSessionReq.thrift_struct_annotations = {
}
CreateSessionReq.thrift_field_annotations = {
}

def CreateSessionReq__init__(self, user=None, graph_addr=None, client_ip=None,):
  self.user = user
  self.graph_addr = graph_addr
  self.client_ip = client_ip

CreateSessionReq.__init__ = CreateSessionReq__init__

def CreateSessionReq__setstate__(self, state):
  state.setdefault('user', None)
  state.setdefault('graph_addr', None)
  state.setdefault('client_ip', None)
  self.__dict__ = state

CreateSessionReq.__getstate__ = lambda self: self.__dict__.copy()
CreateSessionReq.__setstate__ = CreateSessionReq__setstate__

all_structs.append(CreateSessionResp)
CreateSessionResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 3
)

CreateSessionResp.thrift_struct_annotations = {
}
CreateSessionResp.thrift_field_annotations = {
}

def CreateSessionResp__init__(self, code=None, leader=None, session=None,):
  self.code = code
  self.leader = leader
  self.session = session

CreateSessionResp.__init__ = CreateSessionResp__init__

def CreateSessionResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('session', None)
  self.__dict__ = state

CreateSessionResp.__getstate__ = lambda self: self.__dict__.copy()
CreateSessionResp.__setstate__ = CreateSessionResp__setstate__

all_structs.append(UpdateSessionsReq)
UpdateSessionsReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'sessions', (TType.STRUCT,[Session, Session.thrift_spec, False]), None, 2, ), # 1
)

UpdateSessionsReq.thrift_struct_annotations = {
}
UpdateSessionsReq.thrift_field_annotations = {
}

def UpdateSessionsReq__init__(self, sessions=None,):
  self.sessions = sessions

UpdateSessionsReq.__init__ = UpdateSessionsReq__init__

def UpdateSessionsReq__setstate__(self, state):
  state.setdefault('sessions', None)
  self.__dict__ = state

UpdateSessionsReq.__getstate__ = lambda self: self.__dict__.copy()
UpdateSessionsReq.__setstate__ = UpdateSessionsReq__setstate__

all_structs.append(ListSessionsReq)
ListSessionsReq.thrift_spec = (
)

ListSessionsReq.thrift_struct_annotations = {
}
ListSessionsReq.thrift_field_annotations = {
}

all_structs.append(ListSessionsResp)
ListSessionsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'sessions', (TType.STRUCT,[Session, Session.thrift_spec, False]), None, 2, ), # 3
)

ListSessionsResp.thrift_struct_annotations = {
}
ListSessionsResp.thrift_field_annotations = {
}

def ListSessionsResp__init__(self, code=None, leader=None, sessions=None,):
  self.code = code
  self.leader = leader
  self.sessions = sessions

ListSessionsResp.__init__ = ListSessionsResp__init__

def ListSessionsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('sessions', None)
  self.__dict__ = state

ListSessionsResp.__getstate__ = lambda self: self.__dict__.copy()
ListSessionsResp.__setstate__ = ListSessionsResp__setstate__

all_structs.append(GetSessionReq)
GetSessionReq.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 2, ), # 1
)

GetSessionReq.thrift_struct_annotations = {
}
GetSessionReq.thrift_field_annotations = {
}

def GetSessionReq__init__(self, session_id=None,):
  self.session_id = session_id

GetSessionReq.__init__ = GetSessionReq__init__

def GetSessionReq__setstate__(self, state):
  state.setdefault('session_id', None)
  self.__dict__ = state

GetSessionReq.__getstate__ = lambda self: self.__dict__.copy()
GetSessionReq.__setstate__ = GetSessionReq__setstate__

all_structs.append(GetSessionResp)
GetSessionResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula2.common.ttypes.HostAddr, nebula2.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 3
)

GetSessionResp.thrift_struct_annotations = {
}
GetSessionResp.thrift_field_annotations = {
}

def GetSessionResp__init__(self, code=None, leader=None, session=None,):
  self.code = code
  self.leader = leader
  self.session = session

GetSessionResp.__init__ = GetSessionResp__init__

def GetSessionResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('session', None)
  self.__dict__ = state

GetSessionResp.__getstate__ = lambda self: self.__dict__.copy()
GetSessionResp.__setstate__ = GetSessionResp__setstate__

all_structs.append(RemoveSessionReq)
RemoveSessionReq.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 2, ), # 1
)

RemoveSessionReq.thrift_struct_annotations = {
}
RemoveSessionReq.thrift_field_annotations = {
}

def RemoveSessionReq__init__(self, session_id=None,):
  self.session_id = session_id

RemoveSessionReq.__init__ = RemoveSessionReq__init__

def RemoveSessionReq__setstate__(self, state):
  state.setdefault('session_id', None)
  self.__dict__ = state

RemoveSessionReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveSessionReq.__setstate__ = RemoveSessionReq__setstate__

all_structs.append(ReportTaskReq)
ReportTaskReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', ErrorCode, None, 2, ), # 1
  (2, TType.I32, 'job_id', None, None, 2, ), # 2
  (3, TType.I32, 'task_id', None, None, 2, ), # 3
  (4, TType.STRUCT, 'statis', [StatisItem, StatisItem.thrift_spec, False], None, 1, ), # 4
)

ReportTaskReq.thrift_struct_annotations = {
}
ReportTaskReq.thrift_field_annotations = {
}

def ReportTaskReq__init__(self, code=None, job_id=None, task_id=None, statis=None,):
  self.code = code
  self.job_id = job_id
  self.task_id = task_id
  self.statis = statis

ReportTaskReq.__init__ = ReportTaskReq__init__

def ReportTaskReq__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  state.setdefault('statis', None)
  self.__dict__ = state

ReportTaskReq.__getstate__ = lambda self: self.__dict__.copy()
ReportTaskReq.__setstate__ = ReportTaskReq__setstate__

fix_spec(all_structs)
del all_structs
