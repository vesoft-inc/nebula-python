#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from nebula3.fbthrift.util.Recursive import fix_spec
from nebula3.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula3.fbthrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from nebula3.fbthrift import Thrift
from nebula3.fbthrift.transport import TTransport
from nebula3.fbthrift.protocol import TBinaryProtocol
from nebula3.fbthrift.protocol import TCompactProtocol
from nebula3.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula3.fbthrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'NullType', 'PropertyType', 'ErrorCode', 'SchemaID', 'Date', 'Time', 'DateTime', 'Value', 'NList', 'NMap', 'NSet', 'Row', 'DataSet', 'Coordinate', 'Point', 'LineString', 'Polygon', 'Geography', 'Tag', 'Vertex', 'Edge', 'Step', 'Path', 'HostAddr', 'KeyValue', 'Duration', 'LogInfo', 'DirInfo', 'CheckpointInfo', 'LogEntry', 'ClusterID', 'GraphSpaceID', 'PartitionID', 'TagID', 'EdgeType', 'EdgeRanking', 'LogID', 'TermID', 'Timestamp', 'IndexID', 'Port', 'SessionID', 'ExecutionPlanID']

class NullType:
  __NULL__ = 0
  NaN = 1
  BAD_DATA = 2
  BAD_TYPE = 3
  ERR_OVERFLOW = 4
  UNKNOWN_PROP = 5
  DIV_BY_ZERO = 6
  OUT_OF_RANGE = 7

  _VALUES_TO_NAMES = {
    0: "__NULL__",
    1: "NaN",
    2: "BAD_DATA",
    3: "BAD_TYPE",
    4: "ERR_OVERFLOW",
    5: "UNKNOWN_PROP",
    6: "DIV_BY_ZERO",
    7: "OUT_OF_RANGE",
  }

  _NAMES_TO_VALUES = {
    "__NULL__": 0,
    "NaN": 1,
    "BAD_DATA": 2,
    "BAD_TYPE": 3,
    "ERR_OVERFLOW": 4,
    "UNKNOWN_PROP": 5,
    "DIV_BY_ZERO": 6,
    "OUT_OF_RANGE": 7,
  }

class PropertyType:
  UNKNOWN = 0
  BOOL = 1
  INT64 = 2
  VID = 3
  FLOAT = 4
  DOUBLE = 5
  STRING = 6
  FIXED_STRING = 7
  INT8 = 8
  INT16 = 9
  INT32 = 10
  TIMESTAMP = 21
  DURATION = 23
  DATE = 24
  DATETIME = 25
  TIME = 26
  GEOGRAPHY = 31

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "BOOL",
    2: "INT64",
    3: "VID",
    4: "FLOAT",
    5: "DOUBLE",
    6: "STRING",
    7: "FIXED_STRING",
    8: "INT8",
    9: "INT16",
    10: "INT32",
    21: "TIMESTAMP",
    23: "DURATION",
    24: "DATE",
    25: "DATETIME",
    26: "TIME",
    31: "GEOGRAPHY",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "BOOL": 1,
    "INT64": 2,
    "VID": 3,
    "FLOAT": 4,
    "DOUBLE": 5,
    "STRING": 6,
    "FIXED_STRING": 7,
    "INT8": 8,
    "INT16": 9,
    "INT32": 10,
    "TIMESTAMP": 21,
    "DURATION": 23,
    "DATE": 24,
    "DATETIME": 25,
    "TIME": 26,
    "GEOGRAPHY": 31,
  }

class ErrorCode:
  SUCCEEDED = 0
  E_DISCONNECTED = -1
  E_FAIL_TO_CONNECT = -2
  E_RPC_FAILURE = -3
  E_LEADER_CHANGED = -4
  E_SPACE_NOT_FOUND = -5
  E_TAG_NOT_FOUND = -6
  E_EDGE_NOT_FOUND = -7
  E_INDEX_NOT_FOUND = -8
  E_EDGE_PROP_NOT_FOUND = -9
  E_TAG_PROP_NOT_FOUND = -10
  E_ROLE_NOT_FOUND = -11
  E_CONFIG_NOT_FOUND = -12
  E_MACHINE_NOT_FOUND = -13
  E_ZONE_NOT_FOUND = -14
  E_LISTENER_NOT_FOUND = -15
  E_PART_NOT_FOUND = -16
  E_KEY_NOT_FOUND = -17
  E_USER_NOT_FOUND = -18
  E_STATS_NOT_FOUND = -19
  E_SERVICE_NOT_FOUND = -20
  E_BACKUP_FAILED = -24
  E_BACKUP_EMPTY_TABLE = -25
  E_BACKUP_TABLE_FAILED = -26
  E_PARTIAL_RESULT = -27
  E_REBUILD_INDEX_FAILED = -28
  E_INVALID_PASSWORD = -29
  E_FAILED_GET_ABS_PATH = -30
  E_BAD_USERNAME_PASSWORD = -1001
  E_SESSION_INVALID = -1002
  E_SESSION_TIMEOUT = -1003
  E_SYNTAX_ERROR = -1004
  E_EXECUTION_ERROR = -1005
  E_STATEMENT_EMPTY = -1006
  E_BAD_PERMISSION = -1008
  E_SEMANTIC_ERROR = -1009
  E_TOO_MANY_CONNECTIONS = -1010
  E_PARTIAL_SUCCEEDED = -1011
  E_NO_HOSTS = -2001
  E_EXISTED = -2002
  E_INVALID_HOST = -2003
  E_UNSUPPORTED = -2004
  E_NOT_DROP = -2005
  E_BALANCER_RUNNING = -2006
  E_CONFIG_IMMUTABLE = -2007
  E_CONFLICT = -2008
  E_INVALID_PARM = -2009
  E_WRONGCLUSTER = -2010
  E_ZONE_NOT_ENOUGH = -2011
  E_ZONE_IS_EMPTY = -2012
  E_STORE_FAILURE = -2021
  E_STORE_SEGMENT_ILLEGAL = -2022
  E_BAD_BALANCE_PLAN = -2023
  E_BALANCED = -2024
  E_NO_RUNNING_BALANCE_PLAN = -2025
  E_NO_VALID_HOST = -2026
  E_CORRUPTED_BALANCE_PLAN = -2027
  E_NO_INVALID_BALANCE_PLAN = -2028
  E_IMPROPER_ROLE = -2030
  E_INVALID_PARTITION_NUM = -2031
  E_INVALID_REPLICA_FACTOR = -2032
  E_INVALID_CHARSET = -2033
  E_INVALID_COLLATE = -2034
  E_CHARSET_COLLATE_NOT_MATCH = -2035
  E_SNAPSHOT_FAILURE = -2040
  E_BLOCK_WRITE_FAILURE = -2041
  E_REBUILD_INDEX_FAILURE = -2042
  E_INDEX_WITH_TTL = -2043
  E_ADD_JOB_FAILURE = -2044
  E_STOP_JOB_FAILURE = -2045
  E_SAVE_JOB_FAILURE = -2046
  E_BALANCER_FAILURE = -2047
  E_JOB_NOT_FINISHED = -2048
  E_TASK_REPORT_OUT_DATE = -2049
  E_JOB_NOT_IN_SPACE = -2050
  E_JOB_NEED_RECOVER = -2051
  E_INVALID_JOB = -2065
  E_BACKUP_BUILDING_INDEX = -2066
  E_BACKUP_SPACE_NOT_FOUND = -2067
  E_RESTORE_FAILURE = -2068
  E_SESSION_NOT_FOUND = -2069
  E_LIST_CLUSTER_FAILURE = -2070
  E_LIST_CLUSTER_GET_ABS_PATH_FAILURE = -2071
  E_LIST_CLUSTER_NO_AGENT_FAILURE = -2072
  E_QUERY_NOT_FOUND = -2073
  E_AGENT_HB_FAILUE = -2074
  E_CONSENSUS_ERROR = -3001
  E_KEY_HAS_EXISTS = -3002
  E_DATA_TYPE_MISMATCH = -3003
  E_INVALID_FIELD_VALUE = -3004
  E_INVALID_OPERATION = -3005
  E_NOT_NULLABLE = -3006
  E_FIELD_UNSET = -3007
  E_OUT_OF_RANGE = -3008
  E_DATA_CONFLICT_ERROR = -3010
  E_WRITE_STALLED = -3011
  E_IMPROPER_DATA_TYPE = -3021
  E_INVALID_SPACEVIDLEN = -3022
  E_INVALID_FILTER = -3031
  E_INVALID_UPDATER = -3032
  E_INVALID_STORE = -3033
  E_INVALID_PEER = -3034
  E_RETRY_EXHAUSTED = -3035
  E_TRANSFER_LEADER_FAILED = -3036
  E_INVALID_STAT_TYPE = -3037
  E_INVALID_VID = -3038
  E_NO_TRANSFORMED = -3039
  E_LOAD_META_FAILED = -3040
  E_FAILED_TO_CHECKPOINT = -3041
  E_CHECKPOINT_BLOCKED = -3042
  E_FILTER_OUT = -3043
  E_INVALID_DATA = -3044
  E_MUTATE_EDGE_CONFLICT = -3045
  E_MUTATE_TAG_CONFLICT = -3046
  E_OUTDATED_LOCK = -3047
  E_INVALID_TASK_PARA = -3051
  E_USER_CANCEL = -3052
  E_TASK_EXECUTION_FAILED = -3053
  E_PLAN_IS_KILLED = -3060
  E_NO_TERM = -3070
  E_OUTDATED_TERM = -3071
  E_OUTDATED_EDGE = -3072
  E_WRITE_WRITE_CONFLICT = -3073
  E_CLIENT_SERVER_INCOMPATIBLE = -3061
  E_ID_FAILED = -3062
  E_RAFT_UNKNOWN_PART = -3500
  E_RAFT_LOG_GAP = -3501
  E_RAFT_LOG_STALE = -3502
  E_RAFT_TERM_OUT_OF_DATE = -3503
  E_RAFT_UNKNOWN_APPEND_LOG = -3504
  E_RAFT_WAITING_SNAPSHOT = -3511
  E_RAFT_SENDING_SNAPSHOT = -3512
  E_RAFT_INVALID_PEER = -3513
  E_RAFT_NOT_READY = -3514
  E_RAFT_STOPPED = -3515
  E_RAFT_BAD_ROLE = -3516
  E_RAFT_WAL_FAIL = -3521
  E_RAFT_HOST_STOPPED = -3522
  E_RAFT_TOO_MANY_REQUESTS = -3523
  E_RAFT_PERSIST_SNAPSHOT_FAILED = -3524
  E_RAFT_RPC_EXCEPTION = -3525
  E_RAFT_NO_WAL_FOUND = -3526
  E_RAFT_HOST_PAUSED = -3527
  E_RAFT_WRITE_BLOCKED = -3528
  E_RAFT_BUFFER_OVERFLOW = -3529
  E_RAFT_ATOMIC_OP_FAILED = -3530
  E_LEADER_LEASE_FAILED = -3531
  E_UNKNOWN = -8000

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    -1: "E_DISCONNECTED",
    -2: "E_FAIL_TO_CONNECT",
    -3: "E_RPC_FAILURE",
    -4: "E_LEADER_CHANGED",
    -5: "E_SPACE_NOT_FOUND",
    -6: "E_TAG_NOT_FOUND",
    -7: "E_EDGE_NOT_FOUND",
    -8: "E_INDEX_NOT_FOUND",
    -9: "E_EDGE_PROP_NOT_FOUND",
    -10: "E_TAG_PROP_NOT_FOUND",
    -11: "E_ROLE_NOT_FOUND",
    -12: "E_CONFIG_NOT_FOUND",
    -13: "E_MACHINE_NOT_FOUND",
    -14: "E_ZONE_NOT_FOUND",
    -15: "E_LISTENER_NOT_FOUND",
    -16: "E_PART_NOT_FOUND",
    -17: "E_KEY_NOT_FOUND",
    -18: "E_USER_NOT_FOUND",
    -19: "E_STATS_NOT_FOUND",
    -20: "E_SERVICE_NOT_FOUND",
    -24: "E_BACKUP_FAILED",
    -25: "E_BACKUP_EMPTY_TABLE",
    -26: "E_BACKUP_TABLE_FAILED",
    -27: "E_PARTIAL_RESULT",
    -28: "E_REBUILD_INDEX_FAILED",
    -29: "E_INVALID_PASSWORD",
    -30: "E_FAILED_GET_ABS_PATH",
    -1001: "E_BAD_USERNAME_PASSWORD",
    -1002: "E_SESSION_INVALID",
    -1003: "E_SESSION_TIMEOUT",
    -1004: "E_SYNTAX_ERROR",
    -1005: "E_EXECUTION_ERROR",
    -1006: "E_STATEMENT_EMPTY",
    -1008: "E_BAD_PERMISSION",
    -1009: "E_SEMANTIC_ERROR",
    -1010: "E_TOO_MANY_CONNECTIONS",
    -1011: "E_PARTIAL_SUCCEEDED",
    -2001: "E_NO_HOSTS",
    -2002: "E_EXISTED",
    -2003: "E_INVALID_HOST",
    -2004: "E_UNSUPPORTED",
    -2005: "E_NOT_DROP",
    -2006: "E_BALANCER_RUNNING",
    -2007: "E_CONFIG_IMMUTABLE",
    -2008: "E_CONFLICT",
    -2009: "E_INVALID_PARM",
    -2010: "E_WRONGCLUSTER",
    -2011: "E_ZONE_NOT_ENOUGH",
    -2012: "E_ZONE_IS_EMPTY",
    -2021: "E_STORE_FAILURE",
    -2022: "E_STORE_SEGMENT_ILLEGAL",
    -2023: "E_BAD_BALANCE_PLAN",
    -2024: "E_BALANCED",
    -2025: "E_NO_RUNNING_BALANCE_PLAN",
    -2026: "E_NO_VALID_HOST",
    -2027: "E_CORRUPTED_BALANCE_PLAN",
    -2028: "E_NO_INVALID_BALANCE_PLAN",
    -2030: "E_IMPROPER_ROLE",
    -2031: "E_INVALID_PARTITION_NUM",
    -2032: "E_INVALID_REPLICA_FACTOR",
    -2033: "E_INVALID_CHARSET",
    -2034: "E_INVALID_COLLATE",
    -2035: "E_CHARSET_COLLATE_NOT_MATCH",
    -2040: "E_SNAPSHOT_FAILURE",
    -2041: "E_BLOCK_WRITE_FAILURE",
    -2042: "E_REBUILD_INDEX_FAILURE",
    -2043: "E_INDEX_WITH_TTL",
    -2044: "E_ADD_JOB_FAILURE",
    -2045: "E_STOP_JOB_FAILURE",
    -2046: "E_SAVE_JOB_FAILURE",
    -2047: "E_BALANCER_FAILURE",
    -2048: "E_JOB_NOT_FINISHED",
    -2049: "E_TASK_REPORT_OUT_DATE",
    -2050: "E_JOB_NOT_IN_SPACE",
    -2051: "E_JOB_NEED_RECOVER",
    -2065: "E_INVALID_JOB",
    -2066: "E_BACKUP_BUILDING_INDEX",
    -2067: "E_BACKUP_SPACE_NOT_FOUND",
    -2068: "E_RESTORE_FAILURE",
    -2069: "E_SESSION_NOT_FOUND",
    -2070: "E_LIST_CLUSTER_FAILURE",
    -2071: "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE",
    -2072: "E_LIST_CLUSTER_NO_AGENT_FAILURE",
    -2073: "E_QUERY_NOT_FOUND",
    -2074: "E_AGENT_HB_FAILUE",
    -3001: "E_CONSENSUS_ERROR",
    -3002: "E_KEY_HAS_EXISTS",
    -3003: "E_DATA_TYPE_MISMATCH",
    -3004: "E_INVALID_FIELD_VALUE",
    -3005: "E_INVALID_OPERATION",
    -3006: "E_NOT_NULLABLE",
    -3007: "E_FIELD_UNSET",
    -3008: "E_OUT_OF_RANGE",
    -3010: "E_DATA_CONFLICT_ERROR",
    -3011: "E_WRITE_STALLED",
    -3021: "E_IMPROPER_DATA_TYPE",
    -3022: "E_INVALID_SPACEVIDLEN",
    -3031: "E_INVALID_FILTER",
    -3032: "E_INVALID_UPDATER",
    -3033: "E_INVALID_STORE",
    -3034: "E_INVALID_PEER",
    -3035: "E_RETRY_EXHAUSTED",
    -3036: "E_TRANSFER_LEADER_FAILED",
    -3037: "E_INVALID_STAT_TYPE",
    -3038: "E_INVALID_VID",
    -3039: "E_NO_TRANSFORMED",
    -3040: "E_LOAD_META_FAILED",
    -3041: "E_FAILED_TO_CHECKPOINT",
    -3042: "E_CHECKPOINT_BLOCKED",
    -3043: "E_FILTER_OUT",
    -3044: "E_INVALID_DATA",
    -3045: "E_MUTATE_EDGE_CONFLICT",
    -3046: "E_MUTATE_TAG_CONFLICT",
    -3047: "E_OUTDATED_LOCK",
    -3051: "E_INVALID_TASK_PARA",
    -3052: "E_USER_CANCEL",
    -3053: "E_TASK_EXECUTION_FAILED",
    -3060: "E_PLAN_IS_KILLED",
    -3070: "E_NO_TERM",
    -3071: "E_OUTDATED_TERM",
    -3072: "E_OUTDATED_EDGE",
    -3073: "E_WRITE_WRITE_CONFLICT",
    -3061: "E_CLIENT_SERVER_INCOMPATIBLE",
    -3062: "E_ID_FAILED",
    -3500: "E_RAFT_UNKNOWN_PART",
    -3501: "E_RAFT_LOG_GAP",
    -3502: "E_RAFT_LOG_STALE",
    -3503: "E_RAFT_TERM_OUT_OF_DATE",
    -3504: "E_RAFT_UNKNOWN_APPEND_LOG",
    -3511: "E_RAFT_WAITING_SNAPSHOT",
    -3512: "E_RAFT_SENDING_SNAPSHOT",
    -3513: "E_RAFT_INVALID_PEER",
    -3514: "E_RAFT_NOT_READY",
    -3515: "E_RAFT_STOPPED",
    -3516: "E_RAFT_BAD_ROLE",
    -3521: "E_RAFT_WAL_FAIL",
    -3522: "E_RAFT_HOST_STOPPED",
    -3523: "E_RAFT_TOO_MANY_REQUESTS",
    -3524: "E_RAFT_PERSIST_SNAPSHOT_FAILED",
    -3525: "E_RAFT_RPC_EXCEPTION",
    -3526: "E_RAFT_NO_WAL_FOUND",
    -3527: "E_RAFT_HOST_PAUSED",
    -3528: "E_RAFT_WRITE_BLOCKED",
    -3529: "E_RAFT_BUFFER_OVERFLOW",
    -3530: "E_RAFT_ATOMIC_OP_FAILED",
    -3531: "E_LEADER_LEASE_FAILED",
    -8000: "E_UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "E_DISCONNECTED": -1,
    "E_FAIL_TO_CONNECT": -2,
    "E_RPC_FAILURE": -3,
    "E_LEADER_CHANGED": -4,
    "E_SPACE_NOT_FOUND": -5,
    "E_TAG_NOT_FOUND": -6,
    "E_EDGE_NOT_FOUND": -7,
    "E_INDEX_NOT_FOUND": -8,
    "E_EDGE_PROP_NOT_FOUND": -9,
    "E_TAG_PROP_NOT_FOUND": -10,
    "E_ROLE_NOT_FOUND": -11,
    "E_CONFIG_NOT_FOUND": -12,
    "E_MACHINE_NOT_FOUND": -13,
    "E_ZONE_NOT_FOUND": -14,
    "E_LISTENER_NOT_FOUND": -15,
    "E_PART_NOT_FOUND": -16,
    "E_KEY_NOT_FOUND": -17,
    "E_USER_NOT_FOUND": -18,
    "E_STATS_NOT_FOUND": -19,
    "E_SERVICE_NOT_FOUND": -20,
    "E_BACKUP_FAILED": -24,
    "E_BACKUP_EMPTY_TABLE": -25,
    "E_BACKUP_TABLE_FAILED": -26,
    "E_PARTIAL_RESULT": -27,
    "E_REBUILD_INDEX_FAILED": -28,
    "E_INVALID_PASSWORD": -29,
    "E_FAILED_GET_ABS_PATH": -30,
    "E_BAD_USERNAME_PASSWORD": -1001,
    "E_SESSION_INVALID": -1002,
    "E_SESSION_TIMEOUT": -1003,
    "E_SYNTAX_ERROR": -1004,
    "E_EXECUTION_ERROR": -1005,
    "E_STATEMENT_EMPTY": -1006,
    "E_BAD_PERMISSION": -1008,
    "E_SEMANTIC_ERROR": -1009,
    "E_TOO_MANY_CONNECTIONS": -1010,
    "E_PARTIAL_SUCCEEDED": -1011,
    "E_NO_HOSTS": -2001,
    "E_EXISTED": -2002,
    "E_INVALID_HOST": -2003,
    "E_UNSUPPORTED": -2004,
    "E_NOT_DROP": -2005,
    "E_BALANCER_RUNNING": -2006,
    "E_CONFIG_IMMUTABLE": -2007,
    "E_CONFLICT": -2008,
    "E_INVALID_PARM": -2009,
    "E_WRONGCLUSTER": -2010,
    "E_ZONE_NOT_ENOUGH": -2011,
    "E_ZONE_IS_EMPTY": -2012,
    "E_STORE_FAILURE": -2021,
    "E_STORE_SEGMENT_ILLEGAL": -2022,
    "E_BAD_BALANCE_PLAN": -2023,
    "E_BALANCED": -2024,
    "E_NO_RUNNING_BALANCE_PLAN": -2025,
    "E_NO_VALID_HOST": -2026,
    "E_CORRUPTED_BALANCE_PLAN": -2027,
    "E_NO_INVALID_BALANCE_PLAN": -2028,
    "E_IMPROPER_ROLE": -2030,
    "E_INVALID_PARTITION_NUM": -2031,
    "E_INVALID_REPLICA_FACTOR": -2032,
    "E_INVALID_CHARSET": -2033,
    "E_INVALID_COLLATE": -2034,
    "E_CHARSET_COLLATE_NOT_MATCH": -2035,
    "E_SNAPSHOT_FAILURE": -2040,
    "E_BLOCK_WRITE_FAILURE": -2041,
    "E_REBUILD_INDEX_FAILURE": -2042,
    "E_INDEX_WITH_TTL": -2043,
    "E_ADD_JOB_FAILURE": -2044,
    "E_STOP_JOB_FAILURE": -2045,
    "E_SAVE_JOB_FAILURE": -2046,
    "E_BALANCER_FAILURE": -2047,
    "E_JOB_NOT_FINISHED": -2048,
    "E_TASK_REPORT_OUT_DATE": -2049,
    "E_JOB_NOT_IN_SPACE": -2050,
    "E_JOB_NEED_RECOVER": -2051,
    "E_INVALID_JOB": -2065,
    "E_BACKUP_BUILDING_INDEX": -2066,
    "E_BACKUP_SPACE_NOT_FOUND": -2067,
    "E_RESTORE_FAILURE": -2068,
    "E_SESSION_NOT_FOUND": -2069,
    "E_LIST_CLUSTER_FAILURE": -2070,
    "E_LIST_CLUSTER_GET_ABS_PATH_FAILURE": -2071,
    "E_LIST_CLUSTER_NO_AGENT_FAILURE": -2072,
    "E_QUERY_NOT_FOUND": -2073,
    "E_AGENT_HB_FAILUE": -2074,
    "E_CONSENSUS_ERROR": -3001,
    "E_KEY_HAS_EXISTS": -3002,
    "E_DATA_TYPE_MISMATCH": -3003,
    "E_INVALID_FIELD_VALUE": -3004,
    "E_INVALID_OPERATION": -3005,
    "E_NOT_NULLABLE": -3006,
    "E_FIELD_UNSET": -3007,
    "E_OUT_OF_RANGE": -3008,
    "E_DATA_CONFLICT_ERROR": -3010,
    "E_WRITE_STALLED": -3011,
    "E_IMPROPER_DATA_TYPE": -3021,
    "E_INVALID_SPACEVIDLEN": -3022,
    "E_INVALID_FILTER": -3031,
    "E_INVALID_UPDATER": -3032,
    "E_INVALID_STORE": -3033,
    "E_INVALID_PEER": -3034,
    "E_RETRY_EXHAUSTED": -3035,
    "E_TRANSFER_LEADER_FAILED": -3036,
    "E_INVALID_STAT_TYPE": -3037,
    "E_INVALID_VID": -3038,
    "E_NO_TRANSFORMED": -3039,
    "E_LOAD_META_FAILED": -3040,
    "E_FAILED_TO_CHECKPOINT": -3041,
    "E_CHECKPOINT_BLOCKED": -3042,
    "E_FILTER_OUT": -3043,
    "E_INVALID_DATA": -3044,
    "E_MUTATE_EDGE_CONFLICT": -3045,
    "E_MUTATE_TAG_CONFLICT": -3046,
    "E_OUTDATED_LOCK": -3047,
    "E_INVALID_TASK_PARA": -3051,
    "E_USER_CANCEL": -3052,
    "E_TASK_EXECUTION_FAILED": -3053,
    "E_PLAN_IS_KILLED": -3060,
    "E_NO_TERM": -3070,
    "E_OUTDATED_TERM": -3071,
    "E_OUTDATED_EDGE": -3072,
    "E_WRITE_WRITE_CONFLICT": -3073,
    "E_CLIENT_SERVER_INCOMPATIBLE": -3061,
    "E_ID_FAILED": -3062,
    "E_RAFT_UNKNOWN_PART": -3500,
    "E_RAFT_LOG_GAP": -3501,
    "E_RAFT_LOG_STALE": -3502,
    "E_RAFT_TERM_OUT_OF_DATE": -3503,
    "E_RAFT_UNKNOWN_APPEND_LOG": -3504,
    "E_RAFT_WAITING_SNAPSHOT": -3511,
    "E_RAFT_SENDING_SNAPSHOT": -3512,
    "E_RAFT_INVALID_PEER": -3513,
    "E_RAFT_NOT_READY": -3514,
    "E_RAFT_STOPPED": -3515,
    "E_RAFT_BAD_ROLE": -3516,
    "E_RAFT_WAL_FAIL": -3521,
    "E_RAFT_HOST_STOPPED": -3522,
    "E_RAFT_TOO_MANY_REQUESTS": -3523,
    "E_RAFT_PERSIST_SNAPSHOT_FAILED": -3524,
    "E_RAFT_RPC_EXCEPTION": -3525,
    "E_RAFT_NO_WAL_FOUND": -3526,
    "E_RAFT_HOST_PAUSED": -3527,
    "E_RAFT_WRITE_BLOCKED": -3528,
    "E_RAFT_BUFFER_OVERFLOW": -3529,
    "E_RAFT_ATOMIC_OP_FAILED": -3530,
    "E_LEADER_LEASE_FAILED": -3531,
    "E_UNKNOWN": -8000,
  }

class SchemaID(object):
  """
  Attributes:
   - tag_id
   - edge_type
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  TAG_ID = 1
  EDGE_TYPE = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_tag_id(self):
    assert self.field == 1
    return self.value

  def get_edge_type(self):
    assert self.field == 2
    return self.value

  def set_tag_id(self, value):
    self.field = 1
    self.value = value

  def set_edge_type(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tag_id', value)
    if self.field == 2:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('edge_type', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          tag_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_tag_id(tag_id)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          edge_type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_edge_type(edge_type)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('SchemaID')
    if self.field == 1:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      tag_id = self.value
      oprot.writeI32(tag_id)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      edge_type = self.value
      oprot.writeI32(edge_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Date:
  """
  Attributes:
   - year
   - month
   - day
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Date')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Time:
  """
  Attributes:
   - hour
   - minute
   - sec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.sec = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.microsec = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Time')
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 1)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 2)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.BYTE, 3)
      oprot.writeByte(self.sec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I32, 4)
      oprot.writeI32(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.sec is not None:
      value = pprint.pformat(self.sec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DateTime:
  """
  Attributes:
   - year
   - month
   - day
   - hour
   - minute
   - sec
   - microsec
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.year = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.month = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.day = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.hour = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.minute = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.sec = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.microsec = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DateTime')
    if self.year != None:
      oprot.writeFieldBegin('year', TType.I16, 1)
      oprot.writeI16(self.year)
      oprot.writeFieldEnd()
    if self.month != None:
      oprot.writeFieldBegin('month', TType.BYTE, 2)
      oprot.writeByte(self.month)
      oprot.writeFieldEnd()
    if self.day != None:
      oprot.writeFieldBegin('day', TType.BYTE, 3)
      oprot.writeByte(self.day)
      oprot.writeFieldEnd()
    if self.hour != None:
      oprot.writeFieldBegin('hour', TType.BYTE, 4)
      oprot.writeByte(self.hour)
      oprot.writeFieldEnd()
    if self.minute != None:
      oprot.writeFieldBegin('minute', TType.BYTE, 5)
      oprot.writeByte(self.minute)
      oprot.writeFieldEnd()
    if self.sec != None:
      oprot.writeFieldBegin('sec', TType.BYTE, 6)
      oprot.writeByte(self.sec)
      oprot.writeFieldEnd()
    if self.microsec != None:
      oprot.writeFieldBegin('microsec', TType.I32, 7)
      oprot.writeI32(self.microsec)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.year is not None:
      value = pprint.pformat(self.year, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    year=%s' % (value))
    if self.month is not None:
      value = pprint.pformat(self.month, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    month=%s' % (value))
    if self.day is not None:
      value = pprint.pformat(self.day, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    day=%s' % (value))
    if self.hour is not None:
      value = pprint.pformat(self.hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hour=%s' % (value))
    if self.minute is not None:
      value = pprint.pformat(self.minute, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    minute=%s' % (value))
    if self.sec is not None:
      value = pprint.pformat(self.sec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sec=%s' % (value))
    if self.microsec is not None:
      value = pprint.pformat(self.microsec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microsec=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Value(object):
  """
  Attributes:
   - nVal
   - bVal
   - iVal
   - fVal
   - sVal
   - dVal
   - tVal
   - dtVal
   - vVal
   - eVal
   - pVal
   - lVal
   - mVal
   - uVal
   - gVal
   - ggVal
   - duVal
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  NVAL = 1
  BVAL = 2
  IVAL = 3
  FVAL = 4
  SVAL = 5
  DVAL = 6
  TVAL = 7
  DTVAL = 8
  VVAL = 9
  EVAL = 10
  PVAL = 11
  LVAL = 12
  MVAL = 13
  UVAL = 14
  GVAL = 15
  GGVAL = 16
  DUVAL = 17
  
  @staticmethod
  def isUnion():
    return True

  def get_nVal(self):
    assert self.field == 1
    return self.value

  def get_bVal(self):
    assert self.field == 2
    return self.value

  def get_iVal(self):
    assert self.field == 3
    return self.value

  def get_fVal(self):
    assert self.field == 4
    return self.value

  def get_sVal(self):
    assert self.field == 5
    return self.value

  def get_dVal(self):
    assert self.field == 6
    return self.value

  def get_tVal(self):
    assert self.field == 7
    return self.value

  def get_dtVal(self):
    assert self.field == 8
    return self.value

  def get_vVal(self):
    assert self.field == 9
    return self.value

  def get_eVal(self):
    assert self.field == 10
    return self.value

  def get_pVal(self):
    assert self.field == 11
    return self.value

  def get_lVal(self):
    assert self.field == 12
    return self.value

  def get_mVal(self):
    assert self.field == 13
    return self.value

  def get_uVal(self):
    assert self.field == 14
    return self.value

  def get_gVal(self):
    assert self.field == 15
    return self.value

  def get_ggVal(self):
    assert self.field == 16
    return self.value

  def get_duVal(self):
    assert self.field == 17
    return self.value

  def set_nVal(self, value):
    self.field = 1
    self.value = value

  def set_bVal(self, value):
    self.field = 2
    self.value = value

  def set_iVal(self, value):
    self.field = 3
    self.value = value

  def set_fVal(self, value):
    self.field = 4
    self.value = value

  def set_sVal(self, value):
    self.field = 5
    self.value = value

  def set_dVal(self, value):
    self.field = 6
    self.value = value

  def set_tVal(self, value):
    self.field = 7
    self.value = value

  def set_dtVal(self, value):
    self.field = 8
    self.value = value

  def set_vVal(self, value):
    self.field = 9
    self.value = value

  def set_eVal(self, value):
    self.field = 10
    self.value = value

  def set_pVal(self, value):
    self.field = 11
    self.value = value

  def set_lVal(self, value):
    self.field = 12
    self.value = value

  def set_mVal(self, value):
    self.field = 13
    self.value = value

  def set_uVal(self, value):
    self.field = 14
    self.value = value

  def set_gVal(self, value):
    self.field = 15
    self.value = value

  def set_ggVal(self, value):
    self.field = 16
    self.value = value

  def set_duVal(self, value):
    self.field = 17
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('nVal', value)
    if self.field == 2:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bVal', value)
    if self.field == 3:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('iVal', value)
    if self.field == 4:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('fVal', value)
    if self.field == 5:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('sVal', value)
    if self.field == 6:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dVal', value)
    if self.field == 7:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tVal', value)
    if self.field == 8:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('dtVal', value)
    if self.field == 9:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('vVal', value)
    if self.field == 10:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('eVal', value)
    if self.field == 11:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('pVal', value)
    if self.field == 12:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('lVal', value)
    if self.field == 13:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mVal', value)
    if self.field == 14:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('uVal', value)
    if self.field == 15:
      padding = ' ' * 5
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('gVal', value)
    if self.field == 16:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('ggVal', value)
    if self.field == 17:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('duVal', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          nVal = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_nVal(nVal)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          bVal = iprot.readBool()
          assert self.field == 0 and self.value is None
          self.set_bVal(bVal)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          iVal = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_iVal(iVal)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          fVal = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_fVal(fVal)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          sVal = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_sVal(sVal)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          dVal = Date()
          dVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dVal(dVal)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          tVal = Time()
          tVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_tVal(tVal)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          dtVal = DateTime()
          dtVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_dtVal(dtVal)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          vVal = Vertex()
          vVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_vVal(vVal)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          eVal = Edge()
          eVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_eVal(eVal)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          pVal = Path()
          pVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_pVal(pVal)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          lVal = NList()
          lVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_lVal(lVal)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          mVal = NMap()
          mVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_mVal(mVal)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          uVal = NSet()
          uVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_uVal(uVal)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          gVal = DataSet()
          gVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_gVal(gVal)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          ggVal = Geography()
          ggVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_ggVal(ggVal)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          duVal = Duration()
          duVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_duVal(duVal)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Value')
    if self.field == 1:
      oprot.writeFieldBegin('nVal', TType.I32, 1)
      nVal = self.value
      oprot.writeI32(nVal)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('bVal', TType.BOOL, 2)
      bVal = self.value
      oprot.writeBool(bVal)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('iVal', TType.I64, 3)
      iVal = self.value
      oprot.writeI64(iVal)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('fVal', TType.DOUBLE, 4)
      fVal = self.value
      oprot.writeDouble(fVal)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('sVal', TType.STRING, 5)
      sVal = self.value
      oprot.writeString(sVal)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('dVal', TType.STRUCT, 6)
      dVal = self.value
      dVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('tVal', TType.STRUCT, 7)
      tVal = self.value
      tVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('dtVal', TType.STRUCT, 8)
      dtVal = self.value
      dtVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('vVal', TType.STRUCT, 9)
      vVal = self.value
      vVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('eVal', TType.STRUCT, 10)
      eVal = self.value
      eVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('pVal', TType.STRUCT, 11)
      pVal = self.value
      pVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 12:
      oprot.writeFieldBegin('lVal', TType.STRUCT, 12)
      lVal = self.value
      lVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 13:
      oprot.writeFieldBegin('mVal', TType.STRUCT, 13)
      mVal = self.value
      mVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 14:
      oprot.writeFieldBegin('uVal', TType.STRUCT, 14)
      uVal = self.value
      uVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 15:
      oprot.writeFieldBegin('gVal', TType.STRUCT, 15)
      gVal = self.value
      gVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 16:
      oprot.writeFieldBegin('ggVal', TType.STRUCT, 16)
      ggVal = self.value
      ggVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 17:
      oprot.writeFieldBegin('duVal', TType.STRUCT, 17)
      duVal = self.value
      duVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NList:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = Value()
              _elem5.read(iprot)
              self.values.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = Value()
              _elem6.read(iprot)
              self.values.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NList')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter7 in self.values:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NMap:
  """
  Attributes:
   - kvs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.kvs = {}
          (_ktype9, _vtype10, _size8 ) = iprot.readMapBegin() 
          if _size8 >= 0:
            for _i12 in range(_size8):
              _key13 = iprot.readString()
              _val14 = Value()
              _val14.read(iprot)
              self.kvs[_key13] = _val14
          else: 
            while iprot.peekMap():
              _key15 = iprot.readString()
              _val16 = Value()
              _val16.read(iprot)
              self.kvs[_key15] = _val16
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NMap')
    if self.kvs != None:
      oprot.writeFieldBegin('kvs', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.kvs))
      for kiter17,viter18 in self.kvs.items():
        oprot.writeString(kiter17)
        viter18.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.kvs is not None:
      value = pprint.pformat(self.kvs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    kvs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NSet:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.values = set()
          (_etype22, _size19) = iprot.readSetBegin()
          if _size19 >= 0:
            for _i23 in range(_size19):
              _elem24 = Value()
              _elem24.read(iprot)
              self.values.add(_elem24)
          else: 
            while iprot.peekSet():
              _elem25 = Value()
              _elem25.read(iprot)
              self.values.add(_elem25)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NSet')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.SET, 1)
      oprot.writeSetBegin(TType.STRUCT, len(self.values))
      for iter26 in self.values:
        iter26.write(oprot)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Row:
  """
  Attributes:
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.values = []
          (_etype30, _size27) = iprot.readListBegin()
          if _size27 >= 0:
            for _i31 in range(_size27):
              _elem32 = Value()
              _elem32.read(iprot)
              self.values.append(_elem32)
          else: 
            while iprot.peekList():
              _elem33 = Value()
              _elem33.read(iprot)
              self.values.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Row')
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.values))
      for iter34 in self.values:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DataSet:
  """
  Attributes:
   - column_names
   - rows
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in range(_size35):
              _elem40 = iprot.readString()
              self.column_names.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = iprot.readString()
              self.column_names.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.rows = []
          (_etype45, _size42) = iprot.readListBegin()
          if _size42 >= 0:
            for _i46 in range(_size42):
              _elem47 = Row()
              _elem47.read(iprot)
              self.rows.append(_elem47)
          else: 
            while iprot.peekList():
              _elem48 = Row()
              _elem48.read(iprot)
              self.rows.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DataSet')
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter49 in self.column_names:
        oprot.writeString(iter49)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rows != None:
      oprot.writeFieldBegin('rows', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.rows))
      for iter50 in self.rows:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.rows is not None:
      value = pprint.pformat(self.rows, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    rows=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Coordinate:
  """
  Attributes:
   - x
   - y
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.x = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.y = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Coordinate')
    if self.x != None:
      oprot.writeFieldBegin('x', TType.DOUBLE, 1)
      oprot.writeDouble(self.x)
      oprot.writeFieldEnd()
    if self.y != None:
      oprot.writeFieldBegin('y', TType.DOUBLE, 2)
      oprot.writeDouble(self.y)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.x is not None:
      value = pprint.pformat(self.x, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    x=%s' % (value))
    if self.y is not None:
      value = pprint.pformat(self.y, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    y=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Point:
  """
  Attributes:
   - coord
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.coord = Coordinate()
          self.coord.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Point')
    if self.coord != None:
      oprot.writeFieldBegin('coord', TType.STRUCT, 1)
      self.coord.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.coord is not None:
      value = pprint.pformat(self.coord, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    coord=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LineString:
  """
  Attributes:
   - coordList
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.coordList = []
          (_etype54, _size51) = iprot.readListBegin()
          if _size51 >= 0:
            for _i55 in range(_size51):
              _elem56 = Coordinate()
              _elem56.read(iprot)
              self.coordList.append(_elem56)
          else: 
            while iprot.peekList():
              _elem57 = Coordinate()
              _elem57.read(iprot)
              self.coordList.append(_elem57)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LineString')
    if self.coordList != None:
      oprot.writeFieldBegin('coordList', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.coordList))
      for iter58 in self.coordList:
        iter58.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.coordList is not None:
      value = pprint.pformat(self.coordList, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    coordList=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Polygon:
  """
  Attributes:
   - coordListList
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.coordListList = []
          (_etype62, _size59) = iprot.readListBegin()
          if _size59 >= 0:
            for _i63 in range(_size59):
              _elem64 = []
              (_etype68, _size65) = iprot.readListBegin()
              if _size65 >= 0:
                for _i69 in range(_size65):
                  _elem70 = Coordinate()
                  _elem70.read(iprot)
                  _elem64.append(_elem70)
              else: 
                while iprot.peekList():
                  _elem71 = Coordinate()
                  _elem71.read(iprot)
                  _elem64.append(_elem71)
              iprot.readListEnd()
              self.coordListList.append(_elem64)
          else: 
            while iprot.peekList():
              _elem72 = []
              (_etype76, _size73) = iprot.readListBegin()
              if _size73 >= 0:
                for _i77 in range(_size73):
                  _elem78 = Coordinate()
                  _elem78.read(iprot)
                  _elem72.append(_elem78)
              else: 
                while iprot.peekList():
                  _elem79 = Coordinate()
                  _elem79.read(iprot)
                  _elem72.append(_elem79)
              iprot.readListEnd()
              self.coordListList.append(_elem72)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Polygon')
    if self.coordListList != None:
      oprot.writeFieldBegin('coordListList', TType.LIST, 1)
      oprot.writeListBegin(TType.LIST, len(self.coordListList))
      for iter80 in self.coordListList:
        oprot.writeListBegin(TType.STRUCT, len(iter80))
        for iter81 in iter80:
          iter81.write(oprot)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.coordListList is not None:
      value = pprint.pformat(self.coordListList, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    coordListList=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Geography(object):
  """
  Attributes:
   - ptVal
   - lsVal
   - pgVal
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  PTVAL = 1
  LSVAL = 2
  PGVAL = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_ptVal(self):
    assert self.field == 1
    return self.value

  def get_lsVal(self):
    assert self.field == 2
    return self.value

  def get_pgVal(self):
    assert self.field == 3
    return self.value

  def set_ptVal(self, value):
    self.field = 1
    self.value = value

  def set_lsVal(self, value):
    self.field = 2
    self.value = value

  def set_pgVal(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('ptVal', value)
    if self.field == 2:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('lsVal', value)
    if self.field == 3:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('pgVal', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRUCT:
          ptVal = Point()
          ptVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_ptVal(ptVal)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          lsVal = LineString()
          lsVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_lsVal(lsVal)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          pgVal = Polygon()
          pgVal.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_pgVal(pgVal)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Geography')
    if self.field == 1:
      oprot.writeFieldBegin('ptVal', TType.STRUCT, 1)
      ptVal = self.value
      ptVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('lsVal', TType.STRUCT, 2)
      lsVal = self.value
      lsVal.write(oprot)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('pgVal', TType.STRUCT, 3)
      pgVal = self.value
      pgVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Tag:
  """
  Attributes:
   - name
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype83, _vtype84, _size82 ) = iprot.readMapBegin() 
          if _size82 >= 0:
            for _i86 in range(_size82):
              _key87 = iprot.readString()
              _val88 = Value()
              _val88.read(iprot)
              self.props[_key87] = _val88
          else: 
            while iprot.peekMap():
              _key89 = iprot.readString()
              _val90 = Value()
              _val90.read(iprot)
              self.props[_key89] = _val90
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Tag')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter91,viter92 in self.props.items():
        oprot.writeString(kiter91)
        viter92.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Vertex:
  """
  Attributes:
   - vid
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.vid = Value()
          self.vid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype96, _size93) = iprot.readListBegin()
          if _size93 >= 0:
            for _i97 in range(_size93):
              _elem98 = Tag()
              _elem98.read(iprot)
              self.tags.append(_elem98)
          else: 
            while iprot.peekList():
              _elem99 = Tag()
              _elem99.read(iprot)
              self.tags.append(_elem99)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Vertex')
    if self.vid != None:
      oprot.writeFieldBegin('vid', TType.STRUCT, 1)
      self.vid.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter100 in self.tags:
        iter100.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.vid is not None:
      value = pprint.pformat(self.vid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vid=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Edge:
  """
  Attributes:
   - src
   - dst
   - type
   - name
   - ranking
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Value()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dst = Value()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype102, _vtype103, _size101 ) = iprot.readMapBegin() 
          if _size101 >= 0:
            for _i105 in range(_size101):
              _key106 = iprot.readString()
              _val107 = Value()
              _val107.read(iprot)
              self.props[_key106] = _val107
          else: 
            while iprot.peekMap():
              _key108 = iprot.readString()
              _val109 = Value()
              _val109.read(iprot)
              self.props[_key108] = _val109
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Edge')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 2)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 3)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 4)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 5)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter110,viter111 in self.props.items():
        oprot.writeString(kiter110)
        viter111.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Step:
  """
  Attributes:
   - dst
   - type
   - name
   - ranking
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dst = Vertex()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.props = {}
          (_ktype113, _vtype114, _size112 ) = iprot.readMapBegin() 
          if _size112 >= 0:
            for _i116 in range(_size112):
              _key117 = iprot.readString()
              _val118 = Value()
              _val118.read(iprot)
              self.props[_key117] = _val118
          else: 
            while iprot.peekMap():
              _key119 = iprot.readString()
              _val120 = Value()
              _val120.read(iprot)
              self.props[_key119] = _val120
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Step')
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 1)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 4)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.props))
      for kiter121,viter122 in self.props.items():
        oprot.writeString(kiter121)
        viter122.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Path:
  """
  Attributes:
   - src
   - steps
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = Vertex()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.steps = []
          (_etype126, _size123) = iprot.readListBegin()
          if _size123 >= 0:
            for _i127 in range(_size123):
              _elem128 = Step()
              _elem128.read(iprot)
              self.steps.append(_elem128)
          else: 
            while iprot.peekList():
              _elem129 = Step()
              _elem129.read(iprot)
              self.steps.append(_elem129)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Path')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.steps != None:
      oprot.writeFieldBegin('steps', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.steps))
      for iter130 in self.steps:
        iter130.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.steps is not None:
      value = pprint.pformat(self.steps, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    steps=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class HostAddr:
  """
  Attributes:
   - host
   - port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostAddr')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host.encode('utf-8')) if UTF8STRINGS and not isinstance(self.host, bytes) else oprot.writeString(self.host)
      oprot.writeFieldEnd()
    if self.port != None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.port is not None:
      value = pprint.pformat(self.port, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    port=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KeyValue:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KeyValue')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Duration:
  """
  Attributes:
   - seconds
   - microseconds
   - months
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.seconds = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.microseconds = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.months = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Duration')
    if self.seconds != None:
      oprot.writeFieldBegin('seconds', TType.I64, 1)
      oprot.writeI64(self.seconds)
      oprot.writeFieldEnd()
    if self.microseconds != None:
      oprot.writeFieldBegin('microseconds', TType.I32, 2)
      oprot.writeI32(self.microseconds)
      oprot.writeFieldEnd()
    if self.months != None:
      oprot.writeFieldBegin('months', TType.I32, 3)
      oprot.writeI32(self.months)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.seconds is not None:
      value = pprint.pformat(self.seconds, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    seconds=%s' % (value))
    if self.microseconds is not None:
      value = pprint.pformat(self.microseconds, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    microseconds=%s' % (value))
    if self.months is not None:
      value = pprint.pformat(self.months, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    months=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LogInfo:
  """
  Attributes:
   - log_id
   - term_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.log_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.term_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LogInfo')
    if self.log_id != None:
      oprot.writeFieldBegin('log_id', TType.I64, 1)
      oprot.writeI64(self.log_id)
      oprot.writeFieldEnd()
    if self.term_id != None:
      oprot.writeFieldBegin('term_id', TType.I64, 2)
      oprot.writeI64(self.term_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.log_id is not None:
      value = pprint.pformat(self.log_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_id=%s' % (value))
    if self.term_id is not None:
      value = pprint.pformat(self.term_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DirInfo:
  """
  Attributes:
   - root
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.root = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.data = []
          (_etype134, _size131) = iprot.readListBegin()
          if _size131 >= 0:
            for _i135 in range(_size131):
              _elem136 = iprot.readString()
              self.data.append(_elem136)
          else: 
            while iprot.peekList():
              _elem137 = iprot.readString()
              self.data.append(_elem137)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DirInfo')
    if self.root != None:
      oprot.writeFieldBegin('root', TType.STRING, 1)
      oprot.writeString(self.root)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.data))
      for iter138 in self.data:
        oprot.writeString(iter138)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.root is not None:
      value = pprint.pformat(self.root, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    root=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CheckpointInfo:
  """
  Attributes:
   - space_id
   - parts
   - path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype140, _vtype141, _size139 ) = iprot.readMapBegin() 
          if _size139 >= 0:
            for _i143 in range(_size139):
              _key144 = iprot.readI32()
              _val145 = LogInfo()
              _val145.read(iprot)
              self.parts[_key144] = _val145
          else: 
            while iprot.peekMap():
              _key146 = iprot.readI32()
              _val147 = LogInfo()
              _val147.read(iprot)
              self.parts[_key146] = _val147
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.path = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckpointInfo')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.parts))
      for kiter148,viter149 in self.parts.items():
        oprot.writeI32(kiter148)
        viter149.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 3)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LogEntry:
  """
  Attributes:
   - cluster
   - log_str
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.cluster = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.log_str = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LogEntry')
    if self.cluster != None:
      oprot.writeFieldBegin('cluster', TType.I64, 1)
      oprot.writeI64(self.cluster)
      oprot.writeFieldEnd()
    if self.log_str != None:
      oprot.writeFieldBegin('log_str', TType.STRING, 2)
      oprot.writeString(self.log_str)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.cluster is not None:
      value = pprint.pformat(self.cluster, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cluster=%s' % (value))
    if self.log_str is not None:
      value = pprint.pformat(self.log_str, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    log_str=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

ClusterID = UnimplementedTypedef()
GraphSpaceID = UnimplementedTypedef()
PartitionID = UnimplementedTypedef()
TagID = UnimplementedTypedef()
EdgeType = UnimplementedTypedef()
EdgeRanking = UnimplementedTypedef()
LogID = UnimplementedTypedef()
TermID = UnimplementedTypedef()
Timestamp = UnimplementedTypedef()
IndexID = UnimplementedTypedef()
Port = UnimplementedTypedef()
SessionID = UnimplementedTypedef()
ExecutionPlanID = UnimplementedTypedef()
all_structs.append(SchemaID)
SchemaID.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
)

SchemaID.thrift_struct_annotations = {
}
SchemaID.thrift_field_annotations = {
}

def SchemaID__init__(self, tag_id=None, edge_type=None,):
  self.field = 0
  self.value = None
  if tag_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = tag_id
  if edge_type is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = edge_type

SchemaID.__init__ = SchemaID__init__

all_structs.append(Date)
Date.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
)

Date.thrift_struct_annotations = {
  "cpp.type": "nebula::Date",
}
Date.thrift_field_annotations = {
}

def Date__init__(self, year=None, month=None, day=None,):
  self.year = year
  self.month = month
  self.day = day

Date.__init__ = Date__init__

def Date__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  self.__dict__ = state

Date.__getstate__ = lambda self: self.__dict__.copy()
Date.__setstate__ = Date__setstate__

all_structs.append(Time)
Time.thrift_spec = (
  None, # 0
  (1, TType.BYTE, 'hour', None, None, 2, ), # 1
  (2, TType.BYTE, 'minute', None, None, 2, ), # 2
  (3, TType.BYTE, 'sec', None, None, 2, ), # 3
  (4, TType.I32, 'microsec', None, None, 2, ), # 4
)

Time.thrift_struct_annotations = {
  "cpp.type": "nebula::Time",
}
Time.thrift_field_annotations = {
}

def Time__init__(self, hour=None, minute=None, sec=None, microsec=None,):
  self.hour = hour
  self.minute = minute
  self.sec = sec
  self.microsec = microsec

Time.__init__ = Time__init__

def Time__setstate__(self, state):
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('sec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

Time.__getstate__ = lambda self: self.__dict__.copy()
Time.__setstate__ = Time__setstate__

all_structs.append(DateTime)
DateTime.thrift_spec = (
  None, # 0
  (1, TType.I16, 'year', None, None, 2, ), # 1
  (2, TType.BYTE, 'month', None, None, 2, ), # 2
  (3, TType.BYTE, 'day', None, None, 2, ), # 3
  (4, TType.BYTE, 'hour', None, None, 2, ), # 4
  (5, TType.BYTE, 'minute', None, None, 2, ), # 5
  (6, TType.BYTE, 'sec', None, None, 2, ), # 6
  (7, TType.I32, 'microsec', None, None, 2, ), # 7
)

DateTime.thrift_struct_annotations = {
  "cpp.type": "nebula::DateTime",
}
DateTime.thrift_field_annotations = {
}

def DateTime__init__(self, year=None, month=None, day=None, hour=None, minute=None, sec=None, microsec=None,):
  self.year = year
  self.month = month
  self.day = day
  self.hour = hour
  self.minute = minute
  self.sec = sec
  self.microsec = microsec

DateTime.__init__ = DateTime__init__

def DateTime__setstate__(self, state):
  state.setdefault('year', None)
  state.setdefault('month', None)
  state.setdefault('day', None)
  state.setdefault('hour', None)
  state.setdefault('minute', None)
  state.setdefault('sec', None)
  state.setdefault('microsec', None)
  self.__dict__ = state

DateTime.__getstate__ = lambda self: self.__dict__.copy()
DateTime.__setstate__ = DateTime__setstate__

all_structs.append(Value)
Value.thrift_spec = (
  None, # 0
  (1, TType.I32, 'nVal', NullType, None, 2, ), # 1
  (2, TType.BOOL, 'bVal', None, None, 2, ), # 2
  (3, TType.I64, 'iVal', None, None, 2, ), # 3
  (4, TType.DOUBLE, 'fVal', None, None, 2, ), # 4
  (5, TType.STRING, 'sVal', False, None, 2, ), # 5
  (6, TType.STRUCT, 'dVal', [Date, Date.thrift_spec, False], None, 2, ), # 6
  (7, TType.STRUCT, 'tVal', [Time, Time.thrift_spec, False], None, 2, ), # 7
  (8, TType.STRUCT, 'dtVal', [DateTime, DateTime.thrift_spec, False], None, 2, ), # 8
  (9, TType.STRUCT, 'vVal', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 9
  (10, TType.STRUCT, 'eVal', [Edge, Edge.thrift_spec, False], None, 2, ), # 10
  (11, TType.STRUCT, 'pVal', [Path, Path.thrift_spec, False], None, 2, ), # 11
  (12, TType.STRUCT, 'lVal', [NList, NList.thrift_spec, False], None, 2, ), # 12
  (13, TType.STRUCT, 'mVal', [NMap, NMap.thrift_spec, False], None, 2, ), # 13
  (14, TType.STRUCT, 'uVal', [NSet, NSet.thrift_spec, False], None, 2, ), # 14
  (15, TType.STRUCT, 'gVal', [DataSet, DataSet.thrift_spec, False], None, 2, ), # 15
  (16, TType.STRUCT, 'ggVal', [Geography, Geography.thrift_spec, True], None, 2, ), # 16
  (17, TType.STRUCT, 'duVal', [Duration, Duration.thrift_spec, False], None, 2, ), # 17
)

Value.thrift_struct_annotations = {
  "cpp.type": "nebula::Value",
}
Value.thrift_field_annotations = {
  9: {
    "cpp.ref_type": "unique",
  },
  10: {
    "cpp.ref_type": "unique",
  },
  11: {
    "cpp.ref_type": "unique",
  },
  12: {
    "cpp.ref_type": "unique",
  },
  13: {
    "cpp.ref_type": "unique",
  },
  14: {
    "cpp.ref_type": "unique",
  },
  15: {
    "cpp.ref_type": "unique",
  },
  16: {
    "cpp.ref_type": "unique",
  },
  17: {
    "cpp.ref_type": "unique",
  },
}

def Value__init__(self, nVal=None, bVal=None, iVal=None, fVal=None, sVal=None, dVal=None, tVal=None, dtVal=None, vVal=None, eVal=None, pVal=None, lVal=None, mVal=None, uVal=None, gVal=None, ggVal=None, duVal=None,):
  self.field = 0
  self.value = None
  if nVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = nVal
  if bVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = bVal
  if iVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = iVal
  if fVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = fVal
  if sVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = sVal
  if dVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = dVal
  if tVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = tVal
  if dtVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = dtVal
  if vVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = vVal
  if eVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = eVal
  if pVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = pVal
  if lVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 12
    self.value = lVal
  if mVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 13
    self.value = mVal
  if uVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 14
    self.value = uVal
  if gVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 15
    self.value = gVal
  if ggVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 16
    self.value = ggVal
  if duVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 17
    self.value = duVal

Value.__init__ = Value__init__

all_structs.append(NList)
NList.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NList.thrift_struct_annotations = {
  "cpp.type": "nebula::List",
}
NList.thrift_field_annotations = {
}

def NList__init__(self, values=None,):
  self.values = values

NList.__init__ = NList__init__

def NList__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

NList.__getstate__ = lambda self: self.__dict__.copy()
NList.__setstate__ = NList__setstate__

all_structs.append(NMap)
NMap.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'kvs', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NMap.thrift_struct_annotations = {
  "cpp.type": "nebula::Map",
}
NMap.thrift_field_annotations = {
}

def NMap__init__(self, kvs=None,):
  self.kvs = kvs

NMap.__init__ = NMap__init__

def NMap__setstate__(self, state):
  state.setdefault('kvs', None)
  self.__dict__ = state

NMap.__getstate__ = lambda self: self.__dict__.copy()
NMap.__setstate__ = NMap__setstate__

all_structs.append(NSet)
NSet.thrift_spec = (
  None, # 0
  (1, TType.SET, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

NSet.thrift_struct_annotations = {
  "cpp.type": "nebula::Set",
}
NSet.thrift_field_annotations = {
}

def NSet__init__(self, values=None,):
  self.values = values

NSet.__init__ = NSet__init__

def NSet__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

NSet.__getstate__ = lambda self: self.__dict__.copy()
NSet.__setstate__ = NSet__setstate__

all_structs.append(Row)
Row.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'values', (TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 1
)

Row.thrift_struct_annotations = {
  "cpp.type": "nebula::Row",
}
Row.thrift_field_annotations = {
}

def Row__init__(self, values=None,):
  self.values = values

Row.__init__ = Row__init__

def Row__setstate__(self, state):
  state.setdefault('values', None)
  self.__dict__ = state

Row.__getstate__ = lambda self: self.__dict__.copy()
Row.__setstate__ = Row__setstate__

all_structs.append(DataSet)
DataSet.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 1
  (2, TType.LIST, 'rows', (TType.STRUCT,[Row, Row.thrift_spec, False]), None, 2, ), # 2
)

DataSet.thrift_struct_annotations = {
  "cpp.type": "nebula::DataSet",
}
DataSet.thrift_field_annotations = {
}

def DataSet__init__(self, column_names=None, rows=None,):
  self.column_names = column_names
  self.rows = rows

DataSet.__init__ = DataSet__init__

def DataSet__setstate__(self, state):
  state.setdefault('column_names', None)
  state.setdefault('rows', None)
  self.__dict__ = state

DataSet.__getstate__ = lambda self: self.__dict__.copy()
DataSet.__setstate__ = DataSet__setstate__

all_structs.append(Coordinate)
Coordinate.thrift_spec = (
  None, # 0
  (1, TType.DOUBLE, 'x', None, None, 2, ), # 1
  (2, TType.DOUBLE, 'y', None, None, 2, ), # 2
)

Coordinate.thrift_struct_annotations = {
  "cpp.type": "nebula::Coordinate",
}
Coordinate.thrift_field_annotations = {
}

def Coordinate__init__(self, x=None, y=None,):
  self.x = x
  self.y = y

Coordinate.__init__ = Coordinate__init__

def Coordinate__setstate__(self, state):
  state.setdefault('x', None)
  state.setdefault('y', None)
  self.__dict__ = state

Coordinate.__getstate__ = lambda self: self.__dict__.copy()
Coordinate.__setstate__ = Coordinate__setstate__

all_structs.append(Point)
Point.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'coord', [Coordinate, Coordinate.thrift_spec, False], None, 2, ), # 1
)

Point.thrift_struct_annotations = {
  "cpp.type": "nebula::Point",
}
Point.thrift_field_annotations = {
}

def Point__init__(self, coord=None,):
  self.coord = coord

Point.__init__ = Point__init__

def Point__setstate__(self, state):
  state.setdefault('coord', None)
  self.__dict__ = state

Point.__getstate__ = lambda self: self.__dict__.copy()
Point.__setstate__ = Point__setstate__

all_structs.append(LineString)
LineString.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'coordList', (TType.STRUCT,[Coordinate, Coordinate.thrift_spec, False]), None, 2, ), # 1
)

LineString.thrift_struct_annotations = {
  "cpp.type": "nebula::LineString",
}
LineString.thrift_field_annotations = {
}

def LineString__init__(self, coordList=None,):
  self.coordList = coordList

LineString.__init__ = LineString__init__

def LineString__setstate__(self, state):
  state.setdefault('coordList', None)
  self.__dict__ = state

LineString.__getstate__ = lambda self: self.__dict__.copy()
LineString.__setstate__ = LineString__setstate__

all_structs.append(Polygon)
Polygon.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'coordListList', (TType.LIST,(TType.STRUCT,[Coordinate, Coordinate.thrift_spec, False])), None, 2, ), # 1
)

Polygon.thrift_struct_annotations = {
  "cpp.type": "nebula::Polygon",
}
Polygon.thrift_field_annotations = {
}

def Polygon__init__(self, coordListList=None,):
  self.coordListList = coordListList

Polygon.__init__ = Polygon__init__

def Polygon__setstate__(self, state):
  state.setdefault('coordListList', None)
  self.__dict__ = state

Polygon.__getstate__ = lambda self: self.__dict__.copy()
Polygon.__setstate__ = Polygon__setstate__

all_structs.append(Geography)
Geography.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'ptVal', [Point, Point.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'lsVal', [LineString, LineString.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'pgVal', [Polygon, Polygon.thrift_spec, False], None, 2, ), # 3
)

Geography.thrift_struct_annotations = {
  "cpp.type": "nebula::Geography",
}
Geography.thrift_field_annotations = {
  1: {
    "cpp.ref_type": "unique",
  },
  2: {
    "cpp.ref_type": "unique",
  },
  3: {
    "cpp.ref_type": "unique",
  },
}

def Geography__init__(self, ptVal=None, lsVal=None, pgVal=None,):
  self.field = 0
  self.value = None
  if ptVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = ptVal
  if lsVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = lsVal
  if pgVal is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = pgVal

Geography.__init__ = Geography__init__

all_structs.append(Tag)
Tag.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 2
)

Tag.thrift_struct_annotations = {
  "cpp.type": "nebula::Tag",
}
Tag.thrift_field_annotations = {
}

def Tag__init__(self, name=None, props=None,):
  self.name = name
  self.props = props

Tag.__init__ = Tag__init__

def Tag__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('props', None)
  self.__dict__ = state

Tag.__getstate__ = lambda self: self.__dict__.copy()
Tag.__setstate__ = Tag__setstate__

all_structs.append(Vertex)
Vertex.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'vid', [Value, Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[Tag, Tag.thrift_spec, False]), None, 2, ), # 2
)

Vertex.thrift_struct_annotations = {
  "cpp.type": "nebula::Vertex",
}
Vertex.thrift_field_annotations = {
}

def Vertex__init__(self, vid=None, tags=None,):
  self.vid = vid
  self.tags = tags

Vertex.__init__ = Vertex__init__

def Vertex__setstate__(self, state):
  state.setdefault('vid', None)
  state.setdefault('tags', None)
  self.__dict__ = state

Vertex.__getstate__ = lambda self: self.__dict__.copy()
Vertex.__setstate__ = Vertex__setstate__

all_structs.append(Edge)
Edge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [Value, Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.STRUCT, 'dst', [Value, Value.thrift_spec, True], None, 2, ), # 2
  (3, TType.I32, 'type', None, None, 2, ), # 3
  (4, TType.STRING, 'name', False, None, 2, ), # 4
  (5, TType.I64, 'ranking', None, None, 2, ), # 5
  (6, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 6
)

Edge.thrift_struct_annotations = {
  "cpp.type": "nebula::Edge",
}
Edge.thrift_field_annotations = {
}

def Edge__init__(self, src=None, dst=None, type=None, name=None, ranking=None, props=None,):
  self.src = src
  self.dst = dst
  self.type = type
  self.name = name
  self.ranking = ranking
  self.props = props

Edge.__init__ = Edge__init__

def Edge__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('dst', None)
  state.setdefault('type', None)
  state.setdefault('name', None)
  state.setdefault('ranking', None)
  state.setdefault('props', None)
  self.__dict__ = state

Edge.__getstate__ = lambda self: self.__dict__.copy()
Edge.__setstate__ = Edge__setstate__

all_structs.append(Step)
Step.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dst', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'type', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
  (4, TType.I64, 'ranking', None, None, 2, ), # 4
  (5, TType.MAP, 'props', (TType.STRING,False,TType.STRUCT,[Value, Value.thrift_spec, True]), None, 2, ), # 5
)

Step.thrift_struct_annotations = {
  "cpp.type": "nebula::Step",
}
Step.thrift_field_annotations = {
}

def Step__init__(self, dst=None, type=None, name=None, ranking=None, props=None,):
  self.dst = dst
  self.type = type
  self.name = name
  self.ranking = ranking
  self.props = props

Step.__init__ = Step__init__

def Step__setstate__(self, state):
  state.setdefault('dst', None)
  state.setdefault('type', None)
  state.setdefault('name', None)
  state.setdefault('ranking', None)
  state.setdefault('props', None)
  self.__dict__ = state

Step.__getstate__ = lambda self: self.__dict__.copy()
Step.__setstate__ = Step__setstate__

all_structs.append(Path)
Path.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [Vertex, Vertex.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'steps', (TType.STRUCT,[Step, Step.thrift_spec, False]), None, 2, ), # 2
)

Path.thrift_struct_annotations = {
  "cpp.type": "nebula::Path",
}
Path.thrift_field_annotations = {
}

def Path__init__(self, src=None, steps=None,):
  self.src = src
  self.steps = steps

Path.__init__ = Path__init__

def Path__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('steps', None)
  self.__dict__ = state

Path.__getstate__ = lambda self: self.__dict__.copy()
Path.__setstate__ = Path__setstate__

all_structs.append(HostAddr)
HostAddr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'host', True, None, 2, ), # 1
  (2, TType.I32, 'port', None, None, 2, ), # 2
)

HostAddr.thrift_struct_annotations = {
  "cpp.type": "nebula::HostAddr",
}
HostAddr.thrift_field_annotations = {
}

def HostAddr__init__(self, host=None, port=None,):
  self.host = host
  self.port = port

HostAddr.__init__ = HostAddr__init__

def HostAddr__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('port', None)
  self.__dict__ = state

HostAddr.__getstate__ = lambda self: self.__dict__.copy()
HostAddr.__setstate__ = HostAddr__setstate__

all_structs.append(KeyValue)
KeyValue.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'key', False, None, 2, ), # 1
  (2, TType.STRING, 'value', False, None, 2, ), # 2
)

KeyValue.thrift_struct_annotations = {
  "cpp.type": "nebula::KeyValue",
}
KeyValue.thrift_field_annotations = {
}

def KeyValue__init__(self, key=None, value=None,):
  self.key = key
  self.value = value

KeyValue.__init__ = KeyValue__init__

def KeyValue__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('value', None)
  self.__dict__ = state

KeyValue.__getstate__ = lambda self: self.__dict__.copy()
KeyValue.__setstate__ = KeyValue__setstate__

all_structs.append(Duration)
Duration.thrift_spec = (
  None, # 0
  (1, TType.I64, 'seconds', None, None, 2, ), # 1
  (2, TType.I32, 'microseconds', None, None, 2, ), # 2
  (3, TType.I32, 'months', None, None, 2, ), # 3
)

Duration.thrift_struct_annotations = {
  "cpp.type": "nebula::Duration",
}
Duration.thrift_field_annotations = {
}

def Duration__init__(self, seconds=None, microseconds=None, months=None,):
  self.seconds = seconds
  self.microseconds = microseconds
  self.months = months

Duration.__init__ = Duration__init__

def Duration__setstate__(self, state):
  state.setdefault('seconds', None)
  state.setdefault('microseconds', None)
  state.setdefault('months', None)
  self.__dict__ = state

Duration.__getstate__ = lambda self: self.__dict__.copy()
Duration.__setstate__ = Duration__setstate__

all_structs.append(LogInfo)
LogInfo.thrift_spec = (
  None, # 0
  (1, TType.I64, 'log_id', None, None, 2, ), # 1
  (2, TType.I64, 'term_id', None, None, 2, ), # 2
)

LogInfo.thrift_struct_annotations = {
}
LogInfo.thrift_field_annotations = {
}

def LogInfo__init__(self, log_id=None, term_id=None,):
  self.log_id = log_id
  self.term_id = term_id

LogInfo.__init__ = LogInfo__init__

def LogInfo__setstate__(self, state):
  state.setdefault('log_id', None)
  state.setdefault('term_id', None)
  self.__dict__ = state

LogInfo.__getstate__ = lambda self: self.__dict__.copy()
LogInfo.__setstate__ = LogInfo__setstate__

all_structs.append(DirInfo)
DirInfo.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'root', False, None, 2, ), # 1
  (2, TType.LIST, 'data', (TType.STRING,False), None, 2, ), # 2
)

DirInfo.thrift_struct_annotations = {
}
DirInfo.thrift_field_annotations = {
}

def DirInfo__init__(self, root=None, data=None,):
  self.root = root
  self.data = data

DirInfo.__init__ = DirInfo__init__

def DirInfo__setstate__(self, state):
  state.setdefault('root', None)
  state.setdefault('data', None)
  self.__dict__ = state

DirInfo.__getstate__ = lambda self: self.__dict__.copy()
DirInfo.__setstate__ = DirInfo__setstate__

all_structs.append(CheckpointInfo)
CheckpointInfo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRUCT,[LogInfo, LogInfo.thrift_spec, False]), None, 2, ), # 2
  (3, TType.STRING, 'path', False, None, 2, ), # 3
)

CheckpointInfo.thrift_struct_annotations = {
}
CheckpointInfo.thrift_field_annotations = {
}

def CheckpointInfo__init__(self, space_id=None, parts=None, path=None,):
  self.space_id = space_id
  self.parts = parts
  self.path = path

CheckpointInfo.__init__ = CheckpointInfo__init__

def CheckpointInfo__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('path', None)
  self.__dict__ = state

CheckpointInfo.__getstate__ = lambda self: self.__dict__.copy()
CheckpointInfo.__setstate__ = CheckpointInfo__setstate__

all_structs.append(LogEntry)
LogEntry.thrift_spec = (
  None, # 0
  (1, TType.I64, 'cluster', None, None, 2, ), # 1
  (2, TType.STRING, 'log_str', False, None, 2, ), # 2
)

LogEntry.thrift_struct_annotations = {
}
LogEntry.thrift_field_annotations = {
}

def LogEntry__init__(self, cluster=None, log_str=None,):
  self.cluster = cluster
  self.log_str = log_str

LogEntry.__init__ = LogEntry__init__

def LogEntry__setstate__(self, state):
  state.setdefault('cluster', None)
  state.setdefault('log_str', None)
  self.__dict__ = state

LogEntry.__getstate__ = lambda self: self.__dict__.copy()
LogEntry.__setstate__ = LogEntry__setstate__

fix_spec(all_structs)
del all_structs
