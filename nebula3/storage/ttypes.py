#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from nebula3.fbthrift.util.Recursive import fix_spec
from nebula3.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula3.fbthrift.protocol.TProtocol import TProtocolException


import nebula3.common.ttypes
import nebula3.meta.ttypes


import pprint
import warnings
from nebula3.fbthrift import Thrift
from nebula3.fbthrift.transport import TTransport
from nebula3.fbthrift.protocol import TBinaryProtocol
from nebula3.fbthrift.protocol import TCompactProtocol
from nebula3.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula3.fbthrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'StatType', 'OrderDirection', 'EdgeDirection', 'ScanType', 'EngineSignType', 'RequestCommon', 'PartitionResult', 'ResponseCommon', 'StatProp', 'Expr', 'EdgeProp', 'VertexProp', 'OrderBy', 'TraverseSpec', 'GetNeighborsRequest', 'GetNeighborsResponse', 'GetDstBySrcRequest', 'GetDstBySrcResponse', 'ExecResponse', 'GetPropRequest', 'GetPropResponse', 'NewTag', 'NewVertex', 'EdgeKey', 'NewEdge', 'AddVerticesRequest', 'AddEdgesRequest', 'DeleteVerticesRequest', 'DeleteEdgesRequest', 'DelTags', 'DeleteTagsRequest', 'UpdateResponse', 'UpdatedProp', 'UpdateVertexRequest', 'UpdateEdgeRequest', 'GetUUIDReq', 'GetUUIDResp', 'LookupIndexResp', 'IndexColumnHint', 'IndexQueryContext', 'IndexSpec', 'LookupIndexRequest', 'LookupAndTraverseRequest', 'ScanCursor', 'ScanVertexRequest', 'ScanEdgeRequest', 'ScanResponse', 'TaskPara', 'KVGetRequest', 'KVGetResponse', 'KVPutRequest', 'KVRemoveRequest', 'AdminExecResp', 'TransLeaderReq', 'AddPartReq', 'AddLearnerReq', 'RemovePartReq', 'MemberChangeReq', 'CatchUpDataReq', 'GetLeaderReq', 'CreateCPRequest', 'CreateCPResp', 'DropCPRequest', 'DropCPResp', 'BlockingSignRequest', 'BlockingSignResp', 'GetLeaderPartsResp', 'CheckPeersReq', 'RebuildIndexRequest', 'ListClusterInfoResp', 'ListClusterInfoReq', 'AddTaskRequest', 'AddTaskResp', 'StopTaskRequest', 'StopTaskResp', 'ClearSpaceReq', 'ClearSpaceResp', 'ChainAddEdgesRequest', 'ChainUpdateEdgeRequest', 'ChainDeleteEdgesRequest']

class StatType:
  SUM = 1
  COUNT = 2
  AVG = 3
  MAX = 4
  MIN = 5

  _VALUES_TO_NAMES = {
    1: "SUM",
    2: "COUNT",
    3: "AVG",
    4: "MAX",
    5: "MIN",
  }

  _NAMES_TO_VALUES = {
    "SUM": 1,
    "COUNT": 2,
    "AVG": 3,
    "MAX": 4,
    "MIN": 5,
  }

class OrderDirection:
  ASCENDING = 1
  DESCENDING = 2

  _VALUES_TO_NAMES = {
    1: "ASCENDING",
    2: "DESCENDING",
  }

  _NAMES_TO_VALUES = {
    "ASCENDING": 1,
    "DESCENDING": 2,
  }

class EdgeDirection:
  BOTH = 1
  IN_EDGE = 2
  OUT_EDGE = 3

  _VALUES_TO_NAMES = {
    1: "BOTH",
    2: "IN_EDGE",
    3: "OUT_EDGE",
  }

  _NAMES_TO_VALUES = {
    "BOTH": 1,
    "IN_EDGE": 2,
    "OUT_EDGE": 3,
  }

class ScanType:
  PREFIX = 1
  RANGE = 2

  _VALUES_TO_NAMES = {
    1: "PREFIX",
    2: "RANGE",
  }

  _NAMES_TO_VALUES = {
    "PREFIX": 1,
    "RANGE": 2,
  }

class EngineSignType:
  BLOCK_ON = 1
  BLOCK_OFF = 2

  _VALUES_TO_NAMES = {
    1: "BLOCK_ON",
    2: "BLOCK_OFF",
  }

  _NAMES_TO_VALUES = {
    "BLOCK_ON": 1,
    "BLOCK_OFF": 2,
  }

class RequestCommon:
  """
  Attributes:
   - session_id
   - plan_id
   - profile_detail
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.plan_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.profile_detail = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RequestCommon')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    if self.plan_id != None:
      oprot.writeFieldBegin('plan_id', TType.I64, 2)
      oprot.writeI64(self.plan_id)
      oprot.writeFieldEnd()
    if self.profile_detail != None:
      oprot.writeFieldBegin('profile_detail', TType.BOOL, 3)
      oprot.writeBool(self.profile_detail)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    if self.plan_id is not None:
      value = pprint.pformat(self.plan_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    plan_id=%s' % (value))
    if self.profile_detail is not None:
      value = pprint.pformat(self.profile_detail, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    profile_detail=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PartitionResult:
  """
  Attributes:
   - code
   - part_id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionResult')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ResponseCommon:
  """
  Attributes:
   - failed_parts
   - latency_in_us
   - latency_detail_us
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.failed_parts = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = PartitionResult()
              _elem5.read(iprot)
              self.failed_parts.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = PartitionResult()
              _elem6.read(iprot)
              self.failed_parts.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.latency_in_us = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.latency_detail_us = {}
          (_ktype8, _vtype9, _size7 ) = iprot.readMapBegin() 
          if _size7 >= 0:
            for _i11 in range(_size7):
              _key12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val13 = iprot.readI32()
              self.latency_detail_us[_key12] = _val13
          else: 
            while iprot.peekMap():
              _key14 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val15 = iprot.readI32()
              self.latency_detail_us[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ResponseCommon')
    if self.failed_parts != None:
      oprot.writeFieldBegin('failed_parts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.failed_parts))
      for iter16 in self.failed_parts:
        iter16.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I64, 2)
      oprot.writeI64(self.latency_in_us)
      oprot.writeFieldEnd()
    if self.latency_detail_us != None:
      oprot.writeFieldBegin('latency_detail_us', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.latency_detail_us))
      for kiter17,viter18 in self.latency_detail_us.items():
        oprot.writeString(kiter17.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter17, bytes) else oprot.writeString(kiter17)
        oprot.writeI32(viter18)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.failed_parts is not None:
      value = pprint.pformat(self.failed_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    failed_parts=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    if self.latency_detail_us is not None:
      value = pprint.pformat(self.latency_detail_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_detail_us=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StatProp:
  """
  Attributes:
   - alias
   - prop
   - stat
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.stat = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StatProp')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 2)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.stat != None:
      oprot.writeFieldBegin('stat', TType.I32, 3)
      oprot.writeI32(self.stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.stat is not None:
      value = pprint.pformat(self.stat, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Expr:
  """
  Attributes:
   - alias
   - expr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.alias = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.expr = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Expr')
    if self.alias != None:
      oprot.writeFieldBegin('alias', TType.STRING, 1)
      oprot.writeString(self.alias)
      oprot.writeFieldEnd()
    if self.expr != None:
      oprot.writeFieldBegin('expr', TType.STRING, 2)
      oprot.writeString(self.expr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.alias is not None:
      value = pprint.pformat(self.alias, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    alias=%s' % (value))
    if self.expr is not None:
      value = pprint.pformat(self.expr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class EdgeProp:
  """
  Attributes:
   - type
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype22, _size19) = iprot.readListBegin()
          if _size19 >= 0:
            for _i23 in range(_size19):
              _elem24 = iprot.readString()
              self.props.append(_elem24)
          else: 
            while iprot.peekList():
              _elem25 = iprot.readString()
              self.props.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeProp')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter26 in self.props:
        oprot.writeString(iter26)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class VertexProp:
  """
  Attributes:
   - tag
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype30, _size27) = iprot.readListBegin()
          if _size27 >= 0:
            for _i31 in range(_size27):
              _elem32 = iprot.readString()
              self.props.append(_elem32)
          else: 
            while iprot.peekList():
              _elem33 = iprot.readString()
              self.props.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VertexProp')
    if self.tag != None:
      oprot.writeFieldBegin('tag', TType.I32, 1)
      oprot.writeI32(self.tag)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.props))
      for iter34 in self.props:
        oprot.writeString(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag is not None:
      value = pprint.pformat(self.tag, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class OrderBy:
  """
  Attributes:
   - prop
   - direction
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.prop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('OrderBy')
    if self.prop != None:
      oprot.writeFieldBegin('prop', TType.STRING, 1)
      oprot.writeString(self.prop)
      oprot.writeFieldEnd()
    if self.direction != None:
      oprot.writeFieldBegin('direction', TType.I32, 2)
      oprot.writeI32(self.direction)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.prop is not None:
      value = pprint.pformat(self.prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop=%s' % (value))
    if self.direction is not None:
      value = pprint.pformat(self.direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    direction=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TraverseSpec:
  """
  Attributes:
   - edge_types
   - edge_direction
   - dedup
   - stat_props
   - vertex_props
   - edge_props
   - expressions
   - order_by
   - random
   - limit
   - filter
   - tag_filter
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.edge_types = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in range(_size35):
              _elem40 = iprot.readI32()
              self.edge_types.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = iprot.readI32()
              self.edge_types.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_direction = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.stat_props = []
          (_etype45, _size42) = iprot.readListBegin()
          if _size42 >= 0:
            for _i46 in range(_size42):
              _elem47 = StatProp()
              _elem47.read(iprot)
              self.stat_props.append(_elem47)
          else: 
            while iprot.peekList():
              _elem48 = StatProp()
              _elem48.read(iprot)
              self.stat_props.append(_elem48)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype52, _size49) = iprot.readListBegin()
          if _size49 >= 0:
            for _i53 in range(_size49):
              _elem54 = VertexProp()
              _elem54.read(iprot)
              self.vertex_props.append(_elem54)
          else: 
            while iprot.peekList():
              _elem55 = VertexProp()
              _elem55.read(iprot)
              self.vertex_props.append(_elem55)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype59, _size56) = iprot.readListBegin()
          if _size56 >= 0:
            for _i60 in range(_size56):
              _elem61 = EdgeProp()
              _elem61.read(iprot)
              self.edge_props.append(_elem61)
          else: 
            while iprot.peekList():
              _elem62 = EdgeProp()
              _elem62.read(iprot)
              self.edge_props.append(_elem62)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype66, _size63) = iprot.readListBegin()
          if _size63 >= 0:
            for _i67 in range(_size63):
              _elem68 = Expr()
              _elem68.read(iprot)
              self.expressions.append(_elem68)
          else: 
            while iprot.peekList():
              _elem69 = Expr()
              _elem69.read(iprot)
              self.expressions.append(_elem69)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype73, _size70) = iprot.readListBegin()
          if _size70 >= 0:
            for _i74 in range(_size70):
              _elem75 = OrderBy()
              _elem75.read(iprot)
              self.order_by.append(_elem75)
          else: 
            while iprot.peekList():
              _elem76 = OrderBy()
              _elem76.read(iprot)
              self.order_by.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.random = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.tag_filter = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TraverseSpec')
    if self.edge_types != None:
      oprot.writeFieldBegin('edge_types', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.edge_types))
      for iter77 in self.edge_types:
        oprot.writeI32(iter77)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_direction != None:
      oprot.writeFieldBegin('edge_direction', TType.I32, 2)
      oprot.writeI32(self.edge_direction)
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 3)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.stat_props != None:
      oprot.writeFieldBegin('stat_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.stat_props))
      for iter78 in self.stat_props:
        iter78.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter79 in self.vertex_props:
        iter79.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter80 in self.edge_props:
        iter80.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter81 in self.expressions:
        iter81.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter82 in self.order_by:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.random != None:
      oprot.writeFieldBegin('random', TType.BOOL, 9)
      oprot.writeBool(self.random)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 10)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 11)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.tag_filter != None:
      oprot.writeFieldBegin('tag_filter', TType.STRING, 12)
      oprot.writeString(self.tag_filter)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.edge_types is not None:
      value = pprint.pformat(self.edge_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_types=%s' % (value))
    if self.edge_direction is not None:
      value = pprint.pformat(self.edge_direction, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_direction=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.stat_props is not None:
      value = pprint.pformat(self.stat_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat_props=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.random is not None:
      value = pprint.pformat(self.random, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    random=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.tag_filter is not None:
      value = pprint.pformat(self.tag_filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_filter=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetNeighborsRequest:
  """
  Attributes:
   - space_id
   - column_names
   - parts
   - traverse_spec
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.column_names = []
          (_etype86, _size83) = iprot.readListBegin()
          if _size83 >= 0:
            for _i87 in range(_size83):
              _elem88 = iprot.readString()
              self.column_names.append(_elem88)
          else: 
            while iprot.peekList():
              _elem89 = iprot.readString()
              self.column_names.append(_elem89)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype91, _vtype92, _size90 ) = iprot.readMapBegin() 
          if _size90 >= 0:
            for _i94 in range(_size90):
              _key95 = iprot.readI32()
              _val96 = []
              (_etype100, _size97) = iprot.readListBegin()
              if _size97 >= 0:
                for _i101 in range(_size97):
                  _elem102 = nebula3.common.ttypes.Value()
                  _elem102.read(iprot)
                  _val96.append(_elem102)
              else: 
                while iprot.peekList():
                  _elem103 = nebula3.common.ttypes.Value()
                  _elem103.read(iprot)
                  _val96.append(_elem103)
              iprot.readListEnd()
              self.parts[_key95] = _val96
          else: 
            while iprot.peekMap():
              _key104 = iprot.readI32()
              _val105 = []
              (_etype109, _size106) = iprot.readListBegin()
              if _size106 >= 0:
                for _i110 in range(_size106):
                  _elem111 = nebula3.common.ttypes.Value()
                  _elem111.read(iprot)
                  _val105.append(_elem111)
              else: 
                while iprot.peekList():
                  _elem112 = nebula3.common.ttypes.Value()
                  _elem112.read(iprot)
                  _val105.append(_elem112)
              iprot.readListEnd()
              self.parts[_key104] = _val105
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.column_names != None:
      oprot.writeFieldBegin('column_names', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.column_names))
      for iter113 in self.column_names:
        oprot.writeString(iter113)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter114,viter115 in self.parts.items():
        oprot.writeI32(kiter114)
        oprot.writeListBegin(TType.STRUCT, len(viter115))
        for iter116 in viter115:
          iter116.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 5)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.column_names is not None:
      value = pprint.pformat(self.column_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_names=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetNeighborsResponse:
  """
  Attributes:
   - result
   - vertices
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vertices = nebula3.common.ttypes.DataSet()
          self.vertices.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetNeighborsResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.vertices != None:
      oprot.writeFieldBegin('vertices', TType.STRUCT, 2)
      self.vertices.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.vertices is not None:
      value = pprint.pformat(self.vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertices=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetDstBySrcRequest:
  """
  Attributes:
   - space_id
   - parts
   - edge_types
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype118, _vtype119, _size117 ) = iprot.readMapBegin() 
          if _size117 >= 0:
            for _i121 in range(_size117):
              _key122 = iprot.readI32()
              _val123 = []
              (_etype127, _size124) = iprot.readListBegin()
              if _size124 >= 0:
                for _i128 in range(_size124):
                  _elem129 = nebula3.common.ttypes.Value()
                  _elem129.read(iprot)
                  _val123.append(_elem129)
              else: 
                while iprot.peekList():
                  _elem130 = nebula3.common.ttypes.Value()
                  _elem130.read(iprot)
                  _val123.append(_elem130)
              iprot.readListEnd()
              self.parts[_key122] = _val123
          else: 
            while iprot.peekMap():
              _key131 = iprot.readI32()
              _val132 = []
              (_etype136, _size133) = iprot.readListBegin()
              if _size133 >= 0:
                for _i137 in range(_size133):
                  _elem138 = nebula3.common.ttypes.Value()
                  _elem138.read(iprot)
                  _val132.append(_elem138)
              else: 
                while iprot.peekList():
                  _elem139 = nebula3.common.ttypes.Value()
                  _elem139.read(iprot)
                  _val132.append(_elem139)
              iprot.readListEnd()
              self.parts[_key131] = _val132
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edge_types = []
          (_etype143, _size140) = iprot.readListBegin()
          if _size140 >= 0:
            for _i144 in range(_size140):
              _elem145 = iprot.readI32()
              self.edge_types.append(_elem145)
          else: 
            while iprot.peekList():
              _elem146 = iprot.readI32()
              self.edge_types.append(_elem146)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetDstBySrcRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter147,viter148 in self.parts.items():
        oprot.writeI32(kiter147)
        oprot.writeListBegin(TType.STRUCT, len(viter148))
        for iter149 in viter148:
          iter149.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edge_types != None:
      oprot.writeFieldBegin('edge_types', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.edge_types))
      for iter150 in self.edge_types:
        oprot.writeI32(iter150)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 4)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.edge_types is not None:
      value = pprint.pformat(self.edge_types, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_types=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetDstBySrcResponse:
  """
  Attributes:
   - result
   - dsts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dsts = nebula3.common.ttypes.DataSet()
          self.dsts.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetDstBySrcResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.dsts != None:
      oprot.writeFieldBegin('dsts', TType.STRUCT, 2)
      self.dsts.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.dsts is not None:
      value = pprint.pformat(self.dsts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dsts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ExecResponse:
  """
  Attributes:
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetPropRequest:
  """
  Attributes:
   - space_id
   - parts
   - vertex_props
   - edge_props
   - expressions
   - dedup
   - order_by
   - limit
   - filter
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype152, _vtype153, _size151 ) = iprot.readMapBegin() 
          if _size151 >= 0:
            for _i155 in range(_size151):
              _key156 = iprot.readI32()
              _val157 = []
              (_etype161, _size158) = iprot.readListBegin()
              if _size158 >= 0:
                for _i162 in range(_size158):
                  _elem163 = nebula3.common.ttypes.Row()
                  _elem163.read(iprot)
                  _val157.append(_elem163)
              else: 
                while iprot.peekList():
                  _elem164 = nebula3.common.ttypes.Row()
                  _elem164.read(iprot)
                  _val157.append(_elem164)
              iprot.readListEnd()
              self.parts[_key156] = _val157
          else: 
            while iprot.peekMap():
              _key165 = iprot.readI32()
              _val166 = []
              (_etype170, _size167) = iprot.readListBegin()
              if _size167 >= 0:
                for _i171 in range(_size167):
                  _elem172 = nebula3.common.ttypes.Row()
                  _elem172.read(iprot)
                  _val166.append(_elem172)
              else: 
                while iprot.peekList():
                  _elem173 = nebula3.common.ttypes.Row()
                  _elem173.read(iprot)
                  _val166.append(_elem173)
              iprot.readListEnd()
              self.parts[_key165] = _val166
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.vertex_props = []
          (_etype177, _size174) = iprot.readListBegin()
          if _size174 >= 0:
            for _i178 in range(_size174):
              _elem179 = VertexProp()
              _elem179.read(iprot)
              self.vertex_props.append(_elem179)
          else: 
            while iprot.peekList():
              _elem180 = VertexProp()
              _elem180.read(iprot)
              self.vertex_props.append(_elem180)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.edge_props = []
          (_etype184, _size181) = iprot.readListBegin()
          if _size181 >= 0:
            for _i185 in range(_size181):
              _elem186 = EdgeProp()
              _elem186.read(iprot)
              self.edge_props.append(_elem186)
          else: 
            while iprot.peekList():
              _elem187 = EdgeProp()
              _elem187.read(iprot)
              self.edge_props.append(_elem187)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.expressions = []
          (_etype191, _size188) = iprot.readListBegin()
          if _size188 >= 0:
            for _i192 in range(_size188):
              _elem193 = Expr()
              _elem193.read(iprot)
              self.expressions.append(_elem193)
          else: 
            while iprot.peekList():
              _elem194 = Expr()
              _elem194.read(iprot)
              self.expressions.append(_elem194)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.dedup = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype198, _size195) = iprot.readListBegin()
          if _size195 >= 0:
            for _i199 in range(_size195):
              _elem200 = OrderBy()
              _elem200.read(iprot)
              self.order_by.append(_elem200)
          else: 
            while iprot.peekList():
              _elem201 = OrderBy()
              _elem201.read(iprot)
              self.order_by.append(_elem201)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter202,viter203 in self.parts.items():
        oprot.writeI32(kiter202)
        oprot.writeListBegin(TType.STRUCT, len(viter203))
        for iter204 in viter203:
          iter204.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.vertex_props != None:
      oprot.writeFieldBegin('vertex_props', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.vertex_props))
      for iter205 in self.vertex_props:
        iter205.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.edge_props != None:
      oprot.writeFieldBegin('edge_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_props))
      for iter206 in self.edge_props:
        iter206.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.expressions != None:
      oprot.writeFieldBegin('expressions', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.expressions))
      for iter207 in self.expressions:
        iter207.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dedup != None:
      oprot.writeFieldBegin('dedup', TType.BOOL, 6)
      oprot.writeBool(self.dedup)
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter208 in self.order_by:
        iter208.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 8)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 9)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 10)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.vertex_props is not None:
      value = pprint.pformat(self.vertex_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_props=%s' % (value))
    if self.edge_props is not None:
      value = pprint.pformat(self.edge_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_props=%s' % (value))
    if self.expressions is not None:
      value = pprint.pformat(self.expressions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    expressions=%s' % (value))
    if self.dedup is not None:
      value = pprint.pformat(self.dedup, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dedup=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetPropResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula3.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPropResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NewTag:
  """
  Attributes:
   - tag_id
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype212, _size209) = iprot.readListBegin()
          if _size209 >= 0:
            for _i213 in range(_size209):
              _elem214 = nebula3.common.ttypes.Value()
              _elem214.read(iprot)
              self.props.append(_elem214)
          else: 
            while iprot.peekList():
              _elem215 = nebula3.common.ttypes.Value()
              _elem215.read(iprot)
              self.props.append(_elem215)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewTag')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter216 in self.props:
        iter216.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NewVertex:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = nebula3.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype220, _size217) = iprot.readListBegin()
          if _size217 >= 0:
            for _i221 in range(_size217):
              _elem222 = NewTag()
              _elem222.read(iprot)
              self.tags.append(_elem222)
          else: 
            while iprot.peekList():
              _elem223 = NewTag()
              _elem223.read(iprot)
              self.tags.append(_elem223)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewVertex')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter224 in self.tags:
        iter224.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class EdgeKey:
  """
  Attributes:
   - src
   - edge_type
   - ranking
   - dst
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.src = nebula3.common.ttypes.Value()
          self.src.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.ranking = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.dst = nebula3.common.ttypes.Value()
          self.dst.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeKey')
    if self.src != None:
      oprot.writeFieldBegin('src', TType.STRUCT, 1)
      self.src.write(oprot)
      oprot.writeFieldEnd()
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 2)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.ranking != None:
      oprot.writeFieldBegin('ranking', TType.I64, 3)
      oprot.writeI64(self.ranking)
      oprot.writeFieldEnd()
    if self.dst != None:
      oprot.writeFieldBegin('dst', TType.STRUCT, 4)
      self.dst.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.src is not None:
      value = pprint.pformat(self.src, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    src=%s' % (value))
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.ranking is not None:
      value = pprint.pformat(self.ranking, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ranking=%s' % (value))
    if self.dst is not None:
      value = pprint.pformat(self.dst, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dst=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class NewEdge:
  """
  Attributes:
   - key
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.key = EdgeKey()
          self.key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.props = []
          (_etype228, _size225) = iprot.readListBegin()
          if _size225 >= 0:
            for _i229 in range(_size225):
              _elem230 = nebula3.common.ttypes.Value()
              _elem230.read(iprot)
              self.props.append(_elem230)
          else: 
            while iprot.peekList():
              _elem231 = nebula3.common.ttypes.Value()
              _elem231.read(iprot)
              self.props.append(_elem231)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NewEdge')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRUCT, 1)
      self.key.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.props))
      for iter232 in self.props:
        iter232.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - if_not_exists
   - ignore_existed_index
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype234, _vtype235, _size233 ) = iprot.readMapBegin() 
          if _size233 >= 0:
            for _i237 in range(_size233):
              _key238 = iprot.readI32()
              _val239 = []
              (_etype243, _size240) = iprot.readListBegin()
              if _size240 >= 0:
                for _i244 in range(_size240):
                  _elem245 = NewVertex()
                  _elem245.read(iprot)
                  _val239.append(_elem245)
              else: 
                while iprot.peekList():
                  _elem246 = NewVertex()
                  _elem246.read(iprot)
                  _val239.append(_elem246)
              iprot.readListEnd()
              self.parts[_key238] = _val239
          else: 
            while iprot.peekMap():
              _key247 = iprot.readI32()
              _val248 = []
              (_etype252, _size249) = iprot.readListBegin()
              if _size249 >= 0:
                for _i253 in range(_size249):
                  _elem254 = NewVertex()
                  _elem254.read(iprot)
                  _val248.append(_elem254)
              else: 
                while iprot.peekList():
                  _elem255 = NewVertex()
                  _elem255.read(iprot)
                  _val248.append(_elem255)
              iprot.readListEnd()
              self.parts[_key247] = _val248
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.prop_names = {}
          (_ktype257, _vtype258, _size256 ) = iprot.readMapBegin() 
          if _size256 >= 0:
            for _i260 in range(_size256):
              _key261 = iprot.readI32()
              _val262 = []
              (_etype266, _size263) = iprot.readListBegin()
              if _size263 >= 0:
                for _i267 in range(_size263):
                  _elem268 = iprot.readString()
                  _val262.append(_elem268)
              else: 
                while iprot.peekList():
                  _elem269 = iprot.readString()
                  _val262.append(_elem269)
              iprot.readListEnd()
              self.prop_names[_key261] = _val262
          else: 
            while iprot.peekMap():
              _key270 = iprot.readI32()
              _val271 = []
              (_etype275, _size272) = iprot.readListBegin()
              if _size272 >= 0:
                for _i276 in range(_size272):
                  _elem277 = iprot.readString()
                  _val271.append(_elem277)
              else: 
                while iprot.peekList():
                  _elem278 = iprot.readString()
                  _val271.append(_elem278)
              iprot.readListEnd()
              self.prop_names[_key270] = _val271
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ignore_existed_index = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter279,viter280 in self.parts.items():
        oprot.writeI32(kiter279)
        oprot.writeListBegin(TType.STRUCT, len(viter280))
        for iter281 in viter280:
          iter281.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.prop_names))
      for kiter282,viter283 in self.prop_names.items():
        oprot.writeI32(kiter282)
        oprot.writeListBegin(TType.STRING, len(viter283))
        for iter284 in viter283:
          oprot.writeString(iter284)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.ignore_existed_index != None:
      oprot.writeFieldBegin('ignore_existed_index', TType.BOOL, 5)
      oprot.writeBool(self.ignore_existed_index)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 6)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.ignore_existed_index is not None:
      value = pprint.pformat(self.ignore_existed_index, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ignore_existed_index=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - if_not_exists
   - ignore_existed_index
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype286, _vtype287, _size285 ) = iprot.readMapBegin() 
          if _size285 >= 0:
            for _i289 in range(_size285):
              _key290 = iprot.readI32()
              _val291 = []
              (_etype295, _size292) = iprot.readListBegin()
              if _size292 >= 0:
                for _i296 in range(_size292):
                  _elem297 = NewEdge()
                  _elem297.read(iprot)
                  _val291.append(_elem297)
              else: 
                while iprot.peekList():
                  _elem298 = NewEdge()
                  _elem298.read(iprot)
                  _val291.append(_elem298)
              iprot.readListEnd()
              self.parts[_key290] = _val291
          else: 
            while iprot.peekMap():
              _key299 = iprot.readI32()
              _val300 = []
              (_etype304, _size301) = iprot.readListBegin()
              if _size301 >= 0:
                for _i305 in range(_size301):
                  _elem306 = NewEdge()
                  _elem306.read(iprot)
                  _val300.append(_elem306)
              else: 
                while iprot.peekList():
                  _elem307 = NewEdge()
                  _elem307.read(iprot)
                  _val300.append(_elem307)
              iprot.readListEnd()
              self.parts[_key299] = _val300
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prop_names = []
          (_etype311, _size308) = iprot.readListBegin()
          if _size308 >= 0:
            for _i312 in range(_size308):
              _elem313 = iprot.readString()
              self.prop_names.append(_elem313)
          else: 
            while iprot.peekList():
              _elem314 = iprot.readString()
              self.prop_names.append(_elem314)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.ignore_existed_index = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter315,viter316 in self.parts.items():
        oprot.writeI32(kiter315)
        oprot.writeListBegin(TType.STRUCT, len(viter316))
        for iter317 in viter316:
          iter317.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.prop_names))
      for iter318 in self.prop_names:
        oprot.writeString(iter318)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.ignore_existed_index != None:
      oprot.writeFieldBegin('ignore_existed_index', TType.BOOL, 5)
      oprot.writeBool(self.ignore_existed_index)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 6)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.ignore_existed_index is not None:
      value = pprint.pformat(self.ignore_existed_index, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ignore_existed_index=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DeleteVerticesRequest:
  """
  Attributes:
   - space_id
   - parts
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype320, _vtype321, _size319 ) = iprot.readMapBegin() 
          if _size319 >= 0:
            for _i323 in range(_size319):
              _key324 = iprot.readI32()
              _val325 = []
              (_etype329, _size326) = iprot.readListBegin()
              if _size326 >= 0:
                for _i330 in range(_size326):
                  _elem331 = nebula3.common.ttypes.Value()
                  _elem331.read(iprot)
                  _val325.append(_elem331)
              else: 
                while iprot.peekList():
                  _elem332 = nebula3.common.ttypes.Value()
                  _elem332.read(iprot)
                  _val325.append(_elem332)
              iprot.readListEnd()
              self.parts[_key324] = _val325
          else: 
            while iprot.peekMap():
              _key333 = iprot.readI32()
              _val334 = []
              (_etype338, _size335) = iprot.readListBegin()
              if _size335 >= 0:
                for _i339 in range(_size335):
                  _elem340 = nebula3.common.ttypes.Value()
                  _elem340.read(iprot)
                  _val334.append(_elem340)
              else: 
                while iprot.peekList():
                  _elem341 = nebula3.common.ttypes.Value()
                  _elem341.read(iprot)
                  _val334.append(_elem341)
              iprot.readListEnd()
              self.parts[_key333] = _val334
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteVerticesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter342,viter343 in self.parts.items():
        oprot.writeI32(kiter342)
        oprot.writeListBegin(TType.STRUCT, len(viter343))
        for iter344 in viter343:
          iter344.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DeleteEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype346, _vtype347, _size345 ) = iprot.readMapBegin() 
          if _size345 >= 0:
            for _i349 in range(_size345):
              _key350 = iprot.readI32()
              _val351 = []
              (_etype355, _size352) = iprot.readListBegin()
              if _size352 >= 0:
                for _i356 in range(_size352):
                  _elem357 = EdgeKey()
                  _elem357.read(iprot)
                  _val351.append(_elem357)
              else: 
                while iprot.peekList():
                  _elem358 = EdgeKey()
                  _elem358.read(iprot)
                  _val351.append(_elem358)
              iprot.readListEnd()
              self.parts[_key350] = _val351
          else: 
            while iprot.peekMap():
              _key359 = iprot.readI32()
              _val360 = []
              (_etype364, _size361) = iprot.readListBegin()
              if _size361 >= 0:
                for _i365 in range(_size361):
                  _elem366 = EdgeKey()
                  _elem366.read(iprot)
                  _val360.append(_elem366)
              else: 
                while iprot.peekList():
                  _elem367 = EdgeKey()
                  _elem367.read(iprot)
                  _val360.append(_elem367)
              iprot.readListEnd()
              self.parts[_key359] = _val360
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter368,viter369 in self.parts.items():
        oprot.writeI32(kiter368)
        oprot.writeListBegin(TType.STRUCT, len(viter369))
        for iter370 in viter369:
          iter370.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DelTags:
  """
  Attributes:
   - id
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = nebula3.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tags = []
          (_etype374, _size371) = iprot.readListBegin()
          if _size371 >= 0:
            for _i375 in range(_size371):
              _elem376 = iprot.readI32()
              self.tags.append(_elem376)
          else: 
            while iprot.peekList():
              _elem377 = iprot.readI32()
              self.tags.append(_elem377)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DelTags')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.tags))
      for iter378 in self.tags:
        oprot.writeI32(iter378)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DeleteTagsRequest:
  """
  Attributes:
   - space_id
   - parts
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype380, _vtype381, _size379 ) = iprot.readMapBegin() 
          if _size379 >= 0:
            for _i383 in range(_size379):
              _key384 = iprot.readI32()
              _val385 = []
              (_etype389, _size386) = iprot.readListBegin()
              if _size386 >= 0:
                for _i390 in range(_size386):
                  _elem391 = DelTags()
                  _elem391.read(iprot)
                  _val385.append(_elem391)
              else: 
                while iprot.peekList():
                  _elem392 = DelTags()
                  _elem392.read(iprot)
                  _val385.append(_elem392)
              iprot.readListEnd()
              self.parts[_key384] = _val385
          else: 
            while iprot.peekMap():
              _key393 = iprot.readI32()
              _val394 = []
              (_etype398, _size395) = iprot.readListBegin()
              if _size395 >= 0:
                for _i399 in range(_size395):
                  _elem400 = DelTags()
                  _elem400.read(iprot)
                  _val394.append(_elem400)
              else: 
                while iprot.peekList():
                  _elem401 = DelTags()
                  _elem401.read(iprot)
                  _val394.append(_elem401)
              iprot.readListEnd()
              self.parts[_key393] = _val394
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeleteTagsRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter402,viter403 in self.parts.items():
        oprot.writeI32(kiter402)
        oprot.writeListBegin(TType.STRUCT, len(viter403))
        for iter404 in viter403:
          iter404.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 3)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateResponse:
  """
  Attributes:
   - result
   - props
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula3.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdatedProp:
  """
  Attributes:
   - name
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdatedProp')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateVertexRequest:
  """
  Attributes:
   - space_id
   - part_id
   - vertex_id
   - tag_id
   - updated_props
   - insertable
   - return_props
   - condition
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.vertex_id = nebula3.common.ttypes.Value()
          self.vertex_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype408, _size405) = iprot.readListBegin()
          if _size405 >= 0:
            for _i409 in range(_size405):
              _elem410 = UpdatedProp()
              _elem410.read(iprot)
              self.updated_props.append(_elem410)
          else: 
            while iprot.peekList():
              _elem411 = UpdatedProp()
              _elem411.read(iprot)
              self.updated_props.append(_elem411)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype415, _size412) = iprot.readListBegin()
          if _size412 >= 0:
            for _i416 in range(_size412):
              _elem417 = iprot.readString()
              self.return_props.append(_elem417)
          else: 
            while iprot.peekList():
              _elem418 = iprot.readString()
              self.return_props.append(_elem418)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.vertex_id != None:
      oprot.writeFieldBegin('vertex_id', TType.STRUCT, 3)
      self.vertex_id.write(oprot)
      oprot.writeFieldEnd()
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 4)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter419 in self.updated_props:
        iter419.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[6][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 6)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter420 in self.return_props:
        oprot.writeString(iter420)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 8)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 9)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.vertex_id is not None:
      value = pprint.pformat(self.vertex_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vertex_id=%s' % (value))
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateEdgeRequest:
  """
  Attributes:
   - space_id
   - part_id
   - edge_key
   - updated_props
   - insertable
   - return_props
   - condition
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.edge_key = EdgeKey()
          self.edge_key.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.updated_props = []
          (_etype424, _size421) = iprot.readListBegin()
          if _size421 >= 0:
            for _i425 in range(_size421):
              _elem426 = UpdatedProp()
              _elem426.read(iprot)
              self.updated_props.append(_elem426)
          else: 
            while iprot.peekList():
              _elem427 = UpdatedProp()
              _elem427.read(iprot)
              self.updated_props.append(_elem427)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.insertable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.return_props = []
          (_etype431, _size428) = iprot.readListBegin()
          if _size428 >= 0:
            for _i432 in range(_size428):
              _elem433 = iprot.readString()
              self.return_props.append(_elem433)
          else: 
            while iprot.peekList():
              _elem434 = iprot.readString()
              self.return_props.append(_elem434)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.condition = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.edge_key != None:
      oprot.writeFieldBegin('edge_key', TType.STRUCT, 3)
      self.edge_key.write(oprot)
      oprot.writeFieldEnd()
    if self.updated_props != None:
      oprot.writeFieldBegin('updated_props', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.updated_props))
      for iter435 in self.updated_props:
        iter435.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.insertable != None and self.insertable != self.thrift_spec[5][4]:
      oprot.writeFieldBegin('insertable', TType.BOOL, 5)
      oprot.writeBool(self.insertable)
      oprot.writeFieldEnd()
    if self.return_props != None:
      oprot.writeFieldBegin('return_props', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.return_props))
      for iter436 in self.return_props:
        oprot.writeString(iter436)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.condition != None:
      oprot.writeFieldBegin('condition', TType.STRING, 7)
      oprot.writeString(self.condition)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 8)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.edge_key is not None:
      value = pprint.pformat(self.edge_key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_key=%s' % (value))
    if self.updated_props is not None:
      value = pprint.pformat(self.updated_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    updated_props=%s' % (value))
    if self.insertable is not None:
      value = pprint.pformat(self.insertable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    insertable=%s' % (value))
    if self.return_props is not None:
      value = pprint.pformat(self.return_props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_props=%s' % (value))
    if self.condition is not None:
      value = pprint.pformat(self.condition, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetUUIDReq:
  """
  Attributes:
   - space_id
   - part_id
   - name
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 3)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 4)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetUUIDResp:
  """
  Attributes:
   - result
   - id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.id = nebula3.common.ttypes.Value()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUUIDResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 2)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LookupIndexResp:
  """
  Attributes:
   - result
   - data
   - stat_data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = nebula3.common.ttypes.DataSet()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.stat_data = nebula3.common.ttypes.DataSet()
          self.stat_data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.stat_data != None:
      oprot.writeFieldBegin('stat_data', TType.STRUCT, 3)
      self.stat_data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    if self.stat_data is not None:
      value = pprint.pformat(self.stat_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat_data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexColumnHint:
  """
  Attributes:
   - column_name
   - scan_type
   - begin_value
   - end_value
   - include_begin
   - include_end
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.column_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.scan_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.begin_value = nebula3.common.ttypes.Value()
          self.begin_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.end_value = nebula3.common.ttypes.Value()
          self.end_value.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.include_begin = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.include_end = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexColumnHint')
    if self.column_name != None:
      oprot.writeFieldBegin('column_name', TType.STRING, 1)
      oprot.writeString(self.column_name)
      oprot.writeFieldEnd()
    if self.scan_type != None:
      oprot.writeFieldBegin('scan_type', TType.I32, 2)
      oprot.writeI32(self.scan_type)
      oprot.writeFieldEnd()
    if self.begin_value != None:
      oprot.writeFieldBegin('begin_value', TType.STRUCT, 3)
      self.begin_value.write(oprot)
      oprot.writeFieldEnd()
    if self.end_value != None:
      oprot.writeFieldBegin('end_value', TType.STRUCT, 4)
      self.end_value.write(oprot)
      oprot.writeFieldEnd()
    if self.include_begin != None:
      oprot.writeFieldBegin('include_begin', TType.BOOL, 5)
      oprot.writeBool(self.include_begin)
      oprot.writeFieldEnd()
    if self.include_end != None:
      oprot.writeFieldBegin('include_end', TType.BOOL, 6)
      oprot.writeBool(self.include_end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.column_name is not None:
      value = pprint.pformat(self.column_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_name=%s' % (value))
    if self.scan_type is not None:
      value = pprint.pformat(self.scan_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    scan_type=%s' % (value))
    if self.begin_value is not None:
      value = pprint.pformat(self.begin_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    begin_value=%s' % (value))
    if self.end_value is not None:
      value = pprint.pformat(self.end_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_value=%s' % (value))
    if self.include_begin is not None:
      value = pprint.pformat(self.include_begin, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    include_begin=%s' % (value))
    if self.include_end is not None:
      value = pprint.pformat(self.include_end, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    include_end=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexQueryContext:
  """
  Attributes:
   - index_id
   - filter
   - column_hints
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.column_hints = []
          (_etype440, _size437) = iprot.readListBegin()
          if _size437 >= 0:
            for _i441 in range(_size437):
              _elem442 = IndexColumnHint()
              _elem442.read(iprot)
              self.column_hints.append(_elem442)
          else: 
            while iprot.peekList():
              _elem443 = IndexColumnHint()
              _elem443.read(iprot)
              self.column_hints.append(_elem443)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexQueryContext')
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 1)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 2)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.column_hints != None:
      oprot.writeFieldBegin('column_hints', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.column_hints))
      for iter444 in self.column_hints:
        iter444.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.column_hints is not None:
      value = pprint.pformat(self.column_hints, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    column_hints=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexSpec:
  """
  Attributes:
   - contexts
   - schema_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.contexts = []
          (_etype448, _size445) = iprot.readListBegin()
          if _size445 >= 0:
            for _i449 in range(_size445):
              _elem450 = IndexQueryContext()
              _elem450.read(iprot)
              self.contexts.append(_elem450)
          else: 
            while iprot.peekList():
              _elem451 = IndexQueryContext()
              _elem451.read(iprot)
              self.contexts.append(_elem451)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema_id = nebula3.common.ttypes.SchemaID()
          self.schema_id.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexSpec')
    if self.contexts != None:
      oprot.writeFieldBegin('contexts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.contexts))
      for iter452 in self.contexts:
        iter452.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_id != None:
      oprot.writeFieldBegin('schema_id', TType.STRUCT, 2)
      self.schema_id.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.contexts is not None:
      value = pprint.pformat(self.contexts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    contexts=%s' % (value))
    if self.schema_id is not None:
      value = pprint.pformat(self.schema_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LookupIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - return_columns
   - common
   - limit
   - order_by
   - stat_columns
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype456, _size453) = iprot.readListBegin()
          if _size453 >= 0:
            for _i457 in range(_size453):
              _elem458 = iprot.readI32()
              self.parts.append(_elem458)
          else: 
            while iprot.peekList():
              _elem459 = iprot.readI32()
              self.parts.append(_elem459)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype463, _size460) = iprot.readListBegin()
          if _size460 >= 0:
            for _i464 in range(_size460):
              _elem465 = iprot.readString()
              self.return_columns.append(_elem465)
          else: 
            while iprot.peekList():
              _elem466 = iprot.readString()
              self.return_columns.append(_elem466)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.order_by = []
          (_etype470, _size467) = iprot.readListBegin()
          if _size467 >= 0:
            for _i471 in range(_size467):
              _elem472 = OrderBy()
              _elem472.read(iprot)
              self.order_by.append(_elem472)
          else: 
            while iprot.peekList():
              _elem473 = OrderBy()
              _elem473.read(iprot)
              self.order_by.append(_elem473)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.stat_columns = []
          (_etype477, _size474) = iprot.readListBegin()
          if _size474 >= 0:
            for _i478 in range(_size474):
              _elem479 = StatProp()
              _elem479.read(iprot)
              self.stat_columns.append(_elem479)
          else: 
            while iprot.peekList():
              _elem480 = StatProp()
              _elem480.read(iprot)
              self.stat_columns.append(_elem480)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter481 in self.parts:
        oprot.writeI32(iter481)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.return_columns))
      for iter482 in self.return_columns:
        oprot.writeString(iter482)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 5)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 6)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.order_by != None:
      oprot.writeFieldBegin('order_by', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.order_by))
      for iter483 in self.order_by:
        iter483.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.stat_columns != None:
      oprot.writeFieldBegin('stat_columns', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.stat_columns))
      for iter484 in self.stat_columns:
        iter484.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.order_by is not None:
      value = pprint.pformat(self.order_by, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    order_by=%s' % (value))
    if self.stat_columns is not None:
      value = pprint.pformat(self.stat_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stat_columns=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LookupAndTraverseRequest:
  """
  Attributes:
   - space_id
   - parts
   - indices
   - traverse_spec
   - common
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype488, _size485) = iprot.readListBegin()
          if _size485 >= 0:
            for _i489 in range(_size485):
              _elem490 = iprot.readI32()
              self.parts.append(_elem490)
          else: 
            while iprot.peekList():
              _elem491 = iprot.readI32()
              self.parts.append(_elem491)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.indices = IndexSpec()
          self.indices.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.traverse_spec = TraverseSpec()
          self.traverse_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LookupAndTraverseRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter492 in self.parts:
        oprot.writeI32(iter492)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.indices != None:
      oprot.writeFieldBegin('indices', TType.STRUCT, 3)
      self.indices.write(oprot)
      oprot.writeFieldEnd()
    if self.traverse_spec != None:
      oprot.writeFieldBegin('traverse_spec', TType.STRUCT, 4)
      self.traverse_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 5)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.indices is not None:
      value = pprint.pformat(self.indices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indices=%s' % (value))
    if self.traverse_spec is not None:
      value = pprint.pformat(self.traverse_spec, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    traverse_spec=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanCursor:
  """
  Attributes:
   - next_cursor
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.next_cursor = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanCursor')
    if self.next_cursor != None:
      oprot.writeFieldBegin('next_cursor', TType.STRING, 1)
      oprot.writeString(self.next_cursor)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.next_cursor is not None:
      value = pprint.pformat(self.next_cursor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    next_cursor=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanVertexRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_columns
   - limit
   - start_time
   - end_time
   - filter
   - only_latest_version
   - enable_read_from_follower
   - common
   - username
   - password
   - need_authenticate
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype494, _vtype495, _size493 ) = iprot.readMapBegin() 
          if _size493 >= 0:
            for _i497 in range(_size493):
              _key498 = iprot.readI32()
              _val499 = ScanCursor()
              _val499.read(iprot)
              self.parts[_key498] = _val499
          else: 
            while iprot.peekMap():
              _key500 = iprot.readI32()
              _val501 = ScanCursor()
              _val501.read(iprot)
              self.parts[_key500] = _val501
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype505, _size502) = iprot.readListBegin()
          if _size502 >= 0:
            for _i506 in range(_size502):
              _elem507 = VertexProp()
              _elem507.read(iprot)
              self.return_columns.append(_elem507)
          else: 
            while iprot.peekList():
              _elem508 = VertexProp()
              _elem508.read(iprot)
              self.return_columns.append(_elem508)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.only_latest_version = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enable_read_from_follower = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
      elif fid == 12:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.need_authenticate = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanVertexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.parts))
      for kiter509,viter510 in self.parts.items():
        oprot.writeI32(kiter509)
        viter510.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter511 in self.return_columns:
        iter511.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 5)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 6)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 7)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.only_latest_version != None:
      oprot.writeFieldBegin('only_latest_version', TType.BOOL, 8)
      oprot.writeBool(self.only_latest_version)
      oprot.writeFieldEnd()
    if self.enable_read_from_follower != None:
      oprot.writeFieldBegin('enable_read_from_follower', TType.BOOL, 9)
      oprot.writeBool(self.enable_read_from_follower)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 10)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    if self.username != None:
      oprot.writeFieldBegin('username', TType.STRING, 11)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password != None:
      oprot.writeFieldBegin('password', TType.STRING, 12)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.need_authenticate != None:
      oprot.writeFieldBegin('need_authenticate', TType.BOOL, 13)
      oprot.writeBool(self.need_authenticate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.only_latest_version is not None:
      value = pprint.pformat(self.only_latest_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    only_latest_version=%s' % (value))
    if self.enable_read_from_follower is not None:
      value = pprint.pformat(self.enable_read_from_follower, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_read_from_follower=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    if self.username is not None:
      value = pprint.pformat(self.username, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    username=%s' % (value))
    if self.password is not None:
      value = pprint.pformat(self.password, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    password=%s' % (value))
    if self.need_authenticate is not None:
      value = pprint.pformat(self.need_authenticate, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    need_authenticate=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanEdgeRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_columns
   - limit
   - start_time
   - end_time
   - filter
   - only_latest_version
   - enable_read_from_follower
   - common
   - username
   - password
   - need_authenticate
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype513, _vtype514, _size512 ) = iprot.readMapBegin() 
          if _size512 >= 0:
            for _i516 in range(_size512):
              _key517 = iprot.readI32()
              _val518 = ScanCursor()
              _val518.read(iprot)
              self.parts[_key517] = _val518
          else: 
            while iprot.peekMap():
              _key519 = iprot.readI32()
              _val520 = ScanCursor()
              _val520.read(iprot)
              self.parts[_key519] = _val520
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.return_columns = []
          (_etype524, _size521) = iprot.readListBegin()
          if _size521 >= 0:
            for _i525 in range(_size521):
              _elem526 = EdgeProp()
              _elem526.read(iprot)
              self.return_columns.append(_elem526)
          else: 
            while iprot.peekList():
              _elem527 = EdgeProp()
              _elem527.read(iprot)
              self.return_columns.append(_elem527)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.limit = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.end_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.filter = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.only_latest_version = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.enable_read_from_follower = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.common = RequestCommon()
          self.common.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.BOOL:
          self.need_authenticate = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanEdgeRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.parts))
      for kiter528,viter529 in self.parts.items():
        oprot.writeI32(kiter528)
        viter529.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_columns != None:
      oprot.writeFieldBegin('return_columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.return_columns))
      for iter530 in self.return_columns:
        iter530.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.limit != None:
      oprot.writeFieldBegin('limit', TType.I64, 4)
      oprot.writeI64(self.limit)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 5)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.end_time != None:
      oprot.writeFieldBegin('end_time', TType.I64, 6)
      oprot.writeI64(self.end_time)
      oprot.writeFieldEnd()
    if self.filter != None:
      oprot.writeFieldBegin('filter', TType.STRING, 7)
      oprot.writeString(self.filter)
      oprot.writeFieldEnd()
    if self.only_latest_version != None:
      oprot.writeFieldBegin('only_latest_version', TType.BOOL, 8)
      oprot.writeBool(self.only_latest_version)
      oprot.writeFieldEnd()
    if self.enable_read_from_follower != None:
      oprot.writeFieldBegin('enable_read_from_follower', TType.BOOL, 9)
      oprot.writeBool(self.enable_read_from_follower)
      oprot.writeFieldEnd()
    if self.common != None:
      oprot.writeFieldBegin('common', TType.STRUCT, 10)
      self.common.write(oprot)
      oprot.writeFieldEnd()
    if self.username != None:
      oprot.writeFieldBegin('username', TType.STRING, 11)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password != None:
      oprot.writeFieldBegin('password', TType.STRING, 12)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    if self.need_authenticate != None:
      oprot.writeFieldBegin('need_authenticate', TType.BOOL, 13)
      oprot.writeBool(self.need_authenticate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_columns is not None:
      value = pprint.pformat(self.return_columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_columns=%s' % (value))
    if self.limit is not None:
      value = pprint.pformat(self.limit, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    limit=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.end_time is not None:
      value = pprint.pformat(self.end_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end_time=%s' % (value))
    if self.filter is not None:
      value = pprint.pformat(self.filter, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    filter=%s' % (value))
    if self.only_latest_version is not None:
      value = pprint.pformat(self.only_latest_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    only_latest_version=%s' % (value))
    if self.enable_read_from_follower is not None:
      value = pprint.pformat(self.enable_read_from_follower, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enable_read_from_follower=%s' % (value))
    if self.common is not None:
      value = pprint.pformat(self.common, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    common=%s' % (value))
    if self.username is not None:
      value = pprint.pformat(self.username, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    username=%s' % (value))
    if self.password is not None:
      value = pprint.pformat(self.password, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    password=%s' % (value))
    if self.need_authenticate is not None:
      value = pprint.pformat(self.need_authenticate, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    need_authenticate=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanResponse:
  """
  Attributes:
   - result
   - props
   - cursors
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.props = nebula3.common.ttypes.DataSet()
          self.props.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.cursors = {}
          (_ktype532, _vtype533, _size531 ) = iprot.readMapBegin() 
          if _size531 >= 0:
            for _i535 in range(_size531):
              _key536 = iprot.readI32()
              _val537 = ScanCursor()
              _val537.read(iprot)
              self.cursors[_key536] = _val537
          else: 
            while iprot.peekMap():
              _key538 = iprot.readI32()
              _val539 = ScanCursor()
              _val539.read(iprot)
              self.cursors[_key538] = _val539
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.props != None:
      oprot.writeFieldBegin('props', TType.STRUCT, 2)
      self.props.write(oprot)
      oprot.writeFieldEnd()
    if self.cursors != None:
      oprot.writeFieldBegin('cursors', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.cursors))
      for kiter540,viter541 in self.cursors.items():
        oprot.writeI32(kiter540)
        viter541.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.props is not None:
      value = pprint.pformat(self.props, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    props=%s' % (value))
    if self.cursors is not None:
      value = pprint.pformat(self.cursors, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cursors=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TaskPara:
  """
  Attributes:
   - space_id
   - parts
   - task_specific_paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype545, _size542) = iprot.readListBegin()
          if _size542 >= 0:
            for _i546 in range(_size542):
              _elem547 = iprot.readI32()
              self.parts.append(_elem547)
          else: 
            while iprot.peekList():
              _elem548 = iprot.readI32()
              self.parts.append(_elem548)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.task_specific_paras = []
          (_etype552, _size549) = iprot.readListBegin()
          if _size549 >= 0:
            for _i553 in range(_size549):
              _elem554 = iprot.readString()
              self.task_specific_paras.append(_elem554)
          else: 
            while iprot.peekList():
              _elem555 = iprot.readString()
              self.task_specific_paras.append(_elem555)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TaskPara')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter556 in self.parts:
        oprot.writeI32(iter556)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.task_specific_paras != None:
      oprot.writeFieldBegin('task_specific_paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.task_specific_paras))
      for iter557 in self.task_specific_paras:
        oprot.writeString(iter557)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.task_specific_paras is not None:
      value = pprint.pformat(self.task_specific_paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_specific_paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVGetRequest:
  """
  Attributes:
   - space_id
   - parts
   - return_partly
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype559, _vtype560, _size558 ) = iprot.readMapBegin() 
          if _size558 >= 0:
            for _i562 in range(_size558):
              _key563 = iprot.readI32()
              _val564 = []
              (_etype568, _size565) = iprot.readListBegin()
              if _size565 >= 0:
                for _i569 in range(_size565):
                  _elem570 = iprot.readString()
                  _val564.append(_elem570)
              else: 
                while iprot.peekList():
                  _elem571 = iprot.readString()
                  _val564.append(_elem571)
              iprot.readListEnd()
              self.parts[_key563] = _val564
          else: 
            while iprot.peekMap():
              _key572 = iprot.readI32()
              _val573 = []
              (_etype577, _size574) = iprot.readListBegin()
              if _size574 >= 0:
                for _i578 in range(_size574):
                  _elem579 = iprot.readString()
                  _val573.append(_elem579)
              else: 
                while iprot.peekList():
                  _elem580 = iprot.readString()
                  _val573.append(_elem580)
              iprot.readListEnd()
              self.parts[_key572] = _val573
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.return_partly = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter581,viter582 in self.parts.items():
        oprot.writeI32(kiter581)
        oprot.writeListBegin(TType.STRING, len(viter582))
        for iter583 in viter582:
          oprot.writeString(iter583)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.return_partly != None:
      oprot.writeFieldBegin('return_partly', TType.BOOL, 3)
      oprot.writeBool(self.return_partly)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.return_partly is not None:
      value = pprint.pformat(self.return_partly, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    return_partly=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVGetResponse:
  """
  Attributes:
   - result
   - key_values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.key_values = {}
          (_ktype585, _vtype586, _size584 ) = iprot.readMapBegin() 
          if _size584 >= 0:
            for _i588 in range(_size584):
              _key589 = iprot.readString()
              _val590 = iprot.readString()
              self.key_values[_key589] = _val590
          else: 
            while iprot.peekMap():
              _key591 = iprot.readString()
              _val592 = iprot.readString()
              self.key_values[_key591] = _val592
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVGetResponse')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.key_values != None:
      oprot.writeFieldBegin('key_values', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.key_values))
      for kiter593,viter594 in self.key_values.items():
        oprot.writeString(kiter593)
        oprot.writeString(viter594)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.key_values is not None:
      value = pprint.pformat(self.key_values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key_values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVPutRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype596, _vtype597, _size595 ) = iprot.readMapBegin() 
          if _size595 >= 0:
            for _i599 in range(_size595):
              _key600 = iprot.readI32()
              _val601 = []
              (_etype605, _size602) = iprot.readListBegin()
              if _size602 >= 0:
                for _i606 in range(_size602):
                  _elem607 = nebula3.common.ttypes.KeyValue()
                  _elem607.read(iprot)
                  _val601.append(_elem607)
              else: 
                while iprot.peekList():
                  _elem608 = nebula3.common.ttypes.KeyValue()
                  _elem608.read(iprot)
                  _val601.append(_elem608)
              iprot.readListEnd()
              self.parts[_key600] = _val601
          else: 
            while iprot.peekMap():
              _key609 = iprot.readI32()
              _val610 = []
              (_etype614, _size611) = iprot.readListBegin()
              if _size611 >= 0:
                for _i615 in range(_size611):
                  _elem616 = nebula3.common.ttypes.KeyValue()
                  _elem616.read(iprot)
                  _val610.append(_elem616)
              else: 
                while iprot.peekList():
                  _elem617 = nebula3.common.ttypes.KeyValue()
                  _elem617.read(iprot)
                  _val610.append(_elem617)
              iprot.readListEnd()
              self.parts[_key609] = _val610
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVPutRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter618,viter619 in self.parts.items():
        oprot.writeI32(kiter618)
        oprot.writeListBegin(TType.STRUCT, len(viter619))
        for iter620 in viter619:
          iter620.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KVRemoveRequest:
  """
  Attributes:
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype622, _vtype623, _size621 ) = iprot.readMapBegin() 
          if _size621 >= 0:
            for _i625 in range(_size621):
              _key626 = iprot.readI32()
              _val627 = []
              (_etype631, _size628) = iprot.readListBegin()
              if _size628 >= 0:
                for _i632 in range(_size628):
                  _elem633 = iprot.readString()
                  _val627.append(_elem633)
              else: 
                while iprot.peekList():
                  _elem634 = iprot.readString()
                  _val627.append(_elem634)
              iprot.readListEnd()
              self.parts[_key626] = _val627
          else: 
            while iprot.peekMap():
              _key635 = iprot.readI32()
              _val636 = []
              (_etype640, _size637) = iprot.readListBegin()
              if _size637 >= 0:
                for _i641 in range(_size637):
                  _elem642 = iprot.readString()
                  _val636.append(_elem642)
              else: 
                while iprot.peekList():
                  _elem643 = iprot.readString()
                  _val636.append(_elem643)
              iprot.readListEnd()
              self.parts[_key635] = _val636
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KVRemoveRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter644,viter645 in self.parts.items():
        oprot.writeI32(kiter644)
        oprot.writeListBegin(TType.STRING, len(viter645))
        for iter646 in viter645:
          oprot.writeString(iter646)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AdminExecResp:
  """
  Attributes:
   - result
   - stats
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.stats = nebula3.meta.ttypes.StatsItem()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminExecResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.stats != None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 2)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.stats is not None:
      value = pprint.pformat(self.stats, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stats=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TransLeaderReq:
  """
  Attributes:
   - space_id
   - part_id
   - new_leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.new_leader = nebula3.common.ttypes.HostAddr()
          self.new_leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TransLeaderReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.new_leader != None:
      oprot.writeFieldBegin('new_leader', TType.STRUCT, 3)
      self.new_leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.new_leader is not None:
      value = pprint.pformat(self.new_leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddPartReq:
  """
  Attributes:
   - space_id
   - part_id
   - as_learner
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.as_learner = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.peers = []
          (_etype650, _size647) = iprot.readListBegin()
          if _size647 >= 0:
            for _i651 in range(_size647):
              _elem652 = nebula3.common.ttypes.HostAddr()
              _elem652.read(iprot)
              self.peers.append(_elem652)
          else: 
            while iprot.peekList():
              _elem653 = nebula3.common.ttypes.HostAddr()
              _elem653.read(iprot)
              self.peers.append(_elem653)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddPartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.as_learner != None:
      oprot.writeFieldBegin('as_learner', TType.BOOL, 3)
      oprot.writeBool(self.as_learner)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter654 in self.peers:
        iter654.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.as_learner is not None:
      value = pprint.pformat(self.as_learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    as_learner=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddLearnerReq:
  """
  Attributes:
   - space_id
   - part_id
   - learner
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.learner = nebula3.common.ttypes.HostAddr()
          self.learner.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddLearnerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.learner != None:
      oprot.writeFieldBegin('learner', TType.STRUCT, 3)
      self.learner.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.learner is not None:
      value = pprint.pformat(self.learner, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    learner=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RemovePartReq:
  """
  Attributes:
   - space_id
   - part_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemovePartReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class MemberChangeReq:
  """
  Attributes:
   - space_id
   - part_id
   - peer
   - add
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.peer = nebula3.common.ttypes.HostAddr()
          self.peer.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.add = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MemberChangeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peer != None:
      oprot.writeFieldBegin('peer', TType.STRUCT, 3)
      self.peer.write(oprot)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BOOL, 4)
      oprot.writeBool(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peer is not None:
      value = pprint.pformat(self.peer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peer=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CatchUpDataReq:
  """
  Attributes:
   - space_id
   - part_id
   - target
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.target = nebula3.common.ttypes.HostAddr()
          self.target.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CatchUpDataReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.target != None:
      oprot.writeFieldBegin('target', TType.STRUCT, 3)
      self.target.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.target is not None:
      value = pprint.pformat(self.target, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    target=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetLeaderReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateCPRequest:
  """
  Attributes:
   - space_ids
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.space_ids = []
          (_etype658, _size655) = iprot.readListBegin()
          if _size655 >= 0:
            for _i659 in range(_size655):
              _elem660 = iprot.readI32()
              self.space_ids.append(_elem660)
          else: 
            while iprot.peekList():
              _elem661 = iprot.readI32()
              self.space_ids.append(_elem661)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPRequest')
    if self.space_ids != None:
      oprot.writeFieldBegin('space_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.space_ids))
      for iter662 in self.space_ids:
        oprot.writeI32(iter662)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_ids is not None:
      value = pprint.pformat(self.space_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_ids=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateCPResp:
  """
  Attributes:
   - code
   - info
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.info = []
          (_etype666, _size663) = iprot.readListBegin()
          if _size663 >= 0:
            for _i667 in range(_size663):
              _elem668 = nebula3.common.ttypes.CheckpointInfo()
              _elem668.read(iprot)
              self.info.append(_elem668)
          else: 
            while iprot.peekList():
              _elem669 = nebula3.common.ttypes.CheckpointInfo()
              _elem669.read(iprot)
              self.info.append(_elem669)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateCPResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.info != None:
      oprot.writeFieldBegin('info', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.info))
      for iter670 in self.info:
        iter670.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.info is not None:
      value = pprint.pformat(self.info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    info=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropCPRequest:
  """
  Attributes:
   - space_ids
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.space_ids = []
          (_etype674, _size671) = iprot.readListBegin()
          if _size671 >= 0:
            for _i675 in range(_size671):
              _elem676 = iprot.readI32()
              self.space_ids.append(_elem676)
          else: 
            while iprot.peekList():
              _elem677 = iprot.readI32()
              self.space_ids.append(_elem677)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropCPRequest')
    if self.space_ids != None:
      oprot.writeFieldBegin('space_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.space_ids))
      for iter678 in self.space_ids:
        oprot.writeI32(iter678)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_ids is not None:
      value = pprint.pformat(self.space_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_ids=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropCPResp:
  """
  Attributes:
   - code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropCPResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class BlockingSignRequest:
  """
  Attributes:
   - space_ids
   - sign
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.space_ids = []
          (_etype682, _size679) = iprot.readListBegin()
          if _size679 >= 0:
            for _i683 in range(_size679):
              _elem684 = iprot.readI32()
              self.space_ids.append(_elem684)
          else: 
            while iprot.peekList():
              _elem685 = iprot.readI32()
              self.space_ids.append(_elem685)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.sign = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BlockingSignRequest')
    if self.space_ids != None:
      oprot.writeFieldBegin('space_ids', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.space_ids))
      for iter686 in self.space_ids:
        oprot.writeI32(iter686)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sign != None:
      oprot.writeFieldBegin('sign', TType.I32, 2)
      oprot.writeI32(self.sign)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_ids is not None:
      value = pprint.pformat(self.space_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_ids=%s' % (value))
    if self.sign is not None:
      value = pprint.pformat(self.sign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sign=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class BlockingSignResp:
  """
  Attributes:
   - code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BlockingSignResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetLeaderPartsResp:
  """
  Attributes:
   - code
   - leader_parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype688, _vtype689, _size687 ) = iprot.readMapBegin() 
          if _size687 >= 0:
            for _i691 in range(_size687):
              _key692 = iprot.readI32()
              _val693 = []
              (_etype697, _size694) = iprot.readListBegin()
              if _size694 >= 0:
                for _i698 in range(_size694):
                  _elem699 = iprot.readI32()
                  _val693.append(_elem699)
              else: 
                while iprot.peekList():
                  _elem700 = iprot.readI32()
                  _val693.append(_elem700)
              iprot.readListEnd()
              self.leader_parts[_key692] = _val693
          else: 
            while iprot.peekMap():
              _key701 = iprot.readI32()
              _val702 = []
              (_etype706, _size703) = iprot.readListBegin()
              if _size703 >= 0:
                for _i707 in range(_size703):
                  _elem708 = iprot.readI32()
                  _val702.append(_elem708)
              else: 
                while iprot.peekList():
                  _elem709 = iprot.readI32()
                  _val702.append(_elem709)
              iprot.readListEnd()
              self.leader_parts[_key701] = _val702
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetLeaderPartsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_parts))
      for kiter710,viter711 in self.leader_parts.items():
        oprot.writeI32(kiter710)
        oprot.writeListBegin(TType.I32, len(viter711))
        for iter712 in viter711:
          oprot.writeI32(iter712)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CheckPeersReq:
  """
  Attributes:
   - space_id
   - part_id
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype716, _size713) = iprot.readListBegin()
          if _size713 >= 0:
            for _i717 in range(_size713):
              _elem718 = nebula3.common.ttypes.HostAddr()
              _elem718.read(iprot)
              self.peers.append(_elem718)
          else: 
            while iprot.peekList():
              _elem719 = nebula3.common.ttypes.HostAddr()
              _elem719.read(iprot)
              self.peers.append(_elem719)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CheckPeersReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 2)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter720 in self.peers:
        iter720.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RebuildIndexRequest:
  """
  Attributes:
   - space_id
   - parts
   - index_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.parts = []
          (_etype724, _size721) = iprot.readListBegin()
          if _size721 >= 0:
            for _i725 in range(_size721):
              _elem726 = iprot.readI32()
              self.parts.append(_elem726)
          else: 
            while iprot.peekList():
              _elem727 = iprot.readI32()
              self.parts.append(_elem727)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter728 in self.parts:
        oprot.writeI32(iter728)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 3)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListClusterInfoResp:
  """
  Attributes:
   - result
   - dir
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.result = ResponseCommon()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dir = nebula3.common.ttypes.DirInfo()
          self.dir.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListClusterInfoResp')
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 1)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    if self.dir != None:
      oprot.writeFieldBegin('dir', TType.STRUCT, 2)
      self.dir.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.dir is not None:
      value = pprint.pformat(self.dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dir=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListClusterInfoReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListClusterInfoReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddTaskRequest:
  """
  Attributes:
   - job_type
   - job_id
   - task_id
   - para
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.para = TaskPara()
          self.para.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddTaskRequest')
    if self.job_type != None:
      oprot.writeFieldBegin('job_type', TType.I32, 1)
      oprot.writeI32(self.job_type)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 2)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 3)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.para != None:
      oprot.writeFieldBegin('para', TType.STRUCT, 4)
      self.para.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_type is not None:
      value = pprint.pformat(self.job_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_type=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.para is not None:
      value = pprint.pformat(self.para, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    para=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddTaskResp:
  """
  Attributes:
   - code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddTaskResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StopTaskRequest:
  """
  Attributes:
   - job_id
   - task_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StopTaskRequest')
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 1)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 2)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StopTaskResp:
  """
  Attributes:
   - code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StopTaskResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ClearSpaceReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ClearSpaceReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ClearSpaceResp:
  """
  Attributes:
   - code
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ClearSpaceResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ChainAddEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - prop_names
   - if_not_exists
   - term
   - edge_version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype730, _vtype731, _size729 ) = iprot.readMapBegin() 
          if _size729 >= 0:
            for _i733 in range(_size729):
              _key734 = iprot.readI32()
              _val735 = []
              (_etype739, _size736) = iprot.readListBegin()
              if _size736 >= 0:
                for _i740 in range(_size736):
                  _elem741 = NewEdge()
                  _elem741.read(iprot)
                  _val735.append(_elem741)
              else: 
                while iprot.peekList():
                  _elem742 = NewEdge()
                  _elem742.read(iprot)
                  _val735.append(_elem742)
              iprot.readListEnd()
              self.parts[_key734] = _val735
          else: 
            while iprot.peekMap():
              _key743 = iprot.readI32()
              _val744 = []
              (_etype748, _size745) = iprot.readListBegin()
              if _size745 >= 0:
                for _i749 in range(_size745):
                  _elem750 = NewEdge()
                  _elem750.read(iprot)
                  _val744.append(_elem750)
              else: 
                while iprot.peekList():
                  _elem751 = NewEdge()
                  _elem751.read(iprot)
                  _val744.append(_elem751)
              iprot.readListEnd()
              self.parts[_key743] = _val744
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prop_names = []
          (_etype755, _size752) = iprot.readListBegin()
          if _size752 >= 0:
            for _i756 in range(_size752):
              _elem757 = iprot.readString()
              self.prop_names.append(_elem757)
          else: 
            while iprot.peekList():
              _elem758 = iprot.readString()
              self.prop_names.append(_elem758)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.edge_version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChainAddEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter759,viter760 in self.parts.items():
        oprot.writeI32(kiter759)
        oprot.writeListBegin(TType.STRUCT, len(viter760))
        for iter761 in viter760:
          iter761.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.prop_names != None:
      oprot.writeFieldBegin('prop_names', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.prop_names))
      for iter762 in self.prop_names:
        oprot.writeString(iter762)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 5)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    if self.edge_version != None:
      oprot.writeFieldBegin('edge_version', TType.I64, 6)
      oprot.writeI64(self.edge_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.prop_names is not None:
      value = pprint.pformat(self.prop_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prop_names=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    if self.edge_version is not None:
      value = pprint.pformat(self.edge_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ChainUpdateEdgeRequest:
  """
  Attributes:
   - update_edge_request
   - term
   - edge_version
   - space_id
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.update_edge_request = UpdateEdgeRequest()
          self.update_edge_request.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.edge_version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.parts = []
          (_etype766, _size763) = iprot.readListBegin()
          if _size763 >= 0:
            for _i767 in range(_size763):
              _elem768 = iprot.readI32()
              self.parts.append(_elem768)
          else: 
            while iprot.peekList():
              _elem769 = iprot.readI32()
              self.parts.append(_elem769)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChainUpdateEdgeRequest')
    if self.update_edge_request != None:
      oprot.writeFieldBegin('update_edge_request', TType.STRUCT, 1)
      self.update_edge_request.write(oprot)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 2)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    if self.edge_version != None:
      oprot.writeFieldBegin('edge_version', TType.I64, 3)
      oprot.writeI64(self.edge_version)
      oprot.writeFieldEnd()
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 4)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.parts))
      for iter770 in self.parts:
        oprot.writeI32(iter770)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.update_edge_request is not None:
      value = pprint.pformat(self.update_edge_request, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    update_edge_request=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    if self.edge_version is not None:
      value = pprint.pformat(self.edge_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_version=%s' % (value))
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ChainDeleteEdgesRequest:
  """
  Attributes:
   - space_id
   - parts
   - txn_id
   - term
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype772, _vtype773, _size771 ) = iprot.readMapBegin() 
          if _size771 >= 0:
            for _i775 in range(_size771):
              _key776 = iprot.readI32()
              _val777 = []
              (_etype781, _size778) = iprot.readListBegin()
              if _size778 >= 0:
                for _i782 in range(_size778):
                  _elem783 = EdgeKey()
                  _elem783.read(iprot)
                  _val777.append(_elem783)
              else: 
                while iprot.peekList():
                  _elem784 = EdgeKey()
                  _elem784.read(iprot)
                  _val777.append(_elem784)
              iprot.readListEnd()
              self.parts[_key776] = _val777
          else: 
            while iprot.peekMap():
              _key785 = iprot.readI32()
              _val786 = []
              (_etype790, _size787) = iprot.readListBegin()
              if _size787 >= 0:
                for _i791 in range(_size787):
                  _elem792 = EdgeKey()
                  _elem792.read(iprot)
                  _val786.append(_elem792)
              else: 
                while iprot.peekList():
                  _elem793 = EdgeKey()
                  _elem793.read(iprot)
                  _val786.append(_elem793)
              iprot.readListEnd()
              self.parts[_key785] = _val786
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.txn_id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChainDeleteEdgesRequest')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter794,viter795 in self.parts.items():
        oprot.writeI32(kiter794)
        oprot.writeListBegin(TType.STRUCT, len(viter795))
        for iter796 in viter795:
          iter796.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.txn_id != None:
      oprot.writeFieldBegin('txn_id', TType.STRING, 3)
      oprot.writeString(self.txn_id)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 4)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.txn_id is not None:
      value = pprint.pformat(self.txn_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    txn_id=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(RequestCommon)
RequestCommon.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 1, ), # 1
  (2, TType.I64, 'plan_id', None, None, 1, ), # 2
  (3, TType.BOOL, 'profile_detail', None, None, 1, ), # 3
)

RequestCommon.thrift_struct_annotations = {
}
RequestCommon.thrift_field_annotations = {
}

def RequestCommon__init__(self, session_id=None, plan_id=None, profile_detail=None,):
  self.session_id = session_id
  self.plan_id = plan_id
  self.profile_detail = profile_detail

RequestCommon.__init__ = RequestCommon__init__

def RequestCommon__setstate__(self, state):
  state.setdefault('session_id', None)
  state.setdefault('plan_id', None)
  state.setdefault('profile_detail', None)
  self.__dict__ = state

RequestCommon.__getstate__ = lambda self: self.__dict__.copy()
RequestCommon.__setstate__ = RequestCommon__setstate__

all_structs.append(PartitionResult)
PartitionResult.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 0, ), # 1
  (2, TType.I32, 'part_id', None, None, 0, ), # 2
  (3, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 3
)

PartitionResult.thrift_struct_annotations = {
}
PartitionResult.thrift_field_annotations = {
}

def PartitionResult__init__(self, code=None, part_id=None, leader=None,):
  self.code = code
  self.part_id = part_id
  self.leader = leader

PartitionResult.__init__ = PartitionResult__init__

def PartitionResult__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

PartitionResult.__getstate__ = lambda self: self.__dict__.copy()
PartitionResult.__setstate__ = PartitionResult__setstate__

all_structs.append(ResponseCommon)
ResponseCommon.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'failed_parts', (TType.STRUCT,[PartitionResult, PartitionResult.thrift_spec, False]), None, 0, ), # 1
  (2, TType.I64, 'latency_in_us', None, None, 0, ), # 2
  (3, TType.MAP, 'latency_detail_us', (TType.STRING,True,TType.I32,None), None, 1, ), # 3
)

ResponseCommon.thrift_struct_annotations = {
}
ResponseCommon.thrift_field_annotations = {
}

def ResponseCommon__init__(self, failed_parts=None, latency_in_us=None, latency_detail_us=None,):
  self.failed_parts = failed_parts
  self.latency_in_us = latency_in_us
  self.latency_detail_us = latency_detail_us

ResponseCommon.__init__ = ResponseCommon__init__

def ResponseCommon__setstate__(self, state):
  state.setdefault('failed_parts', None)
  state.setdefault('latency_in_us', None)
  state.setdefault('latency_detail_us', None)
  self.__dict__ = state

ResponseCommon.__getstate__ = lambda self: self.__dict__.copy()
ResponseCommon.__setstate__ = ResponseCommon__setstate__

all_structs.append(StatProp)
StatProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'prop', False, None, 2, ), # 2
  (3, TType.I32, 'stat', StatType, None, 2, ), # 3
)

StatProp.thrift_struct_annotations = {
}
StatProp.thrift_field_annotations = {
}

def StatProp__init__(self, alias=None, prop=None, stat=None,):
  self.alias = alias
  self.prop = prop
  self.stat = stat

StatProp.__init__ = StatProp__init__

def StatProp__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('prop', None)
  state.setdefault('stat', None)
  self.__dict__ = state

StatProp.__getstate__ = lambda self: self.__dict__.copy()
StatProp.__setstate__ = StatProp__setstate__

all_structs.append(Expr)
Expr.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'alias', False, None, 2, ), # 1
  (2, TType.STRING, 'expr', False, None, 2, ), # 2
)

Expr.thrift_struct_annotations = {
}
Expr.thrift_field_annotations = {
}

def Expr__init__(self, alias=None, expr=None,):
  self.alias = alias
  self.expr = expr

Expr.__init__ = Expr__init__

def Expr__setstate__(self, state):
  state.setdefault('alias', None)
  state.setdefault('expr', None)
  self.__dict__ = state

Expr.__getstate__ = lambda self: self.__dict__.copy()
Expr.__setstate__ = Expr__setstate__

all_structs.append(EdgeProp)
EdgeProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

EdgeProp.thrift_struct_annotations = {
}
EdgeProp.thrift_field_annotations = {
}

def EdgeProp__init__(self, type=None, props=None,):
  self.type = type
  self.props = props

EdgeProp.__init__ = EdgeProp__init__

def EdgeProp__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('props', None)
  self.__dict__ = state

EdgeProp.__getstate__ = lambda self: self.__dict__.copy()
EdgeProp.__setstate__ = EdgeProp__setstate__

all_structs.append(VertexProp)
VertexProp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRING,False), None, 2, ), # 2
)

VertexProp.thrift_struct_annotations = {
}
VertexProp.thrift_field_annotations = {
}

def VertexProp__init__(self, tag=None, props=None,):
  self.tag = tag
  self.props = props

VertexProp.__init__ = VertexProp__init__

def VertexProp__setstate__(self, state):
  state.setdefault('tag', None)
  state.setdefault('props', None)
  self.__dict__ = state

VertexProp.__getstate__ = lambda self: self.__dict__.copy()
VertexProp.__setstate__ = VertexProp__setstate__

all_structs.append(OrderBy)
OrderBy.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'prop', False, None, 2, ), # 1
  (2, TType.I32, 'direction', OrderDirection, None, 2, ), # 2
)

OrderBy.thrift_struct_annotations = {
}
OrderBy.thrift_field_annotations = {
}

def OrderBy__init__(self, prop=None, direction=None,):
  self.prop = prop
  self.direction = direction

OrderBy.__init__ = OrderBy__init__

def OrderBy__setstate__(self, state):
  state.setdefault('prop', None)
  state.setdefault('direction', None)
  self.__dict__ = state

OrderBy.__getstate__ = lambda self: self.__dict__.copy()
OrderBy.__setstate__ = OrderBy__setstate__

all_structs.append(TraverseSpec)
TraverseSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'edge_types', (TType.I32,None), None, 2, ), # 1
  (2, TType.I32, 'edge_direction', EdgeDirection,   1, 2, ), # 2
  (3, TType.BOOL, 'dedup', None, False, 2, ), # 3
  (4, TType.LIST, 'stat_props', (TType.STRUCT,[StatProp, StatProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 5
  (6, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 6
  (7, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 7
  (8, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 8
  (9, TType.BOOL, 'random', None, None, 1, ), # 9
  (10, TType.I64, 'limit', None, None, 1, ), # 10
  (11, TType.STRING, 'filter', False, None, 1, ), # 11
  (12, TType.STRING, 'tag_filter', False, None, 1, ), # 12
)

TraverseSpec.thrift_struct_annotations = {
}
TraverseSpec.thrift_field_annotations = {
}

def TraverseSpec__init__(self, edge_types=None, edge_direction=TraverseSpec.thrift_spec[2][4], dedup=TraverseSpec.thrift_spec[3][4], stat_props=None, vertex_props=None, edge_props=None, expressions=None, order_by=None, random=None, limit=None, filter=None, tag_filter=None,):
  self.edge_types = edge_types
  self.edge_direction = edge_direction
  self.dedup = dedup
  self.stat_props = stat_props
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.order_by = order_by
  self.random = random
  self.limit = limit
  self.filter = filter
  self.tag_filter = tag_filter

TraverseSpec.__init__ = TraverseSpec__init__

def TraverseSpec__setstate__(self, state):
  state.setdefault('edge_types', None)
  state.setdefault('edge_direction',   1)
  state.setdefault('dedup', False)
  state.setdefault('stat_props', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('order_by', None)
  state.setdefault('random', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  state.setdefault('tag_filter', None)
  self.__dict__ = state

TraverseSpec.__getstate__ = lambda self: self.__dict__.copy()
TraverseSpec.__setstate__ = TraverseSpec__setstate__

all_structs.append(GetNeighborsRequest)
GetNeighborsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'column_names', (TType.STRING,False), None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True])), None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 5
)

GetNeighborsRequest.thrift_struct_annotations = {
}
GetNeighborsRequest.thrift_field_annotations = {
}

def GetNeighborsRequest__init__(self, space_id=None, column_names=None, parts=None, traverse_spec=None, common=None,):
  self.space_id = space_id
  self.column_names = column_names
  self.parts = parts
  self.traverse_spec = traverse_spec
  self.common = common

GetNeighborsRequest.__init__ = GetNeighborsRequest__init__

def GetNeighborsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('column_names', None)
  state.setdefault('parts', None)
  state.setdefault('traverse_spec', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetNeighborsRequest.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsRequest.__setstate__ = GetNeighborsRequest__setstate__

all_structs.append(GetNeighborsResponse)
GetNeighborsResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'vertices', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetNeighborsResponse.thrift_struct_annotations = {
}
GetNeighborsResponse.thrift_field_annotations = {
}

def GetNeighborsResponse__init__(self, result=None, vertices=None,):
  self.result = result
  self.vertices = vertices

GetNeighborsResponse.__init__ = GetNeighborsResponse__init__

def GetNeighborsResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('vertices', None)
  self.__dict__ = state

GetNeighborsResponse.__getstate__ = lambda self: self.__dict__.copy()
GetNeighborsResponse.__setstate__ = GetNeighborsResponse__setstate__

all_structs.append(GetDstBySrcRequest)
GetDstBySrcRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True])), None, 2, ), # 2
  (3, TType.LIST, 'edge_types', (TType.I32,None), None, 2, ), # 3
  (4, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 4
)

GetDstBySrcRequest.thrift_struct_annotations = {
}
GetDstBySrcRequest.thrift_field_annotations = {
}

def GetDstBySrcRequest__init__(self, space_id=None, parts=None, edge_types=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.edge_types = edge_types
  self.common = common

GetDstBySrcRequest.__init__ = GetDstBySrcRequest__init__

def GetDstBySrcRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('edge_types', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetDstBySrcRequest.__getstate__ = lambda self: self.__dict__.copy()
GetDstBySrcRequest.__setstate__ = GetDstBySrcRequest__setstate__

all_structs.append(GetDstBySrcResponse)
GetDstBySrcResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'dsts', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetDstBySrcResponse.thrift_struct_annotations = {
}
GetDstBySrcResponse.thrift_field_annotations = {
}

def GetDstBySrcResponse__init__(self, result=None, dsts=None,):
  self.result = result
  self.dsts = dsts

GetDstBySrcResponse.__init__ = GetDstBySrcResponse__init__

def GetDstBySrcResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('dsts', None)
  self.__dict__ = state

GetDstBySrcResponse.__getstate__ = lambda self: self.__dict__.copy()
GetDstBySrcResponse.__setstate__ = GetDstBySrcResponse__setstate__

all_structs.append(ExecResponse)
ExecResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
)

ExecResponse.thrift_struct_annotations = {
}
ExecResponse.thrift_field_annotations = {
}

def ExecResponse__init__(self, result=None,):
  self.result = result

ExecResponse.__init__ = ExecResponse__init__

def ExecResponse__setstate__(self, state):
  state.setdefault('result', None)
  self.__dict__ = state

ExecResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecResponse.__setstate__ = ExecResponse__setstate__

all_structs.append(GetPropRequest)
GetPropRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.Row, nebula3.common.ttypes.Row.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'vertex_props', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 1, ), # 3
  (4, TType.LIST, 'edge_props', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'expressions', (TType.STRUCT,[Expr, Expr.thrift_spec, False]), None, 1, ), # 5
  (6, TType.BOOL, 'dedup', None, False, 2, ), # 6
  (7, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 7
  (8, TType.I64, 'limit', None, None, 1, ), # 8
  (9, TType.STRING, 'filter', False, None, 1, ), # 9
  (10, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 10
)

GetPropRequest.thrift_struct_annotations = {
}
GetPropRequest.thrift_field_annotations = {
}

def GetPropRequest__init__(self, space_id=None, parts=None, vertex_props=None, edge_props=None, expressions=None, dedup=GetPropRequest.thrift_spec[6][4], order_by=None, limit=None, filter=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.vertex_props = vertex_props
  self.edge_props = edge_props
  self.expressions = expressions
  self.dedup = dedup
  self.order_by = order_by
  self.limit = limit
  self.filter = filter
  self.common = common

GetPropRequest.__init__ = GetPropRequest__init__

def GetPropRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('vertex_props', None)
  state.setdefault('edge_props', None)
  state.setdefault('expressions', None)
  state.setdefault('dedup', False)
  state.setdefault('order_by', None)
  state.setdefault('limit', None)
  state.setdefault('filter', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetPropRequest.__getstate__ = lambda self: self.__dict__.copy()
GetPropRequest.__setstate__ = GetPropRequest__setstate__

all_structs.append(GetPropResponse)
GetPropResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'props', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

GetPropResponse.thrift_struct_annotations = {
}
GetPropResponse.thrift_field_annotations = {
}

def GetPropResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

GetPropResponse.__init__ = GetPropResponse__init__

def GetPropResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

GetPropResponse.__getstate__ = lambda self: self.__dict__.copy()
GetPropResponse.__setstate__ = GetPropResponse__setstate__

all_structs.append(NewTag)
NewTag.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewTag.thrift_struct_annotations = {
}
NewTag.thrift_field_annotations = {
}

def NewTag__init__(self, tag_id=None, props=None,):
  self.tag_id = tag_id
  self.props = props

NewTag.__init__ = NewTag__init__

def NewTag__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewTag.__getstate__ = lambda self: self.__dict__.copy()
NewTag.__setstate__ = NewTag__setstate__

all_structs.append(NewVertex)
NewVertex.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.STRUCT,[NewTag, NewTag.thrift_spec, False]), None, 2, ), # 2
)

NewVertex.thrift_struct_annotations = {
}
NewVertex.thrift_field_annotations = {
}

def NewVertex__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

NewVertex.__init__ = NewVertex__init__

def NewVertex__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

NewVertex.__getstate__ = lambda self: self.__dict__.copy()
NewVertex.__setstate__ = NewVertex__setstate__

all_structs.append(EdgeKey)
EdgeKey.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'src', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.I32, 'edge_type', None, None, 2, ), # 2
  (3, TType.I64, 'ranking', None, None, 2, ), # 3
  (4, TType.STRUCT, 'dst', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

EdgeKey.thrift_struct_annotations = {
}
EdgeKey.thrift_field_annotations = {
}

def EdgeKey__init__(self, src=None, edge_type=None, ranking=None, dst=None,):
  self.src = src
  self.edge_type = edge_type
  self.ranking = ranking
  self.dst = dst

EdgeKey.__init__ = EdgeKey__init__

def EdgeKey__setstate__(self, state):
  state.setdefault('src', None)
  state.setdefault('edge_type', None)
  state.setdefault('ranking', None)
  state.setdefault('dst', None)
  self.__dict__ = state

EdgeKey.__getstate__ = lambda self: self.__dict__.copy()
EdgeKey.__setstate__ = EdgeKey__setstate__

all_structs.append(NewEdge)
NewEdge.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'props', (TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 2
)

NewEdge.thrift_struct_annotations = {
}
NewEdge.thrift_field_annotations = {
}

def NewEdge__init__(self, key=None, props=None,):
  self.key = key
  self.props = props

NewEdge.__init__ = NewEdge__init__

def NewEdge__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('props', None)
  self.__dict__ = state

NewEdge.__getstate__ = lambda self: self.__dict__.copy()
NewEdge.__setstate__ = NewEdge__setstate__

all_structs.append(AddVerticesRequest)
AddVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewVertex, NewVertex.thrift_spec, False])), None, 2, ), # 2
  (3, TType.MAP, 'prop_names', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
  (5, TType.BOOL, 'ignore_existed_index', None, False, 2, ), # 5
  (6, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 6
)

AddVerticesRequest.thrift_struct_annotations = {
}
AddVerticesRequest.thrift_field_annotations = {
}

def AddVerticesRequest__init__(self, space_id=None, parts=None, prop_names=None, if_not_exists=None, ignore_existed_index=AddVerticesRequest.thrift_spec[5][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.if_not_exists = if_not_exists
  self.ignore_existed_index = ignore_existed_index
  self.common = common

AddVerticesRequest.__init__ = AddVerticesRequest__init__

def AddVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('ignore_existed_index', False)
  state.setdefault('common', None)
  self.__dict__ = state

AddVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddVerticesRequest.__setstate__ = AddVerticesRequest__setstate__

all_structs.append(AddEdgesRequest)
AddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewEdge, NewEdge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'prop_names', (TType.STRING,False), None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
  (5, TType.BOOL, 'ignore_existed_index', None, False, 2, ), # 5
  (6, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 6
)

AddEdgesRequest.thrift_struct_annotations = {
}
AddEdgesRequest.thrift_field_annotations = {
}

def AddEdgesRequest__init__(self, space_id=None, parts=None, prop_names=None, if_not_exists=None, ignore_existed_index=AddEdgesRequest.thrift_spec[5][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.if_not_exists = if_not_exists
  self.ignore_existed_index = ignore_existed_index
  self.common = common

AddEdgesRequest.__init__ = AddEdgesRequest__init__

def AddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('ignore_existed_index', False)
  state.setdefault('common', None)
  self.__dict__ = state

AddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
AddEdgesRequest.__setstate__ = AddEdgesRequest__setstate__

all_structs.append(DeleteVerticesRequest)
DeleteVerticesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True])), None, 2, ), # 2
  (3, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 3
)

DeleteVerticesRequest.thrift_struct_annotations = {
}
DeleteVerticesRequest.thrift_field_annotations = {
}

def DeleteVerticesRequest__init__(self, space_id=None, parts=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.common = common

DeleteVerticesRequest.__init__ = DeleteVerticesRequest__init__

def DeleteVerticesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('common', None)
  self.__dict__ = state

DeleteVerticesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteVerticesRequest.__setstate__ = DeleteVerticesRequest__setstate__

all_structs.append(DeleteEdgesRequest)
DeleteEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
  (3, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 3
)

DeleteEdgesRequest.thrift_struct_annotations = {
}
DeleteEdgesRequest.thrift_field_annotations = {
}

def DeleteEdgesRequest__init__(self, space_id=None, parts=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.common = common

DeleteEdgesRequest.__init__ = DeleteEdgesRequest__init__

def DeleteEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('common', None)
  self.__dict__ = state

DeleteEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteEdgesRequest.__setstate__ = DeleteEdgesRequest__setstate__

all_structs.append(DelTags)
DelTags.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 1
  (2, TType.LIST, 'tags', (TType.I32,None), None, 2, ), # 2
)

DelTags.thrift_struct_annotations = {
}
DelTags.thrift_field_annotations = {
}

def DelTags__init__(self, id=None, tags=None,):
  self.id = id
  self.tags = tags

DelTags.__init__ = DelTags__init__

def DelTags__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('tags', None)
  self.__dict__ = state

DelTags.__getstate__ = lambda self: self.__dict__.copy()
DelTags.__setstate__ = DelTags__setstate__

all_structs.append(DeleteTagsRequest)
DeleteTagsRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[DelTags, DelTags.thrift_spec, False])), None, 2, ), # 2
  (3, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 3
)

DeleteTagsRequest.thrift_struct_annotations = {
}
DeleteTagsRequest.thrift_field_annotations = {
}

def DeleteTagsRequest__init__(self, space_id=None, parts=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.common = common

DeleteTagsRequest.__init__ = DeleteTagsRequest__init__

def DeleteTagsRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('common', None)
  self.__dict__ = state

DeleteTagsRequest.__getstate__ = lambda self: self.__dict__.copy()
DeleteTagsRequest.__setstate__ = DeleteTagsRequest__setstate__

all_structs.append(UpdateResponse)
UpdateResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'props', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
)

UpdateResponse.thrift_struct_annotations = {
}
UpdateResponse.thrift_field_annotations = {
}

def UpdateResponse__init__(self, result=None, props=None,):
  self.result = result
  self.props = props

UpdateResponse.__init__ = UpdateResponse__init__

def UpdateResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  self.__dict__ = state

UpdateResponse.__getstate__ = lambda self: self.__dict__.copy()
UpdateResponse.__setstate__ = UpdateResponse__setstate__

all_structs.append(UpdatedProp)
UpdatedProp.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRING, 'value', False, None, 0, ), # 2
)

UpdatedProp.thrift_struct_annotations = {
}
UpdatedProp.thrift_field_annotations = {
}

def UpdatedProp__init__(self, name=None, value=None,):
  self.name = name
  self.value = value

UpdatedProp.__init__ = UpdatedProp__init__

def UpdatedProp__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('value', None)
  self.__dict__ = state

UpdatedProp.__getstate__ = lambda self: self.__dict__.copy()
UpdatedProp.__setstate__ = UpdatedProp__setstate__

all_structs.append(UpdateVertexRequest)
UpdateVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'vertex_id', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.I32, 'tag_id', None, None, 0, ), # 4
  (5, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 5
  (6, TType.BOOL, 'insertable', None, False, 1, ), # 6
  (7, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 7
  (8, TType.STRING, 'condition', False, None, 1, ), # 8
  (9, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 9
)

UpdateVertexRequest.thrift_struct_annotations = {
}
UpdateVertexRequest.thrift_field_annotations = {
}

def UpdateVertexRequest__init__(self, space_id=None, part_id=None, vertex_id=None, tag_id=None, updated_props=None, insertable=UpdateVertexRequest.thrift_spec[6][4], return_props=None, condition=None, common=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.vertex_id = vertex_id
  self.tag_id = tag_id
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition
  self.common = common

UpdateVertexRequest.__init__ = UpdateVertexRequest__init__

def UpdateVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('vertex_id', None)
  state.setdefault('tag_id', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  state.setdefault('common', None)
  self.__dict__ = state

UpdateVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateVertexRequest.__setstate__ = UpdateVertexRequest__setstate__

all_structs.append(UpdateEdgeRequest)
UpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'edge_key', [EdgeKey, EdgeKey.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'updated_props', (TType.STRUCT,[UpdatedProp, UpdatedProp.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'insertable', None, False, 1, ), # 5
  (6, TType.LIST, 'return_props', (TType.STRING,False), None, 1, ), # 6
  (7, TType.STRING, 'condition', False, None, 1, ), # 7
  (8, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 8
)

UpdateEdgeRequest.thrift_struct_annotations = {
}
UpdateEdgeRequest.thrift_field_annotations = {
}

def UpdateEdgeRequest__init__(self, space_id=None, part_id=None, edge_key=None, updated_props=None, insertable=UpdateEdgeRequest.thrift_spec[5][4], return_props=None, condition=None, common=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.edge_key = edge_key
  self.updated_props = updated_props
  self.insertable = insertable
  self.return_props = return_props
  self.condition = condition
  self.common = common

UpdateEdgeRequest.__init__ = UpdateEdgeRequest__init__

def UpdateEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('edge_key', None)
  state.setdefault('updated_props', None)
  state.setdefault('insertable', False)
  state.setdefault('return_props', None)
  state.setdefault('condition', None)
  state.setdefault('common', None)
  self.__dict__ = state

UpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
UpdateEdgeRequest.__setstate__ = UpdateEdgeRequest__setstate__

all_structs.append(GetUUIDReq)
GetUUIDReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRING, 'name', False, None, 2, ), # 3
  (4, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 4
)

GetUUIDReq.thrift_struct_annotations = {
}
GetUUIDReq.thrift_field_annotations = {
}

def GetUUIDReq__init__(self, space_id=None, part_id=None, name=None, common=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.name = name
  self.common = common

GetUUIDReq.__init__ = GetUUIDReq__init__

def GetUUIDReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('name', None)
  state.setdefault('common', None)
  self.__dict__ = state

GetUUIDReq.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDReq.__setstate__ = GetUUIDReq__setstate__

all_structs.append(GetUUIDResp)
GetUUIDResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'id', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 2
)

GetUUIDResp.thrift_struct_annotations = {
}
GetUUIDResp.thrift_field_annotations = {
}

def GetUUIDResp__init__(self, result=None, id=None,):
  self.result = result
  self.id = id

GetUUIDResp.__init__ = GetUUIDResp__init__

def GetUUIDResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('id', None)
  self.__dict__ = state

GetUUIDResp.__getstate__ = lambda self: self.__dict__.copy()
GetUUIDResp.__setstate__ = GetUUIDResp__setstate__

all_structs.append(LookupIndexResp)
LookupIndexResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'data', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
  (3, TType.STRUCT, 'stat_data', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 3
)

LookupIndexResp.thrift_struct_annotations = {
}
LookupIndexResp.thrift_field_annotations = {
}

def LookupIndexResp__init__(self, result=None, data=None, stat_data=None,):
  self.result = result
  self.data = data
  self.stat_data = stat_data

LookupIndexResp.__init__ = LookupIndexResp__init__

def LookupIndexResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('data', None)
  state.setdefault('stat_data', None)
  self.__dict__ = state

LookupIndexResp.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexResp.__setstate__ = LookupIndexResp__setstate__

all_structs.append(IndexColumnHint)
IndexColumnHint.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'column_name', False, None, 2, ), # 1
  (2, TType.I32, 'scan_type', ScanType, None, 2, ), # 2
  (3, TType.STRUCT, 'begin_value', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 3
  (4, TType.STRUCT, 'end_value', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
  (5, TType.BOOL, 'include_begin', None, True, 2, ), # 5
  (6, TType.BOOL, 'include_end', None, False, 2, ), # 6
)

IndexColumnHint.thrift_struct_annotations = {
}
IndexColumnHint.thrift_field_annotations = {
}

def IndexColumnHint__init__(self, column_name=None, scan_type=None, begin_value=None, end_value=None, include_begin=IndexColumnHint.thrift_spec[5][4], include_end=IndexColumnHint.thrift_spec[6][4],):
  self.column_name = column_name
  self.scan_type = scan_type
  self.begin_value = begin_value
  self.end_value = end_value
  self.include_begin = include_begin
  self.include_end = include_end

IndexColumnHint.__init__ = IndexColumnHint__init__

def IndexColumnHint__setstate__(self, state):
  state.setdefault('column_name', None)
  state.setdefault('scan_type', None)
  state.setdefault('begin_value', None)
  state.setdefault('end_value', None)
  state.setdefault('include_begin', True)
  state.setdefault('include_end', False)
  self.__dict__ = state

IndexColumnHint.__getstate__ = lambda self: self.__dict__.copy()
IndexColumnHint.__setstate__ = IndexColumnHint__setstate__

all_structs.append(IndexQueryContext)
IndexQueryContext.thrift_spec = (
  None, # 0
  (1, TType.I32, 'index_id', None, None, 2, ), # 1
  (2, TType.STRING, 'filter', False, None, 2, ), # 2
  (3, TType.LIST, 'column_hints', (TType.STRUCT,[IndexColumnHint, IndexColumnHint.thrift_spec, False]), None, 2, ), # 3
)

IndexQueryContext.thrift_struct_annotations = {
}
IndexQueryContext.thrift_field_annotations = {
}

def IndexQueryContext__init__(self, index_id=None, filter=None, column_hints=None,):
  self.index_id = index_id
  self.filter = filter
  self.column_hints = column_hints

IndexQueryContext.__init__ = IndexQueryContext__init__

def IndexQueryContext__setstate__(self, state):
  state.setdefault('index_id', None)
  state.setdefault('filter', None)
  state.setdefault('column_hints', None)
  self.__dict__ = state

IndexQueryContext.__getstate__ = lambda self: self.__dict__.copy()
IndexQueryContext.__setstate__ = IndexQueryContext__setstate__

all_structs.append(IndexSpec)
IndexSpec.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'contexts', (TType.STRUCT,[IndexQueryContext, IndexQueryContext.thrift_spec, False]), None, 0, ), # 1
  (2, TType.STRUCT, 'schema_id', [nebula3.common.ttypes.SchemaID, nebula3.common.ttypes.SchemaID.thrift_spec, True], None, 2, ), # 2
)

IndexSpec.thrift_struct_annotations = {
}
IndexSpec.thrift_field_annotations = {
}

def IndexSpec__init__(self, contexts=None, schema_id=None,):
  self.contexts = contexts
  self.schema_id = schema_id

IndexSpec.__init__ = IndexSpec__init__

def IndexSpec__setstate__(self, state):
  state.setdefault('contexts', None)
  state.setdefault('schema_id', None)
  self.__dict__ = state

IndexSpec.__getstate__ = lambda self: self.__dict__.copy()
IndexSpec.__setstate__ = IndexSpec__setstate__

all_structs.append(LookupIndexRequest)
LookupIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.LIST, 'return_columns', (TType.STRING,False), None, 1, ), # 4
  (5, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 5
  (6, TType.I64, 'limit', None, None, 1, ), # 6
  (7, TType.LIST, 'order_by', (TType.STRUCT,[OrderBy, OrderBy.thrift_spec, False]), None, 1, ), # 7
  (8, TType.LIST, 'stat_columns', (TType.STRUCT,[StatProp, StatProp.thrift_spec, False]), None, 1, ), # 8
)

LookupIndexRequest.thrift_struct_annotations = {
}
LookupIndexRequest.thrift_field_annotations = {
}

def LookupIndexRequest__init__(self, space_id=None, parts=None, indices=None, return_columns=None, common=None, limit=None, order_by=None, stat_columns=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.return_columns = return_columns
  self.common = common
  self.limit = limit
  self.order_by = order_by
  self.stat_columns = stat_columns

LookupIndexRequest.__init__ = LookupIndexRequest__init__

def LookupIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('return_columns', None)
  state.setdefault('common', None)
  state.setdefault('limit', None)
  state.setdefault('order_by', None)
  state.setdefault('stat_columns', None)
  self.__dict__ = state

LookupIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupIndexRequest.__setstate__ = LookupIndexRequest__setstate__

all_structs.append(LookupAndTraverseRequest)
LookupAndTraverseRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 0, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 2
  (3, TType.STRUCT, 'indices', [IndexSpec, IndexSpec.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'traverse_spec', [TraverseSpec, TraverseSpec.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 5
)

LookupAndTraverseRequest.thrift_struct_annotations = {
}
LookupAndTraverseRequest.thrift_field_annotations = {
}

def LookupAndTraverseRequest__init__(self, space_id=None, parts=None, indices=None, traverse_spec=None, common=None,):
  self.space_id = space_id
  self.parts = parts
  self.indices = indices
  self.traverse_spec = traverse_spec
  self.common = common

LookupAndTraverseRequest.__init__ = LookupAndTraverseRequest__init__

def LookupAndTraverseRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('indices', None)
  state.setdefault('traverse_spec', None)
  state.setdefault('common', None)
  self.__dict__ = state

LookupAndTraverseRequest.__getstate__ = lambda self: self.__dict__.copy()
LookupAndTraverseRequest.__setstate__ = LookupAndTraverseRequest__setstate__

all_structs.append(ScanCursor)
ScanCursor.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'next_cursor', False, None, 1, ), # 1
)

ScanCursor.thrift_struct_annotations = {
}
ScanCursor.thrift_field_annotations = {
}

def ScanCursor__init__(self, next_cursor=None,):
  self.next_cursor = next_cursor

ScanCursor.__init__ = ScanCursor__init__

def ScanCursor__setstate__(self, state):
  state.setdefault('next_cursor', None)
  self.__dict__ = state

ScanCursor.__getstate__ = lambda self: self.__dict__.copy()
ScanCursor.__setstate__ = ScanCursor__setstate__

all_structs.append(ScanVertexRequest)
ScanVertexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRUCT,[ScanCursor, ScanCursor.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'return_columns', (TType.STRUCT,[VertexProp, VertexProp.thrift_spec, False]), None, 2, ), # 3
  (4, TType.I64, 'limit', None, None, 2, ), # 4
  (5, TType.I64, 'start_time', None, None, 1, ), # 5
  (6, TType.I64, 'end_time', None, None, 1, ), # 6
  (7, TType.STRING, 'filter', False, None, 1, ), # 7
  (8, TType.BOOL, 'only_latest_version', None, False, 2, ), # 8
  (9, TType.BOOL, 'enable_read_from_follower', None, True, 2, ), # 9
  (10, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 10
)

ScanVertexRequest.thrift_struct_annotations = {
}
ScanVertexRequest.thrift_field_annotations = {
}

def ScanVertexRequest__init__(self, space_id=None, parts=None, return_columns=None, limit=None, start_time=None, end_time=None, filter=None, only_latest_version=ScanVertexRequest.thrift_spec[8][4], enable_read_from_follower=ScanVertexRequest.thrift_spec[9][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_columns = return_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time
  self.filter = filter
  self.only_latest_version = only_latest_version
  self.enable_read_from_follower = enable_read_from_follower
  self.common = common

ScanVertexRequest.__init__ = ScanVertexRequest__init__

def ScanVertexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  state.setdefault('filter', None)
  state.setdefault('only_latest_version', False)
  state.setdefault('enable_read_from_follower', True)
  state.setdefault('common', None)
  self.__dict__ = state

ScanVertexRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanVertexRequest.__setstate__ = ScanVertexRequest__setstate__

all_structs.append(ScanEdgeRequest)
ScanEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.STRUCT,[ScanCursor, ScanCursor.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'return_columns', (TType.STRUCT,[EdgeProp, EdgeProp.thrift_spec, False]), None, 2, ), # 3
  (4, TType.I64, 'limit', None, None, 2, ), # 4
  (5, TType.I64, 'start_time', None, None, 1, ), # 5
  (6, TType.I64, 'end_time', None, None, 1, ), # 6
  (7, TType.STRING, 'filter', False, None, 1, ), # 7
  (8, TType.BOOL, 'only_latest_version', None, False, 2, ), # 8
  (9, TType.BOOL, 'enable_read_from_follower', None, True, 2, ), # 9
  (10, TType.STRUCT, 'common', [RequestCommon, RequestCommon.thrift_spec, False], None, 1, ), # 10
)

ScanEdgeRequest.thrift_struct_annotations = {
}
ScanEdgeRequest.thrift_field_annotations = {
}

def ScanEdgeRequest__init__(self, space_id=None, parts=None, return_columns=None, limit=None, start_time=None, end_time=None, filter=None, only_latest_version=ScanEdgeRequest.thrift_spec[8][4], enable_read_from_follower=ScanEdgeRequest.thrift_spec[9][4], common=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_columns = return_columns
  self.limit = limit
  self.start_time = start_time
  self.end_time = end_time
  self.filter = filter
  self.only_latest_version = only_latest_version
  self.enable_read_from_follower = enable_read_from_follower
  self.common = common

ScanEdgeRequest.__init__ = ScanEdgeRequest__init__

def ScanEdgeRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_columns', None)
  state.setdefault('limit', None)
  state.setdefault('start_time', None)
  state.setdefault('end_time', None)
  state.setdefault('filter', None)
  state.setdefault('only_latest_version', False)
  state.setdefault('enable_read_from_follower', True)
  state.setdefault('common', None)
  self.__dict__ = state

ScanEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
ScanEdgeRequest.__setstate__ = ScanEdgeRequest__setstate__

all_structs.append(ScanResponse)
ScanResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'props', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 2
  (3, TType.MAP, 'cursors', (TType.I32,None,TType.STRUCT,[ScanCursor, ScanCursor.thrift_spec, False]), None, 2, ), # 3
)

ScanResponse.thrift_struct_annotations = {
}
ScanResponse.thrift_field_annotations = {
}

def ScanResponse__init__(self, result=None, props=None, cursors=None,):
  self.result = result
  self.props = props
  self.cursors = cursors

ScanResponse.__init__ = ScanResponse__init__

def ScanResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('props', None)
  state.setdefault('cursors', None)
  self.__dict__ = state

ScanResponse.__getstate__ = lambda self: self.__dict__.copy()
ScanResponse.__setstate__ = ScanResponse__setstate__

all_structs.append(TaskPara)
TaskPara.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 1, ), # 2
  (3, TType.LIST, 'task_specific_paras', (TType.STRING,False), None, 1, ), # 3
)

TaskPara.thrift_struct_annotations = {
}
TaskPara.thrift_field_annotations = {
}

def TaskPara__init__(self, space_id=None, parts=None, task_specific_paras=None,):
  self.space_id = space_id
  self.parts = parts
  self.task_specific_paras = task_specific_paras

TaskPara.__init__ = TaskPara__init__

def TaskPara__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('task_specific_paras', None)
  self.__dict__ = state

TaskPara.__getstate__ = lambda self: self.__dict__.copy()
TaskPara.__setstate__ = TaskPara__setstate__

all_structs.append(KVGetRequest)
KVGetRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
  (3, TType.BOOL, 'return_partly', None, None, 2, ), # 3
)

KVGetRequest.thrift_struct_annotations = {
}
KVGetRequest.thrift_field_annotations = {
}

def KVGetRequest__init__(self, space_id=None, parts=None, return_partly=None,):
  self.space_id = space_id
  self.parts = parts
  self.return_partly = return_partly

KVGetRequest.__init__ = KVGetRequest__init__

def KVGetRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('return_partly', None)
  self.__dict__ = state

KVGetRequest.__getstate__ = lambda self: self.__dict__.copy()
KVGetRequest.__setstate__ = KVGetRequest__setstate__

all_structs.append(KVGetResponse)
KVGetResponse.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.MAP, 'key_values', (TType.STRING,False,TType.STRING,False), None, 2, ), # 2
)

KVGetResponse.thrift_struct_annotations = {
}
KVGetResponse.thrift_field_annotations = {
}

def KVGetResponse__init__(self, result=None, key_values=None,):
  self.result = result
  self.key_values = key_values

KVGetResponse.__init__ = KVGetResponse__init__

def KVGetResponse__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('key_values', None)
  self.__dict__ = state

KVGetResponse.__getstate__ = lambda self: self.__dict__.copy()
KVGetResponse.__setstate__ = KVGetResponse__setstate__

all_structs.append(KVPutRequest)
KVPutRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.KeyValue, nebula3.common.ttypes.KeyValue.thrift_spec, False])), None, 2, ), # 2
)

KVPutRequest.thrift_struct_annotations = {
}
KVPutRequest.thrift_field_annotations = {
}

def KVPutRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVPutRequest.__init__ = KVPutRequest__init__

def KVPutRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVPutRequest.__getstate__ = lambda self: self.__dict__.copy()
KVPutRequest.__setstate__ = KVPutRequest__setstate__

all_structs.append(KVRemoveRequest)
KVRemoveRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRING,False)), None, 2, ), # 2
)

KVRemoveRequest.thrift_struct_annotations = {
}
KVRemoveRequest.thrift_field_annotations = {
}

def KVRemoveRequest__init__(self, space_id=None, parts=None,):
  self.space_id = space_id
  self.parts = parts

KVRemoveRequest.__init__ = KVRemoveRequest__init__

def KVRemoveRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

KVRemoveRequest.__getstate__ = lambda self: self.__dict__.copy()
KVRemoveRequest.__setstate__ = KVRemoveRequest__setstate__

all_structs.append(AdminExecResp)
AdminExecResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'stats', [nebula3.meta.ttypes.StatsItem, nebula3.meta.ttypes.StatsItem.thrift_spec, False], None, 1, ), # 2
)

AdminExecResp.thrift_struct_annotations = {
}
AdminExecResp.thrift_field_annotations = {
}

def AdminExecResp__init__(self, result=None, stats=None,):
  self.result = result
  self.stats = stats

AdminExecResp.__init__ = AdminExecResp__init__

def AdminExecResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('stats', None)
  self.__dict__ = state

AdminExecResp.__getstate__ = lambda self: self.__dict__.copy()
AdminExecResp.__setstate__ = AdminExecResp__setstate__

all_structs.append(TransLeaderReq)
TransLeaderReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'new_leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

TransLeaderReq.thrift_struct_annotations = {
}
TransLeaderReq.thrift_field_annotations = {
}

def TransLeaderReq__init__(self, space_id=None, part_id=None, new_leader=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.new_leader = new_leader

TransLeaderReq.__init__ = TransLeaderReq__init__

def TransLeaderReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('new_leader', None)
  self.__dict__ = state

TransLeaderReq.__getstate__ = lambda self: self.__dict__.copy()
TransLeaderReq.__setstate__ = TransLeaderReq__setstate__

all_structs.append(AddPartReq)
AddPartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.BOOL, 'as_learner', None, None, 2, ), # 3
  (4, TType.LIST, 'peers', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 4
)

AddPartReq.thrift_struct_annotations = {
}
AddPartReq.thrift_field_annotations = {
}

def AddPartReq__init__(self, space_id=None, part_id=None, as_learner=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.as_learner = as_learner
  self.peers = peers

AddPartReq.__init__ = AddPartReq__init__

def AddPartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('as_learner', None)
  state.setdefault('peers', None)
  self.__dict__ = state

AddPartReq.__getstate__ = lambda self: self.__dict__.copy()
AddPartReq.__setstate__ = AddPartReq__setstate__

all_structs.append(AddLearnerReq)
AddLearnerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'learner', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

AddLearnerReq.thrift_struct_annotations = {
}
AddLearnerReq.thrift_field_annotations = {
}

def AddLearnerReq__init__(self, space_id=None, part_id=None, learner=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.learner = learner

AddLearnerReq.__init__ = AddLearnerReq__init__

def AddLearnerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('learner', None)
  self.__dict__ = state

AddLearnerReq.__getstate__ = lambda self: self.__dict__.copy()
AddLearnerReq.__setstate__ = AddLearnerReq__setstate__

all_structs.append(RemovePartReq)
RemovePartReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
)

RemovePartReq.thrift_struct_annotations = {
}
RemovePartReq.thrift_field_annotations = {
}

def RemovePartReq__init__(self, space_id=None, part_id=None,):
  self.space_id = space_id
  self.part_id = part_id

RemovePartReq.__init__ = RemovePartReq__init__

def RemovePartReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  self.__dict__ = state

RemovePartReq.__getstate__ = lambda self: self.__dict__.copy()
RemovePartReq.__setstate__ = RemovePartReq__setstate__

all_structs.append(MemberChangeReq)
MemberChangeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'peer', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'add', None, None, 2, ), # 4
)

MemberChangeReq.thrift_struct_annotations = {
}
MemberChangeReq.thrift_field_annotations = {
}

def MemberChangeReq__init__(self, space_id=None, part_id=None, peer=None, add=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peer = peer
  self.add = add

MemberChangeReq.__init__ = MemberChangeReq__init__

def MemberChangeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peer', None)
  state.setdefault('add', None)
  self.__dict__ = state

MemberChangeReq.__getstate__ = lambda self: self.__dict__.copy()
MemberChangeReq.__setstate__ = MemberChangeReq__setstate__

all_structs.append(CatchUpDataReq)
CatchUpDataReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.STRUCT, 'target', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

CatchUpDataReq.thrift_struct_annotations = {
}
CatchUpDataReq.thrift_field_annotations = {
}

def CatchUpDataReq__init__(self, space_id=None, part_id=None, target=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.target = target

CatchUpDataReq.__init__ = CatchUpDataReq__init__

def CatchUpDataReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('target', None)
  self.__dict__ = state

CatchUpDataReq.__getstate__ = lambda self: self.__dict__.copy()
CatchUpDataReq.__setstate__ = CatchUpDataReq__setstate__

all_structs.append(GetLeaderReq)
GetLeaderReq.thrift_spec = (
)

GetLeaderReq.thrift_struct_annotations = {
}
GetLeaderReq.thrift_field_annotations = {
}

all_structs.append(CreateCPRequest)
CreateCPRequest.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'space_ids', (TType.I32,None), None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

CreateCPRequest.thrift_struct_annotations = {
}
CreateCPRequest.thrift_field_annotations = {
}

def CreateCPRequest__init__(self, space_ids=None, name=None,):
  self.space_ids = space_ids
  self.name = name

CreateCPRequest.__init__ = CreateCPRequest__init__

def CreateCPRequest__setstate__(self, state):
  state.setdefault('space_ids', None)
  state.setdefault('name', None)
  self.__dict__ = state

CreateCPRequest.__getstate__ = lambda self: self.__dict__.copy()
CreateCPRequest.__setstate__ = CreateCPRequest__setstate__

all_structs.append(CreateCPResp)
CreateCPResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.LIST, 'info', (TType.STRUCT,[nebula3.common.ttypes.CheckpointInfo, nebula3.common.ttypes.CheckpointInfo.thrift_spec, False]), None, 2, ), # 2
)

CreateCPResp.thrift_struct_annotations = {
}
CreateCPResp.thrift_field_annotations = {
}

def CreateCPResp__init__(self, code=None, info=None,):
  self.code = code
  self.info = info

CreateCPResp.__init__ = CreateCPResp__init__

def CreateCPResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('info', None)
  self.__dict__ = state

CreateCPResp.__getstate__ = lambda self: self.__dict__.copy()
CreateCPResp.__setstate__ = CreateCPResp__setstate__

all_structs.append(DropCPRequest)
DropCPRequest.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'space_ids', (TType.I32,None), None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

DropCPRequest.thrift_struct_annotations = {
}
DropCPRequest.thrift_field_annotations = {
}

def DropCPRequest__init__(self, space_ids=None, name=None,):
  self.space_ids = space_ids
  self.name = name

DropCPRequest.__init__ = DropCPRequest__init__

def DropCPRequest__setstate__(self, state):
  state.setdefault('space_ids', None)
  state.setdefault('name', None)
  self.__dict__ = state

DropCPRequest.__getstate__ = lambda self: self.__dict__.copy()
DropCPRequest.__setstate__ = DropCPRequest__setstate__

all_structs.append(DropCPResp)
DropCPResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
)

DropCPResp.thrift_struct_annotations = {
}
DropCPResp.thrift_field_annotations = {
}

def DropCPResp__init__(self, code=None,):
  self.code = code

DropCPResp.__init__ = DropCPResp__init__

def DropCPResp__setstate__(self, state):
  state.setdefault('code', None)
  self.__dict__ = state

DropCPResp.__getstate__ = lambda self: self.__dict__.copy()
DropCPResp.__setstate__ = DropCPResp__setstate__

all_structs.append(BlockingSignRequest)
BlockingSignRequest.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'space_ids', (TType.I32,None), None, 2, ), # 1
  (2, TType.I32, 'sign', EngineSignType, None, 0, ), # 2
)

BlockingSignRequest.thrift_struct_annotations = {
}
BlockingSignRequest.thrift_field_annotations = {
}

def BlockingSignRequest__init__(self, space_ids=None, sign=None,):
  self.space_ids = space_ids
  self.sign = sign

BlockingSignRequest.__init__ = BlockingSignRequest__init__

def BlockingSignRequest__setstate__(self, state):
  state.setdefault('space_ids', None)
  state.setdefault('sign', None)
  self.__dict__ = state

BlockingSignRequest.__getstate__ = lambda self: self.__dict__.copy()
BlockingSignRequest.__setstate__ = BlockingSignRequest__setstate__

all_structs.append(BlockingSignResp)
BlockingSignResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
)

BlockingSignResp.thrift_struct_annotations = {
}
BlockingSignResp.thrift_field_annotations = {
}

def BlockingSignResp__init__(self, code=None,):
  self.code = code

BlockingSignResp.__init__ = BlockingSignResp__init__

def BlockingSignResp__setstate__(self, state):
  state.setdefault('code', None)
  self.__dict__ = state

BlockingSignResp.__getstate__ = lambda self: self.__dict__.copy()
BlockingSignResp.__setstate__ = BlockingSignResp__setstate__

all_structs.append(GetLeaderPartsResp)
GetLeaderPartsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.MAP, 'leader_parts', (TType.I32,None,TType.LIST,(TType.I32,None)), None, 2, ), # 2
)

GetLeaderPartsResp.thrift_struct_annotations = {
}
GetLeaderPartsResp.thrift_field_annotations = {
}

def GetLeaderPartsResp__init__(self, code=None, leader_parts=None,):
  self.code = code
  self.leader_parts = leader_parts

GetLeaderPartsResp.__init__ = GetLeaderPartsResp__init__

def GetLeaderPartsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader_parts', None)
  self.__dict__ = state

GetLeaderPartsResp.__getstate__ = lambda self: self.__dict__.copy()
GetLeaderPartsResp.__setstate__ = GetLeaderPartsResp__setstate__

all_structs.append(CheckPeersReq)
CheckPeersReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'part_id', None, None, 2, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

CheckPeersReq.thrift_struct_annotations = {
}
CheckPeersReq.thrift_field_annotations = {
}

def CheckPeersReq__init__(self, space_id=None, part_id=None, peers=None,):
  self.space_id = space_id
  self.part_id = part_id
  self.peers = peers

CheckPeersReq.__init__ = CheckPeersReq__init__

def CheckPeersReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_id', None)
  state.setdefault('peers', None)
  self.__dict__ = state

CheckPeersReq.__getstate__ = lambda self: self.__dict__.copy()
CheckPeersReq.__setstate__ = CheckPeersReq__setstate__

all_structs.append(RebuildIndexRequest)
RebuildIndexRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'parts', (TType.I32,None), None, 2, ), # 2
  (3, TType.I32, 'index_id', None, None, 2, ), # 3
)

RebuildIndexRequest.thrift_struct_annotations = {
}
RebuildIndexRequest.thrift_field_annotations = {
}

def RebuildIndexRequest__init__(self, space_id=None, parts=None, index_id=None,):
  self.space_id = space_id
  self.parts = parts
  self.index_id = index_id

RebuildIndexRequest.__init__ = RebuildIndexRequest__init__

def RebuildIndexRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('index_id', None)
  self.__dict__ = state

RebuildIndexRequest.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexRequest.__setstate__ = RebuildIndexRequest__setstate__

all_structs.append(ListClusterInfoResp)
ListClusterInfoResp.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'result', [ResponseCommon, ResponseCommon.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRUCT, 'dir', [nebula3.common.ttypes.DirInfo, nebula3.common.ttypes.DirInfo.thrift_spec, False], None, 2, ), # 2
)

ListClusterInfoResp.thrift_struct_annotations = {
}
ListClusterInfoResp.thrift_field_annotations = {
}

def ListClusterInfoResp__init__(self, result=None, dir=None,):
  self.result = result
  self.dir = dir

ListClusterInfoResp.__init__ = ListClusterInfoResp__init__

def ListClusterInfoResp__setstate__(self, state):
  state.setdefault('result', None)
  state.setdefault('dir', None)
  self.__dict__ = state

ListClusterInfoResp.__getstate__ = lambda self: self.__dict__.copy()
ListClusterInfoResp.__setstate__ = ListClusterInfoResp__setstate__

all_structs.append(ListClusterInfoReq)
ListClusterInfoReq.thrift_spec = (
)

ListClusterInfoReq.thrift_struct_annotations = {
}
ListClusterInfoReq.thrift_field_annotations = {
}

all_structs.append(AddTaskRequest)
AddTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_type', nebula3.meta.ttypes.JobType, None, 2, ), # 1
  (2, TType.I32, 'job_id', None, None, 2, ), # 2
  (3, TType.I32, 'task_id', None, None, 2, ), # 3
  (4, TType.STRUCT, 'para', [TaskPara, TaskPara.thrift_spec, False], None, 2, ), # 4
)

AddTaskRequest.thrift_struct_annotations = {
}
AddTaskRequest.thrift_field_annotations = {
}

def AddTaskRequest__init__(self, job_type=None, job_id=None, task_id=None, para=None,):
  self.job_type = job_type
  self.job_id = job_id
  self.task_id = task_id
  self.para = para

AddTaskRequest.__init__ = AddTaskRequest__init__

def AddTaskRequest__setstate__(self, state):
  state.setdefault('job_type', None)
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  state.setdefault('para', None)
  self.__dict__ = state

AddTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
AddTaskRequest.__setstate__ = AddTaskRequest__setstate__

all_structs.append(AddTaskResp)
AddTaskResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
)

AddTaskResp.thrift_struct_annotations = {
}
AddTaskResp.thrift_field_annotations = {
}

def AddTaskResp__init__(self, code=None,):
  self.code = code

AddTaskResp.__init__ = AddTaskResp__init__

def AddTaskResp__setstate__(self, state):
  state.setdefault('code', None)
  self.__dict__ = state

AddTaskResp.__getstate__ = lambda self: self.__dict__.copy()
AddTaskResp.__setstate__ = AddTaskResp__setstate__

all_structs.append(StopTaskRequest)
StopTaskRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_id', None, None, 2, ), # 1
  (2, TType.I32, 'task_id', None, None, 2, ), # 2
)

StopTaskRequest.thrift_struct_annotations = {
}
StopTaskRequest.thrift_field_annotations = {
}

def StopTaskRequest__init__(self, job_id=None, task_id=None,):
  self.job_id = job_id
  self.task_id = task_id

StopTaskRequest.__init__ = StopTaskRequest__init__

def StopTaskRequest__setstate__(self, state):
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  self.__dict__ = state

StopTaskRequest.__getstate__ = lambda self: self.__dict__.copy()
StopTaskRequest.__setstate__ = StopTaskRequest__setstate__

all_structs.append(StopTaskResp)
StopTaskResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
)

StopTaskResp.thrift_struct_annotations = {
}
StopTaskResp.thrift_field_annotations = {
}

def StopTaskResp__init__(self, code=None,):
  self.code = code

StopTaskResp.__init__ = StopTaskResp__init__

def StopTaskResp__setstate__(self, state):
  state.setdefault('code', None)
  self.__dict__ = state

StopTaskResp.__getstate__ = lambda self: self.__dict__.copy()
StopTaskResp.__setstate__ = StopTaskResp__setstate__

all_structs.append(ClearSpaceReq)
ClearSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ClearSpaceReq.thrift_struct_annotations = {
}
ClearSpaceReq.thrift_field_annotations = {
}

def ClearSpaceReq__init__(self, space_id=None,):
  self.space_id = space_id

ClearSpaceReq.__init__ = ClearSpaceReq__init__

def ClearSpaceReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ClearSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
ClearSpaceReq.__setstate__ = ClearSpaceReq__setstate__

all_structs.append(ClearSpaceResp)
ClearSpaceResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
)

ClearSpaceResp.thrift_struct_annotations = {
}
ClearSpaceResp.thrift_field_annotations = {
}

def ClearSpaceResp__init__(self, code=None,):
  self.code = code

ClearSpaceResp.__init__ = ClearSpaceResp__init__

def ClearSpaceResp__setstate__(self, state):
  state.setdefault('code', None)
  self.__dict__ = state

ClearSpaceResp.__getstate__ = lambda self: self.__dict__.copy()
ClearSpaceResp.__setstate__ = ClearSpaceResp__setstate__

all_structs.append(ChainAddEdgesRequest)
ChainAddEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[NewEdge, NewEdge.thrift_spec, False])), None, 2, ), # 2
  (3, TType.LIST, 'prop_names', (TType.STRING,False), None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
  (5, TType.I64, 'term', None, None, 2, ), # 5
  (6, TType.I64, 'edge_version', None, None, 1, ), # 6
)

ChainAddEdgesRequest.thrift_struct_annotations = {
}
ChainAddEdgesRequest.thrift_field_annotations = {
}

def ChainAddEdgesRequest__init__(self, space_id=None, parts=None, prop_names=None, if_not_exists=None, term=None, edge_version=None,):
  self.space_id = space_id
  self.parts = parts
  self.prop_names = prop_names
  self.if_not_exists = if_not_exists
  self.term = term
  self.edge_version = edge_version

ChainAddEdgesRequest.__init__ = ChainAddEdgesRequest__init__

def ChainAddEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('prop_names', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('term', None)
  state.setdefault('edge_version', None)
  self.__dict__ = state

ChainAddEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
ChainAddEdgesRequest.__setstate__ = ChainAddEdgesRequest__setstate__

all_structs.append(ChainUpdateEdgeRequest)
ChainUpdateEdgeRequest.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'update_edge_request', [UpdateEdgeRequest, UpdateEdgeRequest.thrift_spec, False], None, 2, ), # 1
  (2, TType.I64, 'term', None, None, 2, ), # 2
  (3, TType.I64, 'edge_version', None, None, 1, ), # 3
  (4, TType.I32, 'space_id', None, None, 2, ), # 4
  (5, TType.LIST, 'parts', (TType.I32,None), None, 0, ), # 5
)

ChainUpdateEdgeRequest.thrift_struct_annotations = {
}
ChainUpdateEdgeRequest.thrift_field_annotations = {
}

def ChainUpdateEdgeRequest__init__(self, update_edge_request=None, term=None, edge_version=None, space_id=None, parts=None,):
  self.update_edge_request = update_edge_request
  self.term = term
  self.edge_version = edge_version
  self.space_id = space_id
  self.parts = parts

ChainUpdateEdgeRequest.__init__ = ChainUpdateEdgeRequest__init__

def ChainUpdateEdgeRequest__setstate__(self, state):
  state.setdefault('update_edge_request', None)
  state.setdefault('term', None)
  state.setdefault('edge_version', None)
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  self.__dict__ = state

ChainUpdateEdgeRequest.__getstate__ = lambda self: self.__dict__.copy()
ChainUpdateEdgeRequest.__setstate__ = ChainUpdateEdgeRequest__setstate__

all_structs.append(ChainDeleteEdgesRequest)
ChainDeleteEdgesRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[EdgeKey, EdgeKey.thrift_spec, False])), None, 2, ), # 2
  (3, TType.STRING, 'txn_id', False, None, 2, ), # 3
  (4, TType.I64, 'term', None, None, 2, ), # 4
)

ChainDeleteEdgesRequest.thrift_struct_annotations = {
}
ChainDeleteEdgesRequest.thrift_field_annotations = {
}

def ChainDeleteEdgesRequest__init__(self, space_id=None, parts=None, txn_id=None, term=None,):
  self.space_id = space_id
  self.parts = parts
  self.txn_id = txn_id
  self.term = term

ChainDeleteEdgesRequest.__init__ = ChainDeleteEdgesRequest__init__

def ChainDeleteEdgesRequest__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('parts', None)
  state.setdefault('txn_id', None)
  state.setdefault('term', None)
  self.__dict__ = state

ChainDeleteEdgesRequest.__getstate__ = lambda self: self.__dict__.copy()
ChainDeleteEdgesRequest.__setstate__ = ChainDeleteEdgesRequest__setstate__

fix_spec(all_structs)
del all_structs
