#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from nebula3.fbthrift.util.Recursive import fix_spec
from nebula3.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula3.fbthrift.protocol.TProtocol import TProtocolException


from .ttypes import UTF8STRINGS, ProfilingStats, PlanNodeBranchInfo, Pair, PlanNodeDescription, PlanDescription, ExecutionResponse, AuthResponse, VerifyClientVersionResp, VerifyClientVersionReq
import nebula3.common.ttypes

from nebula3.fbthrift.Thrift import TProcessor
import pprint
import warnings
from nebula3.fbthrift import Thrift
from nebula3.fbthrift.transport import TTransport
from nebula3.fbthrift.protocol import TBinaryProtocol
from nebula3.fbthrift.protocol import TCompactProtocol
from nebula3.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula3.fbthrift.protocol import fastproto
except ImportError:
  pass

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

from nebula3.fbthrift.util.Decorators import (
  future_process_main,
  future_process_method,
  process_main as thrift_process_main,
  process_method as thrift_process_method,
  should_run_on_thread,
  write_results_after_future,
)

class Iface:
  def authenticate(self, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    pass

  def signout(self, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    pass

  def execute(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def executeWithParameter(self, sessionId=None, stmt=None, parameterMap=None):
    """
    Parameters:
     - sessionId
     - stmt
     - parameterMap
    """
    pass

  def executeJson(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def executeJsonWithParameter(self, sessionId=None, stmt=None, parameterMap=None):
    """
    Parameters:
     - sessionId
     - stmt
     - parameterMap
    """
    pass

  def verifyClientVersion(self, req=None):
    """
    Parameters:
     - req
    """
    pass


class ContextIface:
  def authenticate(self, handler_ctx, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    pass

  def signout(self, handler_ctx, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    pass

  def execute(self, handler_ctx, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def executeWithParameter(self, handler_ctx, sessionId=None, stmt=None, parameterMap=None):
    """
    Parameters:
     - sessionId
     - stmt
     - parameterMap
    """
    pass

  def executeJson(self, handler_ctx, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass

  def executeJsonWithParameter(self, handler_ctx, sessionId=None, stmt=None, parameterMap=None):
    """
    Parameters:
     - sessionId
     - stmt
     - parameterMap
    """
    pass

  def verifyClientVersion(self, handler_ctx, req=None):
    """
    Parameters:
     - req
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class authenticate_args:
  """
  Attributes:
   - username
   - password
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('authenticate_args')
    if self.username != None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password != None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.username is not None:
      value = pprint.pformat(self.username, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    username=%s' % (value))
    if self.password is not None:
      value = pprint.pformat(self.password, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    password=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(authenticate_args)
authenticate_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'username', False, None, 2, ), # 1
  (2, TType.STRING, 'password', False, None, 2, ), # 2
)

authenticate_args.thrift_struct_annotations = {
}
authenticate_args.thrift_field_annotations = {
}

def authenticate_args__init__(self, username=None, password=None,):
  self.username = username
  self.password = password

authenticate_args.__init__ = authenticate_args__init__

def authenticate_args__setstate__(self, state):
  state.setdefault('username', None)
  state.setdefault('password', None)
  self.__dict__ = state

authenticate_args.__getstate__ = lambda self: self.__dict__.copy()
authenticate_args.__setstate__ = authenticate_args__setstate__

class authenticate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('authenticate_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(authenticate_result)
authenticate_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [AuthResponse, AuthResponse.thrift_spec, False], None, 2, ), # 0
)

authenticate_result.thrift_struct_annotations = {
}
authenticate_result.thrift_field_annotations = {
}

def authenticate_result__init__(self, success=None,):
  self.success = success

authenticate_result.__init__ = authenticate_result__init__

def authenticate_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

authenticate_result.__getstate__ = lambda self: self.__dict__.copy()
authenticate_result.__setstate__ = authenticate_result__setstate__

class signout_args:
  """
  Attributes:
   - sessionId
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('signout_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(signout_args)
signout_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
)

signout_args.thrift_struct_annotations = {
}
signout_args.thrift_field_annotations = {
}

def signout_args__init__(self, sessionId=None,):
  self.sessionId = sessionId

signout_args.__init__ = signout_args__init__

def signout_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  self.__dict__ = state

signout_args.__getstate__ = lambda self: self.__dict__.copy()
signout_args.__setstate__ = signout_args__setstate__

class execute_args:
  """
  Attributes:
   - sessionId
   - stmt
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('execute_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(execute_args)
execute_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', False, None, 2, ), # 2
)

execute_args.thrift_struct_annotations = {
}
execute_args.thrift_field_annotations = {
}

def execute_args__init__(self, sessionId=None, stmt=None,):
  self.sessionId = sessionId
  self.stmt = stmt

execute_args.__init__ = execute_args__init__

def execute_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  self.__dict__ = state

execute_args.__getstate__ = lambda self: self.__dict__.copy()
execute_args.__setstate__ = execute_args__setstate__

class execute_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExecutionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('execute_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(execute_result)
execute_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExecutionResponse, ExecutionResponse.thrift_spec, False], None, 2, ), # 0
)

execute_result.thrift_struct_annotations = {
}
execute_result.thrift_field_annotations = {
}

def execute_result__init__(self, success=None,):
  self.success = success

execute_result.__init__ = execute_result__init__

def execute_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

execute_result.__getstate__ = lambda self: self.__dict__.copy()
execute_result.__setstate__ = execute_result__setstate__

class executeWithParameter_args:
  """
  Attributes:
   - sessionId
   - stmt
   - parameterMap
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameterMap = {}
          (_ktype55, _vtype56, _size54 ) = iprot.readMapBegin() 
          if _size54 >= 0:
            for _i58 in range(_size54):
              _key59 = iprot.readString()
              _val60 = nebula3.common.ttypes.Value()
              _val60.read(iprot)
              self.parameterMap[_key59] = _val60
          else: 
            while iprot.peekMap():
              _key61 = iprot.readString()
              _val62 = nebula3.common.ttypes.Value()
              _val62.read(iprot)
              self.parameterMap[_key61] = _val62
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeWithParameter_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.parameterMap != None:
      oprot.writeFieldBegin('parameterMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.parameterMap))
      for kiter63,viter64 in self.parameterMap.items():
        oprot.writeString(kiter63)
        viter64.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    if self.parameterMap is not None:
      value = pprint.pformat(self.parameterMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parameterMap=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(executeWithParameter_args)
executeWithParameter_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', False, None, 2, ), # 2
  (3, TType.MAP, 'parameterMap', (TType.STRING,False,TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 3
)

executeWithParameter_args.thrift_struct_annotations = {
}
executeWithParameter_args.thrift_field_annotations = {
}

def executeWithParameter_args__init__(self, sessionId=None, stmt=None, parameterMap=None,):
  self.sessionId = sessionId
  self.stmt = stmt
  self.parameterMap = parameterMap

executeWithParameter_args.__init__ = executeWithParameter_args__init__

def executeWithParameter_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  state.setdefault('parameterMap', None)
  self.__dict__ = state

executeWithParameter_args.__getstate__ = lambda self: self.__dict__.copy()
executeWithParameter_args.__setstate__ = executeWithParameter_args__setstate__

class executeWithParameter_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExecutionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeWithParameter_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(executeWithParameter_result)
executeWithParameter_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExecutionResponse, ExecutionResponse.thrift_spec, False], None, 2, ), # 0
)

executeWithParameter_result.thrift_struct_annotations = {
}
executeWithParameter_result.thrift_field_annotations = {
}

def executeWithParameter_result__init__(self, success=None,):
  self.success = success

executeWithParameter_result.__init__ = executeWithParameter_result__init__

def executeWithParameter_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

executeWithParameter_result.__getstate__ = lambda self: self.__dict__.copy()
executeWithParameter_result.__setstate__ = executeWithParameter_result__setstate__

class executeJson_args:
  """
  Attributes:
   - sessionId
   - stmt
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeJson_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(executeJson_args)
executeJson_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', False, None, 2, ), # 2
)

executeJson_args.thrift_struct_annotations = {
}
executeJson_args.thrift_field_annotations = {
}

def executeJson_args__init__(self, sessionId=None, stmt=None,):
  self.sessionId = sessionId
  self.stmt = stmt

executeJson_args.__init__ = executeJson_args__init__

def executeJson_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  self.__dict__ = state

executeJson_args.__getstate__ = lambda self: self.__dict__.copy()
executeJson_args.__setstate__ = executeJson_args__setstate__

class executeJson_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeJson_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(executeJson_result)
executeJson_result.thrift_spec = (
  (0, TType.STRING, 'success', False, None, 2, ), # 0
)

executeJson_result.thrift_struct_annotations = {
}
executeJson_result.thrift_field_annotations = {
}

def executeJson_result__init__(self, success=None,):
  self.success = success

executeJson_result.__init__ = executeJson_result__init__

def executeJson_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

executeJson_result.__getstate__ = lambda self: self.__dict__.copy()
executeJson_result.__setstate__ = executeJson_result__setstate__

class executeJsonWithParameter_args:
  """
  Attributes:
   - sessionId
   - stmt
   - parameterMap
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameterMap = {}
          (_ktype66, _vtype67, _size65 ) = iprot.readMapBegin() 
          if _size65 >= 0:
            for _i69 in range(_size65):
              _key70 = iprot.readString()
              _val71 = nebula3.common.ttypes.Value()
              _val71.read(iprot)
              self.parameterMap[_key70] = _val71
          else: 
            while iprot.peekMap():
              _key72 = iprot.readString()
              _val73 = nebula3.common.ttypes.Value()
              _val73.read(iprot)
              self.parameterMap[_key72] = _val73
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeJsonWithParameter_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    if self.parameterMap != None:
      oprot.writeFieldBegin('parameterMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.parameterMap))
      for kiter74,viter75 in self.parameterMap.items():
        oprot.writeString(kiter74)
        viter75.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    if self.parameterMap is not None:
      value = pprint.pformat(self.parameterMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parameterMap=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(executeJsonWithParameter_args)
executeJsonWithParameter_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', False, None, 2, ), # 2
  (3, TType.MAP, 'parameterMap', (TType.STRING,False,TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 3
)

executeJsonWithParameter_args.thrift_struct_annotations = {
}
executeJsonWithParameter_args.thrift_field_annotations = {
}

def executeJsonWithParameter_args__init__(self, sessionId=None, stmt=None, parameterMap=None,):
  self.sessionId = sessionId
  self.stmt = stmt
  self.parameterMap = parameterMap

executeJsonWithParameter_args.__init__ = executeJsonWithParameter_args__init__

def executeJsonWithParameter_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  state.setdefault('parameterMap', None)
  self.__dict__ = state

executeJsonWithParameter_args.__getstate__ = lambda self: self.__dict__.copy()
executeJsonWithParameter_args.__setstate__ = executeJsonWithParameter_args__setstate__

class executeJsonWithParameter_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('executeJsonWithParameter_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(executeJsonWithParameter_result)
executeJsonWithParameter_result.thrift_spec = (
  (0, TType.STRING, 'success', False, None, 2, ), # 0
)

executeJsonWithParameter_result.thrift_struct_annotations = {
}
executeJsonWithParameter_result.thrift_field_annotations = {
}

def executeJsonWithParameter_result__init__(self, success=None,):
  self.success = success

executeJsonWithParameter_result.__init__ = executeJsonWithParameter_result__init__

def executeJsonWithParameter_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

executeJsonWithParameter_result.__getstate__ = lambda self: self.__dict__.copy()
executeJsonWithParameter_result.__setstate__ = executeJsonWithParameter_result__setstate__

class verifyClientVersion_args:
  """
  Attributes:
   - req
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.req = VerifyClientVersionReq()
          self.req.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('verifyClientVersion_args')
    if self.req != None:
      oprot.writeFieldBegin('req', TType.STRUCT, 1)
      self.req.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.req is not None:
      value = pprint.pformat(self.req, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    req=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(verifyClientVersion_args)
verifyClientVersion_args.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'req', [VerifyClientVersionReq, VerifyClientVersionReq.thrift_spec, False], None, 2, ), # 1
)

verifyClientVersion_args.thrift_struct_annotations = {
}
verifyClientVersion_args.thrift_field_annotations = {
}

def verifyClientVersion_args__init__(self, req=None,):
  self.req = req

verifyClientVersion_args.__init__ = verifyClientVersion_args__init__

def verifyClientVersion_args__setstate__(self, state):
  state.setdefault('req', None)
  self.__dict__ = state

verifyClientVersion_args.__getstate__ = lambda self: self.__dict__.copy()
verifyClientVersion_args.__setstate__ = verifyClientVersion_args__setstate__

class verifyClientVersion_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = VerifyClientVersionResp()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('verifyClientVersion_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(verifyClientVersion_result)
verifyClientVersion_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [VerifyClientVersionResp, VerifyClientVersionResp.thrift_spec, False], None, 2, ), # 0
)

verifyClientVersion_result.thrift_struct_annotations = {
}
verifyClientVersion_result.thrift_field_annotations = {
}

def verifyClientVersion_result__init__(self, success=None,):
  self.success = success

verifyClientVersion_result.__init__ = verifyClientVersion_result__init__

def verifyClientVersion_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

verifyClientVersion_result.__getstate__ = lambda self: self.__dict__.copy()
verifyClientVersion_result.__setstate__ = verifyClientVersion_result__setstate__

class Client(Iface):
  def __enter__(self):
    return self

  def __exit__(self, type, value, tb):
    self._iprot.trans.close()
    if self._iprot is not self._oprot:
      self._oprot.trans.close()

  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def authenticate(self, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    self.send_authenticate(username, password)
    return self.recv_authenticate()

  def send_authenticate(self, username=None, password=None):
    self._oprot.writeMessageBegin('authenticate', TMessageType.CALL, self._seqid)
    args = authenticate_args()
    args.username = username
    args.password = password
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = authenticate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "authenticate failed: unknown result");

  def signout(self, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    self.send_signout(sessionId)

  def send_signout(self, sessionId=None):
    self._oprot.writeMessageBegin('signout', TMessageType.CALL, self._seqid)
    args = signout_args()
    args.sessionId = sessionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.onewayFlush()
  def execute(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    self.send_execute(sessionId, stmt)
    return self.recv_execute()

  def send_execute(self, sessionId=None, stmt=None):
    self._oprot.writeMessageBegin('execute', TMessageType.CALL, self._seqid)
    args = execute_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_execute(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = execute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "execute failed: unknown result");

  def executeWithParameter(self, sessionId=None, stmt=None, parameterMap=None):
    """
    Parameters:
     - sessionId
     - stmt
     - parameterMap
    """
    self.send_executeWithParameter(sessionId, stmt, parameterMap)
    return self.recv_executeWithParameter()

  def send_executeWithParameter(self, sessionId=None, stmt=None, parameterMap=None):
    self._oprot.writeMessageBegin('executeWithParameter', TMessageType.CALL, self._seqid)
    args = executeWithParameter_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.parameterMap = parameterMap
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_executeWithParameter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = executeWithParameter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "executeWithParameter failed: unknown result");

  def executeJson(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    self.send_executeJson(sessionId, stmt)
    return self.recv_executeJson()

  def send_executeJson(self, sessionId=None, stmt=None):
    self._oprot.writeMessageBegin('executeJson', TMessageType.CALL, self._seqid)
    args = executeJson_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_executeJson(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = executeJson_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "executeJson failed: unknown result");

  def executeJsonWithParameter(self, sessionId=None, stmt=None, parameterMap=None):
    """
    Parameters:
     - sessionId
     - stmt
     - parameterMap
    """
    self.send_executeJsonWithParameter(sessionId, stmt, parameterMap)
    return self.recv_executeJsonWithParameter()

  def send_executeJsonWithParameter(self, sessionId=None, stmt=None, parameterMap=None):
    self._oprot.writeMessageBegin('executeJsonWithParameter', TMessageType.CALL, self._seqid)
    args = executeJsonWithParameter_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.parameterMap = parameterMap
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_executeJsonWithParameter(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = executeJsonWithParameter_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "executeJsonWithParameter failed: unknown result");

  def verifyClientVersion(self, req=None):
    """
    Parameters:
     - req
    """
    self.send_verifyClientVersion(req)
    return self.recv_verifyClientVersion()

  def send_verifyClientVersion(self, req=None):
    self._oprot.writeMessageBegin('verifyClientVersion', TMessageType.CALL, self._seqid)
    args = verifyClientVersion_args()
    args.req = req
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_verifyClientVersion(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = verifyClientVersion_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "verifyClientVersion failed: unknown result");


class Processor(Iface, TProcessor):
  _onewayMethods = ("signout",)

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._priorityMap = {}
    self._processMap["authenticate"] = Processor.process_authenticate
    self._priorityMap["authenticate"] = TPriority.NORMAL
    self._processMap["signout"] = Processor.process_signout
    self._priorityMap["signout"] = TPriority.NORMAL
    self._processMap["execute"] = Processor.process_execute
    self._priorityMap["execute"] = TPriority.NORMAL
    self._processMap["executeWithParameter"] = Processor.process_executeWithParameter
    self._priorityMap["executeWithParameter"] = TPriority.NORMAL
    self._processMap["executeJson"] = Processor.process_executeJson
    self._priorityMap["executeJson"] = TPriority.NORMAL
    self._processMap["executeJsonWithParameter"] = Processor.process_executeJsonWithParameter
    self._priorityMap["executeJsonWithParameter"] = TPriority.NORMAL
    self._processMap["verifyClientVersion"] = Processor.process_verifyClientVersion
    self._priorityMap["verifyClientVersion"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @thrift_process_main()
  def process(self,): pass

  @thrift_process_method(authenticate_args, oneway=False)
  def process_authenticate(self, args, handler_ctx):
    result = authenticate_result()
    try:
      result.success = self._handler.authenticate(args.username, args.password)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'authenticate', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(signout_args, oneway=True)
  def process_signout(self, args, handler_ctx):
    try:
      self._handler.signout(args.sessionId)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'signout', ex)
      result = Thrift.TApplicationException(message=repr(ex))

  @thrift_process_method(execute_args, oneway=False)
  def process_execute(self, args, handler_ctx):
    result = execute_result()
    try:
      result.success = self._handler.execute(args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'execute', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeWithParameter_args, oneway=False)
  def process_executeWithParameter(self, args, handler_ctx):
    result = executeWithParameter_result()
    try:
      result.success = self._handler.executeWithParameter(args.sessionId, args.stmt, args.parameterMap)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeWithParameter', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeJson_args, oneway=False)
  def process_executeJson(self, args, handler_ctx):
    result = executeJson_result()
    try:
      result.success = self._handler.executeJson(args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeJson', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeJsonWithParameter_args, oneway=False)
  def process_executeJsonWithParameter(self, args, handler_ctx):
    result = executeJsonWithParameter_result()
    try:
      result.success = self._handler.executeJsonWithParameter(args.sessionId, args.stmt, args.parameterMap)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeJsonWithParameter', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(verifyClientVersion_args, oneway=False)
  def process_verifyClientVersion(self, args, handler_ctx):
    result = verifyClientVersion_result()
    try:
      result.success = self._handler.verifyClientVersion(args.req)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'verifyClientVersion', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  _onewayMethods = ("signout",)

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._priorityMap = {}
    self._processMap["authenticate"] = ContextProcessor.process_authenticate
    self._priorityMap["authenticate"] = TPriority.NORMAL
    self._processMap["signout"] = ContextProcessor.process_signout
    self._priorityMap["signout"] = TPriority.NORMAL
    self._processMap["execute"] = ContextProcessor.process_execute
    self._priorityMap["execute"] = TPriority.NORMAL
    self._processMap["executeWithParameter"] = ContextProcessor.process_executeWithParameter
    self._priorityMap["executeWithParameter"] = TPriority.NORMAL
    self._processMap["executeJson"] = ContextProcessor.process_executeJson
    self._priorityMap["executeJson"] = TPriority.NORMAL
    self._processMap["executeJsonWithParameter"] = ContextProcessor.process_executeJsonWithParameter
    self._priorityMap["executeJsonWithParameter"] = TPriority.NORMAL
    self._processMap["verifyClientVersion"] = ContextProcessor.process_verifyClientVersion
    self._priorityMap["verifyClientVersion"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @thrift_process_main()
  def process(self,): pass

  @thrift_process_method(authenticate_args, oneway=False)
  def process_authenticate(self, args, handler_ctx):
    result = authenticate_result()
    try:
      result.success = self._handler.authenticate(handler_ctx, args.username, args.password)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'authenticate', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(signout_args, oneway=True)
  def process_signout(self, args, handler_ctx):
    try:
      self._handler.signout(handler_ctx, args.sessionId)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'signout', ex)
      result = Thrift.TApplicationException(message=repr(ex))

  @thrift_process_method(execute_args, oneway=False)
  def process_execute(self, args, handler_ctx):
    result = execute_result()
    try:
      result.success = self._handler.execute(handler_ctx, args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'execute', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeWithParameter_args, oneway=False)
  def process_executeWithParameter(self, args, handler_ctx):
    result = executeWithParameter_result()
    try:
      result.success = self._handler.executeWithParameter(handler_ctx, args.sessionId, args.stmt, args.parameterMap)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeWithParameter', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeJson_args, oneway=False)
  def process_executeJson(self, args, handler_ctx):
    result = executeJson_result()
    try:
      result.success = self._handler.executeJson(handler_ctx, args.sessionId, args.stmt)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeJson', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(executeJsonWithParameter_args, oneway=False)
  def process_executeJsonWithParameter(self, args, handler_ctx):
    result = executeJsonWithParameter_result()
    try:
      result.success = self._handler.executeJsonWithParameter(handler_ctx, args.sessionId, args.stmt, args.parameterMap)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'executeJsonWithParameter', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

  @thrift_process_method(verifyClientVersion_args, oneway=False)
  def process_verifyClientVersion(self, args, handler_ctx):
    result = verifyClientVersion_result()
    try:
      result.success = self._handler.verifyClientVersion(handler_ctx, args.req)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'verifyClientVersion', ex)
      result = Thrift.TApplicationException(message=repr(ex))
    return result

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

