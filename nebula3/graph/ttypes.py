#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from nebula3.fbthrift.util.Recursive import fix_spec
from nebula3.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula3.fbthrift.protocol.TProtocol import TProtocolException


import nebula3.common.ttypes


import pprint
import warnings
from nebula3.fbthrift import Thrift
from nebula3.fbthrift.transport import TTransport
from nebula3.fbthrift.protocol import TBinaryProtocol
from nebula3.fbthrift.protocol import TCompactProtocol
from nebula3.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula3.fbthrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'ProfilingStats', 'PlanNodeBranchInfo', 'Pair', 'PlanNodeDescription', 'PlanDescription', 'ExecutionResponse', 'AuthResponse', 'VerifyClientVersionResp', 'VerifyClientVersionReq']

class ProfilingStats:
  """
  Attributes:
   - rows
   - exec_duration_in_us
   - total_duration_in_us
   - other_stats
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.rows = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.exec_duration_in_us = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.total_duration_in_us = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.other_stats = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          if _size0 >= 0:
            for _i4 in range(_size0):
              _key5 = iprot.readString()
              _val6 = iprot.readString()
              self.other_stats[_key5] = _val6
          else: 
            while iprot.peekMap():
              _key7 = iprot.readString()
              _val8 = iprot.readString()
              self.other_stats[_key7] = _val8
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ProfilingStats')
    if self.rows != None:
      oprot.writeFieldBegin('rows', TType.I64, 1)
      oprot.writeI64(self.rows)
      oprot.writeFieldEnd()
    if self.exec_duration_in_us != None:
      oprot.writeFieldBegin('exec_duration_in_us', TType.I64, 2)
      oprot.writeI64(self.exec_duration_in_us)
      oprot.writeFieldEnd()
    if self.total_duration_in_us != None:
      oprot.writeFieldBegin('total_duration_in_us', TType.I64, 3)
      oprot.writeI64(self.total_duration_in_us)
      oprot.writeFieldEnd()
    if self.other_stats != None:
      oprot.writeFieldBegin('other_stats', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.other_stats))
      for kiter9,viter10 in self.other_stats.items():
        oprot.writeString(kiter9)
        oprot.writeString(viter10)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.rows is not None:
      value = pprint.pformat(self.rows, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    rows=%s' % (value))
    if self.exec_duration_in_us is not None:
      value = pprint.pformat(self.exec_duration_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    exec_duration_in_us=%s' % (value))
    if self.total_duration_in_us is not None:
      value = pprint.pformat(self.total_duration_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    total_duration_in_us=%s' % (value))
    if self.other_stats is not None:
      value = pprint.pformat(self.other_stats, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    other_stats=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PlanNodeBranchInfo:
  """
  Attributes:
   - is_do_branch
   - condition_node_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.is_do_branch = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.condition_node_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PlanNodeBranchInfo')
    if self.is_do_branch != None:
      oprot.writeFieldBegin('is_do_branch', TType.BOOL, 1)
      oprot.writeBool(self.is_do_branch)
      oprot.writeFieldEnd()
    if self.condition_node_id != None:
      oprot.writeFieldBegin('condition_node_id', TType.I64, 2)
      oprot.writeI64(self.condition_node_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.is_do_branch is not None:
      value = pprint.pformat(self.is_do_branch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_do_branch=%s' % (value))
    if self.condition_node_id is not None:
      value = pprint.pformat(self.condition_node_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    condition_node_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Pair:
  """
  Attributes:
   - key
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Pair')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 1)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PlanNodeDescription:
  """
  Attributes:
   - name
   - id
   - output_var
   - description
   - profiles
   - branch_info
   - dependencies
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.output_var = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.description = []
          (_etype14, _size11) = iprot.readListBegin()
          if _size11 >= 0:
            for _i15 in range(_size11):
              _elem16 = Pair()
              _elem16.read(iprot)
              self.description.append(_elem16)
          else: 
            while iprot.peekList():
              _elem17 = Pair()
              _elem17.read(iprot)
              self.description.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.profiles = []
          (_etype21, _size18) = iprot.readListBegin()
          if _size18 >= 0:
            for _i22 in range(_size18):
              _elem23 = ProfilingStats()
              _elem23.read(iprot)
              self.profiles.append(_elem23)
          else: 
            while iprot.peekList():
              _elem24 = ProfilingStats()
              _elem24.read(iprot)
              self.profiles.append(_elem24)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.branch_info = PlanNodeBranchInfo()
          self.branch_info.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.dependencies = []
          (_etype28, _size25) = iprot.readListBegin()
          if _size25 >= 0:
            for _i29 in range(_size25):
              _elem30 = iprot.readI64()
              self.dependencies.append(_elem30)
          else: 
            while iprot.peekList():
              _elem31 = iprot.readI64()
              self.dependencies.append(_elem31)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PlanNodeDescription')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 2)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.output_var != None:
      oprot.writeFieldBegin('output_var', TType.STRING, 3)
      oprot.writeString(self.output_var)
      oprot.writeFieldEnd()
    if self.description != None:
      oprot.writeFieldBegin('description', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.description))
      for iter32 in self.description:
        iter32.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.profiles != None:
      oprot.writeFieldBegin('profiles', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.profiles))
      for iter33 in self.profiles:
        iter33.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.branch_info != None:
      oprot.writeFieldBegin('branch_info', TType.STRUCT, 6)
      self.branch_info.write(oprot)
      oprot.writeFieldEnd()
    if self.dependencies != None:
      oprot.writeFieldBegin('dependencies', TType.LIST, 7)
      oprot.writeListBegin(TType.I64, len(self.dependencies))
      for iter34 in self.dependencies:
        oprot.writeI64(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.output_var is not None:
      value = pprint.pformat(self.output_var, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    output_var=%s' % (value))
    if self.description is not None:
      value = pprint.pformat(self.description, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    description=%s' % (value))
    if self.profiles is not None:
      value = pprint.pformat(self.profiles, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    profiles=%s' % (value))
    if self.branch_info is not None:
      value = pprint.pformat(self.branch_info, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    branch_info=%s' % (value))
    if self.dependencies is not None:
      value = pprint.pformat(self.dependencies, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dependencies=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PlanDescription:
  """
  Attributes:
   - plan_node_descs
   - node_index_map
   - format
   - optimize_time_in_us
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.plan_node_descs = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in range(_size35):
              _elem40 = PlanNodeDescription()
              _elem40.read(iprot)
              self.plan_node_descs.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = PlanNodeDescription()
              _elem41.read(iprot)
              self.plan_node_descs.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.node_index_map = {}
          (_ktype43, _vtype44, _size42 ) = iprot.readMapBegin() 
          if _size42 >= 0:
            for _i46 in range(_size42):
              _key47 = iprot.readI64()
              _val48 = iprot.readI64()
              self.node_index_map[_key47] = _val48
          else: 
            while iprot.peekMap():
              _key49 = iprot.readI64()
              _val50 = iprot.readI64()
              self.node_index_map[_key49] = _val50
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.format = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.optimize_time_in_us = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PlanDescription')
    if self.plan_node_descs != None:
      oprot.writeFieldBegin('plan_node_descs', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.plan_node_descs))
      for iter51 in self.plan_node_descs:
        iter51.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.node_index_map != None:
      oprot.writeFieldBegin('node_index_map', TType.MAP, 2)
      oprot.writeMapBegin(TType.I64, TType.I64, len(self.node_index_map))
      for kiter52,viter53 in self.node_index_map.items():
        oprot.writeI64(kiter52)
        oprot.writeI64(viter53)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.format != None:
      oprot.writeFieldBegin('format', TType.STRING, 3)
      oprot.writeString(self.format)
      oprot.writeFieldEnd()
    if self.optimize_time_in_us != None:
      oprot.writeFieldBegin('optimize_time_in_us', TType.I32, 4)
      oprot.writeI32(self.optimize_time_in_us)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.plan_node_descs is not None:
      value = pprint.pformat(self.plan_node_descs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    plan_node_descs=%s' % (value))
    if self.node_index_map is not None:
      value = pprint.pformat(self.node_index_map, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    node_index_map=%s' % (value))
    if self.format is not None:
      value = pprint.pformat(self.format, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    format=%s' % (value))
    if self.optimize_time_in_us is not None:
      value = pprint.pformat(self.optimize_time_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optimize_time_in_us=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ExecutionResponse:
  """
  Attributes:
   - error_code
   - latency_in_us
   - data
   - space_name
   - error_msg
   - plan_desc
   - comment
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.latency_in_us = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.data = nebula3.common.ttypes.DataSet()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.plan_desc = PlanDescription()
          self.plan_desc.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecutionResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.latency_in_us != None:
      oprot.writeFieldBegin('latency_in_us', TType.I64, 2)
      oprot.writeI64(self.latency_in_us)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 3)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 4)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.error_msg != None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 5)
      oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    if self.plan_desc != None:
      oprot.writeFieldBegin('plan_desc', TType.STRUCT, 6)
      self.plan_desc.write(oprot)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 7)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    if self.latency_in_us is not None:
      value = pprint.pformat(self.latency_in_us, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    latency_in_us=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.error_msg is not None:
      value = pprint.pformat(self.error_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_msg=%s' % (value))
    if self.plan_desc is not None:
      value = pprint.pformat(self.plan_desc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    plan_desc=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AuthResponse:
  """
  Attributes:
   - error_code
   - error_msg
   - session_id
   - time_zone_offset_seconds
   - time_zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.time_zone_offset_seconds = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.time_zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AuthResponse')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.error_msg != None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 2)
      oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 3)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    if self.time_zone_offset_seconds != None:
      oprot.writeFieldBegin('time_zone_offset_seconds', TType.I32, 4)
      oprot.writeI32(self.time_zone_offset_seconds)
      oprot.writeFieldEnd()
    if self.time_zone_name != None:
      oprot.writeFieldBegin('time_zone_name', TType.STRING, 5)
      oprot.writeString(self.time_zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    if self.error_msg is not None:
      value = pprint.pformat(self.error_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_msg=%s' % (value))
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    if self.time_zone_offset_seconds is not None:
      value = pprint.pformat(self.time_zone_offset_seconds, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    time_zone_offset_seconds=%s' % (value))
    if self.time_zone_name is not None:
      value = pprint.pformat(self.time_zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    time_zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class VerifyClientVersionResp:
  """
  Attributes:
   - error_code
   - error_msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.error_code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VerifyClientVersionResp')
    if self.error_code != None:
      oprot.writeFieldBegin('error_code', TType.I32, 1)
      oprot.writeI32(self.error_code)
      oprot.writeFieldEnd()
    if self.error_msg != None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 2)
      oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.error_code is not None:
      value = pprint.pformat(self.error_code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_code=%s' % (value))
    if self.error_msg is not None:
      value = pprint.pformat(self.error_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_msg=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class VerifyClientVersionReq:
  """
  Attributes:
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VerifyClientVersionReq')
    if self.version != None:
      oprot.writeFieldBegin('version', TType.STRING, 1)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

all_structs.append(ProfilingStats)
ProfilingStats.thrift_spec = (
  None, # 0
  (1, TType.I64, 'rows', None, None, 0, ), # 1
  (2, TType.I64, 'exec_duration_in_us', None, None, 0, ), # 2
  (3, TType.I64, 'total_duration_in_us', None, None, 0, ), # 3
  (4, TType.MAP, 'other_stats', (TType.STRING,False,TType.STRING,False), None, 1, ), # 4
)

ProfilingStats.thrift_struct_annotations = {
  "cpp.noncopyable": "1",
  "cpp.type": "nebula::ProfilingStats",
}
ProfilingStats.thrift_field_annotations = {
}

def ProfilingStats__init__(self, rows=None, exec_duration_in_us=None, total_duration_in_us=None, other_stats=None,):
  self.rows = rows
  self.exec_duration_in_us = exec_duration_in_us
  self.total_duration_in_us = total_duration_in_us
  self.other_stats = other_stats

ProfilingStats.__init__ = ProfilingStats__init__

def ProfilingStats__setstate__(self, state):
  state.setdefault('rows', None)
  state.setdefault('exec_duration_in_us', None)
  state.setdefault('total_duration_in_us', None)
  state.setdefault('other_stats', None)
  self.__dict__ = state

ProfilingStats.__getstate__ = lambda self: self.__dict__.copy()
ProfilingStats.__setstate__ = ProfilingStats__setstate__

all_structs.append(PlanNodeBranchInfo)
PlanNodeBranchInfo.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'is_do_branch', None, None, 0, ), # 1
  (2, TType.I64, 'condition_node_id', None, None, 0, ), # 2
)

PlanNodeBranchInfo.thrift_struct_annotations = {
  "cpp.type": "nebula::PlanNodeBranchInfo",
}
PlanNodeBranchInfo.thrift_field_annotations = {
}

def PlanNodeBranchInfo__init__(self, is_do_branch=None, condition_node_id=None,):
  self.is_do_branch = is_do_branch
  self.condition_node_id = condition_node_id

PlanNodeBranchInfo.__init__ = PlanNodeBranchInfo__init__

def PlanNodeBranchInfo__setstate__(self, state):
  state.setdefault('is_do_branch', None)
  state.setdefault('condition_node_id', None)
  self.__dict__ = state

PlanNodeBranchInfo.__getstate__ = lambda self: self.__dict__.copy()
PlanNodeBranchInfo.__setstate__ = PlanNodeBranchInfo__setstate__

all_structs.append(Pair)
Pair.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'key', False, None, 0, ), # 1
  (2, TType.STRING, 'value', False, None, 0, ), # 2
)

Pair.thrift_struct_annotations = {
  "cpp.type": "nebula::Pair",
}
Pair.thrift_field_annotations = {
}

def Pair__init__(self, key=None, value=None,):
  self.key = key
  self.value = value

Pair.__init__ = Pair__init__

def Pair__setstate__(self, state):
  state.setdefault('key', None)
  state.setdefault('value', None)
  self.__dict__ = state

Pair.__getstate__ = lambda self: self.__dict__.copy()
Pair.__setstate__ = Pair__setstate__

all_structs.append(PlanNodeDescription)
PlanNodeDescription.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.I64, 'id', None, None, 0, ), # 2
  (3, TType.STRING, 'output_var', False, None, 0, ), # 3
  (4, TType.LIST, 'description', (TType.STRUCT,[Pair, Pair.thrift_spec, False]), None, 1, ), # 4
  (5, TType.LIST, 'profiles', (TType.STRUCT,[ProfilingStats, ProfilingStats.thrift_spec, False]), None, 1, ), # 5
  (6, TType.STRUCT, 'branch_info', [PlanNodeBranchInfo, PlanNodeBranchInfo.thrift_spec, False], None, 1, ), # 6
  (7, TType.LIST, 'dependencies', (TType.I64,None), None, 1, ), # 7
)

PlanNodeDescription.thrift_struct_annotations = {
  "cpp.noncopyable": "1",
  "cpp.type": "nebula::PlanNodeDescription",
}
PlanNodeDescription.thrift_field_annotations = {
}

def PlanNodeDescription__init__(self, name=None, id=None, output_var=None, description=None, profiles=None, branch_info=None, dependencies=None,):
  self.name = name
  self.id = id
  self.output_var = output_var
  self.description = description
  self.profiles = profiles
  self.branch_info = branch_info
  self.dependencies = dependencies

PlanNodeDescription.__init__ = PlanNodeDescription__init__

def PlanNodeDescription__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('id', None)
  state.setdefault('output_var', None)
  state.setdefault('description', None)
  state.setdefault('profiles', None)
  state.setdefault('branch_info', None)
  state.setdefault('dependencies', None)
  self.__dict__ = state

PlanNodeDescription.__getstate__ = lambda self: self.__dict__.copy()
PlanNodeDescription.__setstate__ = PlanNodeDescription__setstate__

all_structs.append(PlanDescription)
PlanDescription.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'plan_node_descs', (TType.STRUCT,[PlanNodeDescription, PlanNodeDescription.thrift_spec, False]), None, 0, ), # 1
  (2, TType.MAP, 'node_index_map', (TType.I64,None,TType.I64,None), None, 0, ), # 2
  (3, TType.STRING, 'format', False, None, 0, ), # 3
  (4, TType.I32, 'optimize_time_in_us', None, None, 0, ), # 4
)

PlanDescription.thrift_struct_annotations = {
  "cpp.noncopyable": "1",
  "cpp.type": "nebula::PlanDescription",
}
PlanDescription.thrift_field_annotations = {
}

def PlanDescription__init__(self, plan_node_descs=None, node_index_map=None, format=None, optimize_time_in_us=None,):
  self.plan_node_descs = plan_node_descs
  self.node_index_map = node_index_map
  self.format = format
  self.optimize_time_in_us = optimize_time_in_us

PlanDescription.__init__ = PlanDescription__init__

def PlanDescription__setstate__(self, state):
  state.setdefault('plan_node_descs', None)
  state.setdefault('node_index_map', None)
  state.setdefault('format', None)
  state.setdefault('optimize_time_in_us', None)
  self.__dict__ = state

PlanDescription.__getstate__ = lambda self: self.__dict__.copy()
PlanDescription.__setstate__ = PlanDescription__setstate__

all_structs.append(ExecutionResponse)
ExecutionResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', nebula3.common.ttypes.ErrorCode, None, 0, ), # 1
  (2, TType.I64, 'latency_in_us', None, None, 0, ), # 2
  (3, TType.STRUCT, 'data', [nebula3.common.ttypes.DataSet, nebula3.common.ttypes.DataSet.thrift_spec, False], None, 1, ), # 3
  (4, TType.STRING, 'space_name', False, None, 1, ), # 4
  (5, TType.STRING, 'error_msg', False, None, 1, ), # 5
  (6, TType.STRUCT, 'plan_desc', [PlanDescription, PlanDescription.thrift_spec, False], None, 1, ), # 6
  (7, TType.STRING, 'comment', False, None, 1, ), # 7
)

ExecutionResponse.thrift_struct_annotations = {
  "cpp.noncopyable": "1",
  "cpp.type": "nebula::ExecutionResponse",
}
ExecutionResponse.thrift_field_annotations = {
}

def ExecutionResponse__init__(self, error_code=None, latency_in_us=None, data=None, space_name=None, error_msg=None, plan_desc=None, comment=None,):
  self.error_code = error_code
  self.latency_in_us = latency_in_us
  self.data = data
  self.space_name = space_name
  self.error_msg = error_msg
  self.plan_desc = plan_desc
  self.comment = comment

ExecutionResponse.__init__ = ExecutionResponse__init__

def ExecutionResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  state.setdefault('latency_in_us', None)
  state.setdefault('data', None)
  state.setdefault('space_name', None)
  state.setdefault('error_msg', None)
  state.setdefault('plan_desc', None)
  state.setdefault('comment', None)
  self.__dict__ = state

ExecutionResponse.__getstate__ = lambda self: self.__dict__.copy()
ExecutionResponse.__setstate__ = ExecutionResponse__setstate__

all_structs.append(AuthResponse)
AuthResponse.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', nebula3.common.ttypes.ErrorCode, None, 0, ), # 1
  (2, TType.STRING, 'error_msg', False, None, 1, ), # 2
  (3, TType.I64, 'session_id', None, None, 1, ), # 3
  (4, TType.I32, 'time_zone_offset_seconds', None, None, 1, ), # 4
  (5, TType.STRING, 'time_zone_name', False, None, 1, ), # 5
)

AuthResponse.thrift_struct_annotations = {
  "cpp.noncopyable": "1",
  "cpp.type": "nebula::AuthResponse",
}
AuthResponse.thrift_field_annotations = {
}

def AuthResponse__init__(self, error_code=None, error_msg=None, session_id=None, time_zone_offset_seconds=None, time_zone_name=None,):
  self.error_code = error_code
  self.error_msg = error_msg
  self.session_id = session_id
  self.time_zone_offset_seconds = time_zone_offset_seconds
  self.time_zone_name = time_zone_name

AuthResponse.__init__ = AuthResponse__init__

def AuthResponse__setstate__(self, state):
  state.setdefault('error_code', None)
  state.setdefault('error_msg', None)
  state.setdefault('session_id', None)
  state.setdefault('time_zone_offset_seconds', None)
  state.setdefault('time_zone_name', None)
  self.__dict__ = state

AuthResponse.__getstate__ = lambda self: self.__dict__.copy()
AuthResponse.__setstate__ = AuthResponse__setstate__

all_structs.append(VerifyClientVersionResp)
VerifyClientVersionResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'error_code', nebula3.common.ttypes.ErrorCode, None, 0, ), # 1
  (2, TType.STRING, 'error_msg', False, None, 1, ), # 2
)

VerifyClientVersionResp.thrift_struct_annotations = {
}
VerifyClientVersionResp.thrift_field_annotations = {
}

def VerifyClientVersionResp__init__(self, error_code=None, error_msg=None,):
  self.error_code = error_code
  self.error_msg = error_msg

VerifyClientVersionResp.__init__ = VerifyClientVersionResp__init__

def VerifyClientVersionResp__setstate__(self, state):
  state.setdefault('error_code', None)
  state.setdefault('error_msg', None)
  self.__dict__ = state

VerifyClientVersionResp.__getstate__ = lambda self: self.__dict__.copy()
VerifyClientVersionResp.__setstate__ = VerifyClientVersionResp__setstate__

all_structs.append(VerifyClientVersionReq)
VerifyClientVersionReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'version', False, "3.0.0", 0, ), # 1
)

VerifyClientVersionReq.thrift_struct_annotations = {
}
VerifyClientVersionReq.thrift_field_annotations = {
}

def VerifyClientVersionReq__init__(self, version=VerifyClientVersionReq.thrift_spec[1][4],):
  self.version = version

VerifyClientVersionReq.__init__ = VerifyClientVersionReq__init__

def VerifyClientVersionReq__setstate__(self, state):
  state.setdefault('version', "3.0.0")
  self.__dict__ = state

VerifyClientVersionReq.__getstate__ = lambda self: self.__dict__.copy()
VerifyClientVersionReq.__setstate__ = VerifyClientVersionReq__setstate__

fix_spec(all_structs)
del all_structs
