#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from nebula3.fbthrift.util.Recursive import fix_spec
from nebula3.fbthrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from nebula3.fbthrift.protocol.TProtocol import TProtocolException


import nebula3.common.ttypes


import pprint
import warnings
from nebula3.fbthrift import Thrift
from nebula3.fbthrift.transport import TTransport
from nebula3.fbthrift.protocol import TBinaryProtocol
from nebula3.fbthrift.protocol import TCompactProtocol
from nebula3.fbthrift.protocol import THeaderProtocol
fastproto = None
try:
  from nebula3.fbthrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'AlterSchemaOp', 'RoleType', 'GeoShape', 'IsolationLevel', 'HostStatus', 'SnapshotStatus', 'AlterSpaceOp', 'AdminJobOp', 'AdminCmd', 'JobStatus', 'ListHostType', 'HostRole', 'TaskResult', 'ConfigModule', 'ConfigMode', 'ListenerType', 'ExternalServiceType', 'QueryStatus', 'ID', 'ColumnTypeDef', 'ColumnDef', 'SchemaProp', 'Schema', 'IdName', 'SpaceDesc', 'SpaceItem', 'TagItem', 'AlterSchemaItem', 'EdgeItem', 'IndexParams', 'IndexItem', 'HostItem', 'UserItem', 'RoleItem', 'ExecResp', 'AlterSpaceReq', 'AdminJobReq', 'JobDesc', 'TaskDesc', 'AdminJobResult', 'AdminJobResp', 'Correlativity', 'StatsItem', 'CreateSpaceReq', 'CreateSpaceAsReq', 'DropSpaceReq', 'ListSpacesReq', 'ListSpacesResp', 'GetSpaceReq', 'GetSpaceResp', 'CreateTagReq', 'AlterTagReq', 'DropTagReq', 'ListTagsReq', 'ListTagsResp', 'GetTagReq', 'GetTagResp', 'CreateEdgeReq', 'AlterEdgeReq', 'GetEdgeReq', 'GetEdgeResp', 'DropEdgeReq', 'ListEdgesReq', 'ListEdgesResp', 'AddHostsReq', 'DropHostsReq', 'ListHostsReq', 'ListHostsResp', 'PartItem', 'ListPartsReq', 'ListPartsResp', 'GetPartsAllocReq', 'GetPartsAllocResp', 'GetWorkerIdReq', 'GetWorkerIdResp', 'MultiPutReq', 'GetReq', 'GetResp', 'MultiGetReq', 'MultiGetResp', 'RemoveReq', 'RemoveRangeReq', 'ScanReq', 'ScanResp', 'HBResp', 'LeaderInfo', 'PartitionList', 'HBReq', 'ServiceInfo', 'AgentHBReq', 'AgentHBResp', 'IndexFieldDef', 'CreateTagIndexReq', 'DropTagIndexReq', 'GetTagIndexReq', 'GetTagIndexResp', 'ListTagIndexesReq', 'ListTagIndexesResp', 'CreateEdgeIndexReq', 'DropEdgeIndexReq', 'GetEdgeIndexReq', 'GetEdgeIndexResp', 'ListEdgeIndexesReq', 'ListEdgeIndexesResp', 'RebuildIndexReq', 'CreateUserReq', 'DropUserReq', 'AlterUserReq', 'GrantRoleReq', 'RevokeRoleReq', 'ListUsersReq', 'ListUsersResp', 'ListRolesReq', 'ListRolesResp', 'GetUserRolesReq', 'ChangePasswordReq', 'BalanceTask', 'ConfigItem', 'RegConfigReq', 'GetConfigReq', 'GetConfigResp', 'SetConfigReq', 'ListConfigsReq', 'ListConfigsResp', 'CreateSnapshotReq', 'DropSnapshotReq', 'ListSnapshotsReq', 'Snapshot', 'ListSnapshotsResp', 'ListIndexStatusReq', 'IndexStatus', 'ListIndexStatusResp', 'MergeZoneReq', 'DropZoneReq', 'DivideZoneReq', 'RenameZoneReq', 'AddHostsIntoZoneReq', 'GetZoneReq', 'GetZoneResp', 'ListZonesReq', 'Zone', 'ListZonesResp', 'AddListenerReq', 'RemoveListenerReq', 'ListListenerReq', 'ListenerInfo', 'ListListenerResp', 'GetStatsReq', 'GetStatsResp', 'HostBackupInfo', 'SpaceBackupInfo', 'BackupMeta', 'CreateBackupReq', 'CreateBackupResp', 'HostPair', 'RestoreMetaReq', 'ServiceClient', 'SignInServiceReq', 'SignOutServiceReq', 'ListServiceClientsReq', 'ListServiceClientsResp', 'FTIndex', 'CreateFTIndexReq', 'DropFTIndexReq', 'ListFTIndexesReq', 'ListFTIndexesResp', 'QueryDesc', 'Session', 'CreateSessionReq', 'CreateSessionResp', 'UpdateSessionsReq', 'UpdateSessionsResp', 'ListSessionsReq', 'ListSessionsResp', 'GetSessionReq', 'GetSessionResp', 'RemoveSessionReq', 'KillQueryReq', 'ReportTaskReq', 'ListClusterInfoResp', 'ListClusterInfoReq', 'GetMetaDirInfoResp', 'GetMetaDirInfoReq', 'VerifyClientVersionResp', 'VerifyClientVersionReq', 'SchemaVer', 'ClusterID']

class AlterSchemaOp:
  ADD = 1
  CHANGE = 2
  DROP = 3
  UNKNOWN = 4

  _VALUES_TO_NAMES = {
    1: "ADD",
    2: "CHANGE",
    3: "DROP",
    4: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "ADD": 1,
    "CHANGE": 2,
    "DROP": 3,
    "UNKNOWN": 4,
  }

class RoleType:
  GOD = 1
  ADMIN = 2
  DBA = 3
  USER = 4
  GUEST = 5

  _VALUES_TO_NAMES = {
    1: "GOD",
    2: "ADMIN",
    3: "DBA",
    4: "USER",
    5: "GUEST",
  }

  _NAMES_TO_VALUES = {
    "GOD": 1,
    "ADMIN": 2,
    "DBA": 3,
    "USER": 4,
    "GUEST": 5,
  }

class GeoShape:
  ANY = 0
  POINT = 1
  LINESTRING = 2
  POLYGON = 3

  _VALUES_TO_NAMES = {
    0: "ANY",
    1: "POINT",
    2: "LINESTRING",
    3: "POLYGON",
  }

  _NAMES_TO_VALUES = {
    "ANY": 0,
    "POINT": 1,
    "LINESTRING": 2,
    "POLYGON": 3,
  }

class IsolationLevel:
  DEFAULT = 0
  TOSS = 1

  _VALUES_TO_NAMES = {
    0: "DEFAULT",
    1: "TOSS",
  }

  _NAMES_TO_VALUES = {
    "DEFAULT": 0,
    "TOSS": 1,
  }

class HostStatus:
  ONLINE = 0
  OFFLINE = 1
  UNKNOWN = 2

  _VALUES_TO_NAMES = {
    0: "ONLINE",
    1: "OFFLINE",
    2: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "ONLINE": 0,
    "OFFLINE": 1,
    "UNKNOWN": 2,
  }

class SnapshotStatus:
  VALID = 0
  INVALID = 1

  _VALUES_TO_NAMES = {
    0: "VALID",
    1: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "VALID": 0,
    "INVALID": 1,
  }

class AlterSpaceOp:
  ADD_ZONE = 1

  _VALUES_TO_NAMES = {
    1: "ADD_ZONE",
  }

  _NAMES_TO_VALUES = {
    "ADD_ZONE": 1,
  }

class AdminJobOp:
  ADD = 1
  SHOW_All = 2
  SHOW = 3
  STOP = 4
  RECOVER = 5

  _VALUES_TO_NAMES = {
    1: "ADD",
    2: "SHOW_All",
    3: "SHOW",
    4: "STOP",
    5: "RECOVER",
  }

  _NAMES_TO_VALUES = {
    "ADD": 1,
    "SHOW_All": 2,
    "SHOW": 3,
    "STOP": 4,
    "RECOVER": 5,
  }

class AdminCmd:
  COMPACT = 0
  FLUSH = 1
  REBUILD_TAG_INDEX = 2
  REBUILD_EDGE_INDEX = 3
  REBUILD_FULLTEXT_INDEX = 4
  STATS = 5
  DATA_BALANCE = 6
  DOWNLOAD = 7
  INGEST = 8
  LEADER_BALANCE = 9
  ZONE_BALANCE = 10
  UNKNOWN = 99

  _VALUES_TO_NAMES = {
    0: "COMPACT",
    1: "FLUSH",
    2: "REBUILD_TAG_INDEX",
    3: "REBUILD_EDGE_INDEX",
    4: "REBUILD_FULLTEXT_INDEX",
    5: "STATS",
    6: "DATA_BALANCE",
    7: "DOWNLOAD",
    8: "INGEST",
    9: "LEADER_BALANCE",
    10: "ZONE_BALANCE",
    99: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "COMPACT": 0,
    "FLUSH": 1,
    "REBUILD_TAG_INDEX": 2,
    "REBUILD_EDGE_INDEX": 3,
    "REBUILD_FULLTEXT_INDEX": 4,
    "STATS": 5,
    "DATA_BALANCE": 6,
    "DOWNLOAD": 7,
    "INGEST": 8,
    "LEADER_BALANCE": 9,
    "ZONE_BALANCE": 10,
    "UNKNOWN": 99,
  }

class JobStatus:
  QUEUE = 1
  RUNNING = 2
  FINISHED = 3
  FAILED = 4
  STOPPED = 5
  INVALID = 255

  _VALUES_TO_NAMES = {
    1: "QUEUE",
    2: "RUNNING",
    3: "FINISHED",
    4: "FAILED",
    5: "STOPPED",
    255: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "QUEUE": 1,
    "RUNNING": 2,
    "FINISHED": 3,
    "FAILED": 4,
    "STOPPED": 5,
    "INVALID": 255,
  }

class ListHostType:
  ALLOC = 0
  GRAPH = 1
  META = 2
  STORAGE = 3
  AGENT = 4

  _VALUES_TO_NAMES = {
    0: "ALLOC",
    1: "GRAPH",
    2: "META",
    3: "STORAGE",
    4: "AGENT",
  }

  _NAMES_TO_VALUES = {
    "ALLOC": 0,
    "GRAPH": 1,
    "META": 2,
    "STORAGE": 3,
    "AGENT": 4,
  }

class HostRole:
  GRAPH = 0
  META = 1
  STORAGE = 2
  LISTENER = 3
  AGENT = 4
  UNKNOWN = 5

  _VALUES_TO_NAMES = {
    0: "GRAPH",
    1: "META",
    2: "STORAGE",
    3: "LISTENER",
    4: "AGENT",
    5: "UNKNOWN",
  }

  _NAMES_TO_VALUES = {
    "GRAPH": 0,
    "META": 1,
    "STORAGE": 2,
    "LISTENER": 3,
    "AGENT": 4,
    "UNKNOWN": 5,
  }

class TaskResult:
  SUCCEEDED = 0
  FAILED = 1
  IN_PROGRESS = 2
  INVALID = 3

  _VALUES_TO_NAMES = {
    0: "SUCCEEDED",
    1: "FAILED",
    2: "IN_PROGRESS",
    3: "INVALID",
  }

  _NAMES_TO_VALUES = {
    "SUCCEEDED": 0,
    "FAILED": 1,
    "IN_PROGRESS": 2,
    "INVALID": 3,
  }

class ConfigModule:
  UNKNOWN = 0
  ALL = 1
  GRAPH = 2
  META = 3
  STORAGE = 4

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "ALL",
    2: "GRAPH",
    3: "META",
    4: "STORAGE",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "ALL": 1,
    "GRAPH": 2,
    "META": 3,
    "STORAGE": 4,
  }

class ConfigMode:
  IMMUTABLE = 0
  REBOOT = 1
  MUTABLE = 2
  IGNORED = 3

  _VALUES_TO_NAMES = {
    0: "IMMUTABLE",
    1: "REBOOT",
    2: "MUTABLE",
    3: "IGNORED",
  }

  _NAMES_TO_VALUES = {
    "IMMUTABLE": 0,
    "REBOOT": 1,
    "MUTABLE": 2,
    "IGNORED": 3,
  }

class ListenerType:
  UNKNOWN = 0
  ELASTICSEARCH = 1

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "ELASTICSEARCH",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "ELASTICSEARCH": 1,
  }

class ExternalServiceType:
  ELASTICSEARCH = 1

  _VALUES_TO_NAMES = {
    1: "ELASTICSEARCH",
  }

  _NAMES_TO_VALUES = {
    "ELASTICSEARCH": 1,
  }

class QueryStatus:
  RUNNING = 1
  KILLING = 2

  _VALUES_TO_NAMES = {
    1: "RUNNING",
    2: "KILLING",
  }

  _NAMES_TO_VALUES = {
    "RUNNING": 1,
    "KILLING": 2,
  }

class ID(object):
  """
  Attributes:
   - space_id
   - tag_id
   - edge_type
   - index_id
   - cluster_id
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  SPACE_ID = 1
  TAG_ID = 2
  EDGE_TYPE = 3
  INDEX_ID = 4
  CLUSTER_ID = 5
  
  @staticmethod
  def isUnion():
    return True

  def get_space_id(self):
    assert self.field == 1
    return self.value

  def get_tag_id(self):
    assert self.field == 2
    return self.value

  def get_edge_type(self):
    assert self.field == 3
    return self.value

  def get_index_id(self):
    assert self.field == 4
    return self.value

  def get_cluster_id(self):
    assert self.field == 5
    return self.value

  def set_space_id(self, value):
    self.field = 1
    self.value = value

  def set_tag_id(self, value):
    self.field = 2
    self.value = value

  def set_edge_type(self, value):
    self.field = 3
    self.value = value

  def set_index_id(self, value):
    self.field = 4
    self.value = value

  def set_cluster_id(self, value):
    self.field = 5
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('space_id', value)
    if self.field == 2:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('tag_id', value)
    if self.field == 3:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('edge_type', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('index_id', value)
    if self.field == 5:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('cluster_id', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          space_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_space_id(space_id)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          tag_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_tag_id(tag_id)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          edge_type = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_edge_type(edge_type)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          index_id = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_index_id(index_id)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          cluster_id = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_cluster_id(cluster_id)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('ID')
    if self.field == 1:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      space_id = self.value
      oprot.writeI32(space_id)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('tag_id', TType.I32, 2)
      tag_id = self.value
      oprot.writeI32(tag_id)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('edge_type', TType.I32, 3)
      edge_type = self.value
      oprot.writeI32(edge_type)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('index_id', TType.I32, 4)
      index_id = self.value
      oprot.writeI32(index_id)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('cluster_id', TType.I64, 5)
      cluster_id = self.value
      oprot.writeI64(cluster_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ColumnTypeDef:
  """
  Attributes:
   - type
   - type_length
   - geo_shape
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.type_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.geo_shape = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ColumnTypeDef')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.type_length != None and self.type_length != self.thrift_spec[2][4]:
      oprot.writeFieldBegin('type_length', TType.I16, 2)
      oprot.writeI16(self.type_length)
      oprot.writeFieldEnd()
    if self.geo_shape != None:
      oprot.writeFieldBegin('geo_shape', TType.I32, 3)
      oprot.writeI32(self.geo_shape)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.type_length is not None:
      value = pprint.pformat(self.type_length, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type_length=%s' % (value))
    if self.geo_shape is not None:
      value = pprint.pformat(self.geo_shape, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    geo_shape=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ColumnDef:
  """
  Attributes:
   - name
   - type
   - default_value
   - nullable
   - comment
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.type = ColumnTypeDef()
          self.type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.default_value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.nullable = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ColumnDef')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.STRUCT, 2)
      self.type.write(oprot)
      oprot.writeFieldEnd()
    if self.default_value != None:
      oprot.writeFieldBegin('default_value', TType.STRING, 3)
      oprot.writeString(self.default_value)
      oprot.writeFieldEnd()
    if self.nullable != None and self.nullable != self.thrift_spec[4][4]:
      oprot.writeFieldBegin('nullable', TType.BOOL, 4)
      oprot.writeBool(self.nullable)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 5)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.default_value is not None:
      value = pprint.pformat(self.default_value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    default_value=%s' % (value))
    if self.nullable is not None:
      value = pprint.pformat(self.nullable, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nullable=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SchemaProp:
  """
  Attributes:
   - ttl_duration
   - ttl_col
   - comment
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ttl_duration = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ttl_col = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SchemaProp')
    if self.ttl_duration != None:
      oprot.writeFieldBegin('ttl_duration', TType.I64, 1)
      oprot.writeI64(self.ttl_duration)
      oprot.writeFieldEnd()
    if self.ttl_col != None:
      oprot.writeFieldBegin('ttl_col', TType.STRING, 2)
      oprot.writeString(self.ttl_col)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 3)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ttl_duration is not None:
      value = pprint.pformat(self.ttl_duration, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ttl_duration=%s' % (value))
    if self.ttl_col is not None:
      value = pprint.pformat(self.ttl_col, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ttl_col=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Schema:
  """
  Attributes:
   - columns
   - schema_prop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.columns = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = ColumnDef()
              _elem5.read(iprot)
              self.columns.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = ColumnDef()
              _elem6.read(iprot)
              self.columns.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema_prop = SchemaProp()
          self.schema_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Schema')
    if self.columns != None:
      oprot.writeFieldBegin('columns', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter7 in self.columns:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_prop != None:
      oprot.writeFieldBegin('schema_prop', TType.STRUCT, 2)
      self.schema_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.columns is not None:
      value = pprint.pformat(self.columns, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    columns=%s' % (value))
    if self.schema_prop is not None:
      value = pprint.pformat(self.schema_prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_prop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IdName:
  """
  Attributes:
   - id
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.id = ID()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IdName')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 1)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SpaceDesc:
  """
  Attributes:
   - space_name
   - partition_num
   - replica_factor
   - charset_name
   - collate_name
   - vid_type
   - zone_names
   - isolation_level
   - comment
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.partition_num = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.replica_factor = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.charset_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.collate_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.vid_type = ColumnTypeDef()
          self.vid_type.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.zone_names = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in range(_size8):
              _elem13 = iprot.readString()
              self.zone_names.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = iprot.readString()
              self.zone_names.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.isolation_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SpaceDesc')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.partition_num != None:
      oprot.writeFieldBegin('partition_num', TType.I32, 2)
      oprot.writeI32(self.partition_num)
      oprot.writeFieldEnd()
    if self.replica_factor != None:
      oprot.writeFieldBegin('replica_factor', TType.I32, 3)
      oprot.writeI32(self.replica_factor)
      oprot.writeFieldEnd()
    if self.charset_name != None:
      oprot.writeFieldBegin('charset_name', TType.STRING, 4)
      oprot.writeString(self.charset_name)
      oprot.writeFieldEnd()
    if self.collate_name != None:
      oprot.writeFieldBegin('collate_name', TType.STRING, 5)
      oprot.writeString(self.collate_name)
      oprot.writeFieldEnd()
    if self.vid_type != None:
      oprot.writeFieldBegin('vid_type', TType.STRUCT, 6)
      self.vid_type.write(oprot)
      oprot.writeFieldEnd()
    if self.zone_names != None:
      oprot.writeFieldBegin('zone_names', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.zone_names))
      for iter15 in self.zone_names:
        oprot.writeString(iter15)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.isolation_level != None:
      oprot.writeFieldBegin('isolation_level', TType.I32, 8)
      oprot.writeI32(self.isolation_level)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 9)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.partition_num is not None:
      value = pprint.pformat(self.partition_num, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    partition_num=%s' % (value))
    if self.replica_factor is not None:
      value = pprint.pformat(self.replica_factor, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    replica_factor=%s' % (value))
    if self.charset_name is not None:
      value = pprint.pformat(self.charset_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    charset_name=%s' % (value))
    if self.collate_name is not None:
      value = pprint.pformat(self.collate_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    collate_name=%s' % (value))
    if self.vid_type is not None:
      value = pprint.pformat(self.vid_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    vid_type=%s' % (value))
    if self.zone_names is not None:
      value = pprint.pformat(self.zone_names, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_names=%s' % (value))
    if self.isolation_level is not None:
      value = pprint.pformat(self.isolation_level, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    isolation_level=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SpaceItem:
  """
  Attributes:
   - space_id
   - properties
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.properties = SpaceDesc()
          self.properties.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SpaceItem')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.properties != None:
      oprot.writeFieldBegin('properties', TType.STRUCT, 2)
      self.properties.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.properties is not None:
      value = pprint.pformat(self.properties, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    properties=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TagItem:
  """
  Attributes:
   - tag_id
   - tag_name
   - version
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.tag_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TagItem')
    if self.tag_id != None:
      oprot.writeFieldBegin('tag_id', TType.I32, 1)
      oprot.writeI32(self.tag_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 4)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_id is not None:
      value = pprint.pformat(self.tag_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AlterSchemaItem:
  """
  Attributes:
   - op
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterSchemaItem')
    if self.op != None:
      oprot.writeFieldBegin('op', TType.I32, 1)
      oprot.writeI32(self.op)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 2)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.op is not None:
      value = pprint.pformat(self.op, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    op=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class EdgeItem:
  """
  Attributes:
   - edge_type
   - edge_name
   - version
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.edge_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('EdgeItem')
    if self.edge_type != None:
      oprot.writeFieldBegin('edge_type', TType.I32, 1)
      oprot.writeI32(self.edge_type)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 4)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.edge_type is not None:
      value = pprint.pformat(self.edge_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_type=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexParams:
  """
  Attributes:
   - s2_max_level
   - s2_max_cells
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.s2_max_level = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.s2_max_cells = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexParams')
    if self.s2_max_level != None:
      oprot.writeFieldBegin('s2_max_level', TType.I32, 1)
      oprot.writeI32(self.s2_max_level)
      oprot.writeFieldEnd()
    if self.s2_max_cells != None:
      oprot.writeFieldBegin('s2_max_cells', TType.I32, 2)
      oprot.writeI32(self.s2_max_cells)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.s2_max_level is not None:
      value = pprint.pformat(self.s2_max_level, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    s2_max_level=%s' % (value))
    if self.s2_max_cells is not None:
      value = pprint.pformat(self.s2_max_cells, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    s2_max_cells=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexItem:
  """
  Attributes:
   - index_id
   - index_name
   - schema_id
   - schema_name
   - fields
   - comment
   - index_params
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.index_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema_id = nebula3.common.ttypes.SchemaID()
          self.schema_id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.schema_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fields = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in range(_size16):
              _elem21 = ColumnDef()
              _elem21.read(iprot)
              self.fields.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = ColumnDef()
              _elem22.read(iprot)
              self.fields.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.index_params = IndexParams()
          self.index_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexItem')
    if self.index_id != None:
      oprot.writeFieldBegin('index_id', TType.I32, 1)
      oprot.writeI32(self.index_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.schema_id != None:
      oprot.writeFieldBegin('schema_id', TType.STRUCT, 3)
      self.schema_id.write(oprot)
      oprot.writeFieldEnd()
    if self.schema_name != None:
      oprot.writeFieldBegin('schema_name', TType.STRING, 4)
      oprot.writeString(self.schema_name)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter23 in self.fields:
        iter23.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 6)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.index_params != None:
      oprot.writeFieldBegin('index_params', TType.STRUCT, 7)
      self.index_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.index_id is not None:
      value = pprint.pformat(self.index_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.schema_id is not None:
      value = pprint.pformat(self.schema_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_id=%s' % (value))
    if self.schema_name is not None:
      value = pprint.pformat(self.schema_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_name=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    if self.index_params is not None:
      value = pprint.pformat(self.index_params, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_params=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class HostItem:
  """
  Attributes:
   - hostAddr
   - status
   - leader_parts
   - all_parts
   - role
   - git_info_sha
   - zone_name
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.hostAddr = nebula3.common.ttypes.HostAddr()
          self.hostAddr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.leader_parts = {}
          (_ktype25, _vtype26, _size24 ) = iprot.readMapBegin() 
          if _size24 >= 0:
            for _i28 in range(_size24):
              _key29 = iprot.readString()
              _val30 = []
              (_etype34, _size31) = iprot.readListBegin()
              if _size31 >= 0:
                for _i35 in range(_size31):
                  _elem36 = iprot.readI32()
                  _val30.append(_elem36)
              else: 
                while iprot.peekList():
                  _elem37 = iprot.readI32()
                  _val30.append(_elem37)
              iprot.readListEnd()
              self.leader_parts[_key29] = _val30
          else: 
            while iprot.peekMap():
              _key38 = iprot.readString()
              _val39 = []
              (_etype43, _size40) = iprot.readListBegin()
              if _size40 >= 0:
                for _i44 in range(_size40):
                  _elem45 = iprot.readI32()
                  _val39.append(_elem45)
              else: 
                while iprot.peekList():
                  _elem46 = iprot.readI32()
                  _val39.append(_elem46)
              iprot.readListEnd()
              self.leader_parts[_key38] = _val39
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.all_parts = {}
          (_ktype48, _vtype49, _size47 ) = iprot.readMapBegin() 
          if _size47 >= 0:
            for _i51 in range(_size47):
              _key52 = iprot.readString()
              _val53 = []
              (_etype57, _size54) = iprot.readListBegin()
              if _size54 >= 0:
                for _i58 in range(_size54):
                  _elem59 = iprot.readI32()
                  _val53.append(_elem59)
              else: 
                while iprot.peekList():
                  _elem60 = iprot.readI32()
                  _val53.append(_elem60)
              iprot.readListEnd()
              self.all_parts[_key52] = _val53
          else: 
            while iprot.peekMap():
              _key61 = iprot.readString()
              _val62 = []
              (_etype66, _size63) = iprot.readListBegin()
              if _size63 >= 0:
                for _i67 in range(_size63):
                  _elem68 = iprot.readI32()
                  _val62.append(_elem68)
              else: 
                while iprot.peekList():
                  _elem69 = iprot.readI32()
                  _val62.append(_elem69)
              iprot.readListEnd()
              self.all_parts[_key61] = _val62
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.role = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.git_info_sha = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostItem')
    if self.hostAddr != None:
      oprot.writeFieldBegin('hostAddr', TType.STRUCT, 1)
      self.hostAddr.write(oprot)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.leader_parts != None:
      oprot.writeFieldBegin('leader_parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.leader_parts))
      for kiter70,viter71 in self.leader_parts.items():
        oprot.writeString(kiter70)
        oprot.writeListBegin(TType.I32, len(viter71))
        for iter72 in viter71:
          oprot.writeI32(iter72)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.all_parts != None:
      oprot.writeFieldBegin('all_parts', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.all_parts))
      for kiter73,viter74 in self.all_parts.items():
        oprot.writeString(kiter73)
        oprot.writeListBegin(TType.I32, len(viter74))
        for iter75 in viter74:
          oprot.writeI32(iter75)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.role != None:
      oprot.writeFieldBegin('role', TType.I32, 5)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.git_info_sha != None:
      oprot.writeFieldBegin('git_info_sha', TType.STRING, 6)
      oprot.writeString(self.git_info_sha)
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 7)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.STRING, 8)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hostAddr is not None:
      value = pprint.pformat(self.hostAddr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hostAddr=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.leader_parts is not None:
      value = pprint.pformat(self.leader_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_parts=%s' % (value))
    if self.all_parts is not None:
      value = pprint.pformat(self.all_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    all_parts=%s' % (value))
    if self.role is not None:
      value = pprint.pformat(self.role, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role=%s' % (value))
    if self.git_info_sha is not None:
      value = pprint.pformat(self.git_info_sha, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    git_info_sha=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UserItem:
  """
  Attributes:
   - account
   - is_lock
   - max_queries_per_hour
   - max_updates_per_hour
   - max_connections_per_hour
   - max_user_connections
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.is_lock = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_queries_per_hour = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.max_updates_per_hour = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.max_connections_per_hour = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.max_user_connections = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UserItem')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.is_lock != None:
      oprot.writeFieldBegin('is_lock', TType.BOOL, 2)
      oprot.writeBool(self.is_lock)
      oprot.writeFieldEnd()
    if self.max_queries_per_hour != None:
      oprot.writeFieldBegin('max_queries_per_hour', TType.I32, 3)
      oprot.writeI32(self.max_queries_per_hour)
      oprot.writeFieldEnd()
    if self.max_updates_per_hour != None:
      oprot.writeFieldBegin('max_updates_per_hour', TType.I32, 4)
      oprot.writeI32(self.max_updates_per_hour)
      oprot.writeFieldEnd()
    if self.max_connections_per_hour != None:
      oprot.writeFieldBegin('max_connections_per_hour', TType.I32, 5)
      oprot.writeI32(self.max_connections_per_hour)
      oprot.writeFieldEnd()
    if self.max_user_connections != None:
      oprot.writeFieldBegin('max_user_connections', TType.I32, 6)
      oprot.writeI32(self.max_user_connections)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.is_lock is not None:
      value = pprint.pformat(self.is_lock, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_lock=%s' % (value))
    if self.max_queries_per_hour is not None:
      value = pprint.pformat(self.max_queries_per_hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_queries_per_hour=%s' % (value))
    if self.max_updates_per_hour is not None:
      value = pprint.pformat(self.max_updates_per_hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_updates_per_hour=%s' % (value))
    if self.max_connections_per_hour is not None:
      value = pprint.pformat(self.max_connections_per_hour, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_connections_per_hour=%s' % (value))
    if self.max_user_connections is not None:
      value = pprint.pformat(self.max_user_connections, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    max_user_connections=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RoleItem:
  """
  Attributes:
   - user_id
   - space_id
   - role_type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user_id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.role_type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RoleItem')
    if self.user_id != None:
      oprot.writeFieldBegin('user_id', TType.STRING, 1)
      oprot.writeString(self.user_id)
      oprot.writeFieldEnd()
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 2)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.role_type != None:
      oprot.writeFieldBegin('role_type', TType.I32, 3)
      oprot.writeI32(self.role_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.user_id is not None:
      value = pprint.pformat(self.user_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user_id=%s' % (value))
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.role_type is not None:
      value = pprint.pformat(self.role_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role_type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ExecResp:
  """
  Attributes:
   - code
   - id
   - leader
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.id = ID()
          self.id.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ExecResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRUCT, 2)
      self.id.write(oprot)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 3)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AlterSpaceReq:
  """
  Attributes:
   - space_name
   - op
   - paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.op = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.paras = []
          (_etype79, _size76) = iprot.readListBegin()
          if _size76 >= 0:
            for _i80 in range(_size76):
              _elem81 = iprot.readString()
              self.paras.append(_elem81)
          else: 
            while iprot.peekList():
              _elem82 = iprot.readString()
              self.paras.append(_elem82)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterSpaceReq')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.op != None:
      oprot.writeFieldBegin('op', TType.I32, 2)
      oprot.writeI32(self.op)
      oprot.writeFieldEnd()
    if self.paras != None:
      oprot.writeFieldBegin('paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.paras))
      for iter83 in self.paras:
        oprot.writeString(iter83)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.op is not None:
      value = pprint.pformat(self.op, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    op=%s' % (value))
    if self.paras is not None:
      value = pprint.pformat(self.paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AdminJobReq:
  """
  Attributes:
   - op
   - cmd
   - paras
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.paras = []
          (_etype87, _size84) = iprot.readListBegin()
          if _size84 >= 0:
            for _i88 in range(_size84):
              _elem89 = iprot.readString()
              self.paras.append(_elem89)
          else: 
            while iprot.peekList():
              _elem90 = iprot.readString()
              self.paras.append(_elem90)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminJobReq')
    if self.op != None:
      oprot.writeFieldBegin('op', TType.I32, 1)
      oprot.writeI32(self.op)
      oprot.writeFieldEnd()
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 2)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.paras != None:
      oprot.writeFieldBegin('paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.paras))
      for iter91 in self.paras:
        oprot.writeString(iter91)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.op is not None:
      value = pprint.pformat(self.op, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    op=%s' % (value))
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.paras is not None:
      value = pprint.pformat(self.paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    paras=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class JobDesc:
  """
  Attributes:
   - id
   - cmd
   - paras
   - status
   - start_time
   - stop_time
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.paras = []
          (_etype95, _size92) = iprot.readListBegin()
          if _size92 >= 0:
            for _i96 in range(_size92):
              _elem97 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.paras.append(_elem97)
          else: 
            while iprot.peekList():
              _elem98 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.paras.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.stop_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('JobDesc')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I32, 1)
      oprot.writeI32(self.id)
      oprot.writeFieldEnd()
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 2)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.paras != None:
      oprot.writeFieldBegin('paras', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.paras))
      for iter99 in self.paras:
        oprot.writeString(iter99.encode('utf-8')) if UTF8STRINGS and not isinstance(iter99, bytes) else oprot.writeString(iter99)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 5)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.stop_time != None:
      oprot.writeFieldBegin('stop_time', TType.I64, 6)
      oprot.writeI64(self.stop_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.cmd is not None:
      value = pprint.pformat(self.cmd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cmd=%s' % (value))
    if self.paras is not None:
      value = pprint.pformat(self.paras, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    paras=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.stop_time is not None:
      value = pprint.pformat(self.stop_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stop_time=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class TaskDesc:
  """
  Attributes:
   - task_id
   - host
   - status
   - start_time
   - stop_time
   - job_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.stop_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TaskDesc')
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 1)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 3)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 4)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.stop_time != None:
      oprot.writeFieldBegin('stop_time', TType.I64, 5)
      oprot.writeI64(self.stop_time)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 6)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.stop_time is not None:
      value = pprint.pformat(self.stop_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stop_time=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AdminJobResult:
  """
  Attributes:
   - job_id
   - job_desc
   - task_desc
   - recovered_job_num
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.job_desc = []
          (_etype103, _size100) = iprot.readListBegin()
          if _size100 >= 0:
            for _i104 in range(_size100):
              _elem105 = JobDesc()
              _elem105.read(iprot)
              self.job_desc.append(_elem105)
          else: 
            while iprot.peekList():
              _elem106 = JobDesc()
              _elem106.read(iprot)
              self.job_desc.append(_elem106)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.task_desc = []
          (_etype110, _size107) = iprot.readListBegin()
          if _size107 >= 0:
            for _i111 in range(_size107):
              _elem112 = TaskDesc()
              _elem112.read(iprot)
              self.task_desc.append(_elem112)
          else: 
            while iprot.peekList():
              _elem113 = TaskDesc()
              _elem113.read(iprot)
              self.task_desc.append(_elem113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.recovered_job_num = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminJobResult')
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 1)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.job_desc != None:
      oprot.writeFieldBegin('job_desc', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.job_desc))
      for iter114 in self.job_desc:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.task_desc != None:
      oprot.writeFieldBegin('task_desc', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.task_desc))
      for iter115 in self.task_desc:
        iter115.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.recovered_job_num != None:
      oprot.writeFieldBegin('recovered_job_num', TType.I32, 4)
      oprot.writeI32(self.recovered_job_num)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.job_desc is not None:
      value = pprint.pformat(self.job_desc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_desc=%s' % (value))
    if self.task_desc is not None:
      value = pprint.pformat(self.task_desc, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_desc=%s' % (value))
    if self.recovered_job_num is not None:
      value = pprint.pformat(self.recovered_job_num, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    recovered_job_num=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AdminJobResp:
  """
  Attributes:
   - code
   - leader
   - result
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.result = AdminJobResult()
          self.result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdminJobResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.result != None:
      oprot.writeFieldBegin('result', TType.STRUCT, 3)
      self.result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Correlativity:
  """
  Attributes:
   - part_id
   - proportion
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.proportion = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Correlativity')
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 1)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.proportion != None:
      oprot.writeFieldBegin('proportion', TType.DOUBLE, 2)
      oprot.writeDouble(self.proportion)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.proportion is not None:
      value = pprint.pformat(self.proportion, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    proportion=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class StatsItem:
  """
  Attributes:
   - tag_vertices
   - edges
   - space_vertices
   - space_edges
   - positive_part_correlativity
   - negative_part_correlativity
   - status
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.tag_vertices = {}
          (_ktype117, _vtype118, _size116 ) = iprot.readMapBegin() 
          if _size116 >= 0:
            for _i120 in range(_size116):
              _key121 = iprot.readString()
              _val122 = iprot.readI64()
              self.tag_vertices[_key121] = _val122
          else: 
            while iprot.peekMap():
              _key123 = iprot.readString()
              _val124 = iprot.readI64()
              self.tag_vertices[_key123] = _val124
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.edges = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin() 
          if _size125 >= 0:
            for _i129 in range(_size125):
              _key130 = iprot.readString()
              _val131 = iprot.readI64()
              self.edges[_key130] = _val131
          else: 
            while iprot.peekMap():
              _key132 = iprot.readString()
              _val133 = iprot.readI64()
              self.edges[_key132] = _val133
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.space_vertices = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.space_edges = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.positive_part_correlativity = {}
          (_ktype135, _vtype136, _size134 ) = iprot.readMapBegin() 
          if _size134 >= 0:
            for _i138 in range(_size134):
              _key139 = iprot.readI32()
              _val140 = []
              (_etype144, _size141) = iprot.readListBegin()
              if _size141 >= 0:
                for _i145 in range(_size141):
                  _elem146 = Correlativity()
                  _elem146.read(iprot)
                  _val140.append(_elem146)
              else: 
                while iprot.peekList():
                  _elem147 = Correlativity()
                  _elem147.read(iprot)
                  _val140.append(_elem147)
              iprot.readListEnd()
              self.positive_part_correlativity[_key139] = _val140
          else: 
            while iprot.peekMap():
              _key148 = iprot.readI32()
              _val149 = []
              (_etype153, _size150) = iprot.readListBegin()
              if _size150 >= 0:
                for _i154 in range(_size150):
                  _elem155 = Correlativity()
                  _elem155.read(iprot)
                  _val149.append(_elem155)
              else: 
                while iprot.peekList():
                  _elem156 = Correlativity()
                  _elem156.read(iprot)
                  _val149.append(_elem156)
              iprot.readListEnd()
              self.positive_part_correlativity[_key148] = _val149
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.negative_part_correlativity = {}
          (_ktype158, _vtype159, _size157 ) = iprot.readMapBegin() 
          if _size157 >= 0:
            for _i161 in range(_size157):
              _key162 = iprot.readI32()
              _val163 = []
              (_etype167, _size164) = iprot.readListBegin()
              if _size164 >= 0:
                for _i168 in range(_size164):
                  _elem169 = Correlativity()
                  _elem169.read(iprot)
                  _val163.append(_elem169)
              else: 
                while iprot.peekList():
                  _elem170 = Correlativity()
                  _elem170.read(iprot)
                  _val163.append(_elem170)
              iprot.readListEnd()
              self.negative_part_correlativity[_key162] = _val163
          else: 
            while iprot.peekMap():
              _key171 = iprot.readI32()
              _val172 = []
              (_etype176, _size173) = iprot.readListBegin()
              if _size173 >= 0:
                for _i177 in range(_size173):
                  _elem178 = Correlativity()
                  _elem178.read(iprot)
                  _val172.append(_elem178)
              else: 
                while iprot.peekList():
                  _elem179 = Correlativity()
                  _elem179.read(iprot)
                  _val172.append(_elem179)
              iprot.readListEnd()
              self.negative_part_correlativity[_key171] = _val172
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StatsItem')
    if self.tag_vertices != None:
      oprot.writeFieldBegin('tag_vertices', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.tag_vertices))
      for kiter180,viter181 in self.tag_vertices.items():
        oprot.writeString(kiter180)
        oprot.writeI64(viter181)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.edges != None:
      oprot.writeFieldBegin('edges', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.edges))
      for kiter182,viter183 in self.edges.items():
        oprot.writeString(kiter182)
        oprot.writeI64(viter183)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.space_vertices != None:
      oprot.writeFieldBegin('space_vertices', TType.I64, 3)
      oprot.writeI64(self.space_vertices)
      oprot.writeFieldEnd()
    if self.space_edges != None:
      oprot.writeFieldBegin('space_edges', TType.I64, 4)
      oprot.writeI64(self.space_edges)
      oprot.writeFieldEnd()
    if self.positive_part_correlativity != None:
      oprot.writeFieldBegin('positive_part_correlativity', TType.MAP, 5)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.positive_part_correlativity))
      for kiter184,viter185 in self.positive_part_correlativity.items():
        oprot.writeI32(kiter184)
        oprot.writeListBegin(TType.STRUCT, len(viter185))
        for iter186 in viter185:
          iter186.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.negative_part_correlativity != None:
      oprot.writeFieldBegin('negative_part_correlativity', TType.MAP, 6)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.negative_part_correlativity))
      for kiter187,viter188 in self.negative_part_correlativity.items():
        oprot.writeI32(kiter187)
        oprot.writeListBegin(TType.STRUCT, len(viter188))
        for iter189 in viter188:
          iter189.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 7)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.tag_vertices is not None:
      value = pprint.pformat(self.tag_vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_vertices=%s' % (value))
    if self.edges is not None:
      value = pprint.pformat(self.edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edges=%s' % (value))
    if self.space_vertices is not None:
      value = pprint.pformat(self.space_vertices, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_vertices=%s' % (value))
    if self.space_edges is not None:
      value = pprint.pformat(self.space_edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_edges=%s' % (value))
    if self.positive_part_correlativity is not None:
      value = pprint.pformat(self.positive_part_correlativity, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    positive_part_correlativity=%s' % (value))
    if self.negative_part_correlativity is not None:
      value = pprint.pformat(self.negative_part_correlativity, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    negative_part_correlativity=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateSpaceReq:
  """
  Attributes:
   - properties
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.properties = SpaceDesc()
          self.properties.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSpaceReq')
    if self.properties != None:
      oprot.writeFieldBegin('properties', TType.STRUCT, 1)
      self.properties.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.properties is not None:
      value = pprint.pformat(self.properties, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    properties=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateSpaceAsReq:
  """
  Attributes:
   - old_space_name
   - new_space_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.old_space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.new_space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSpaceAsReq')
    if self.old_space_name != None:
      oprot.writeFieldBegin('old_space_name', TType.STRING, 1)
      oprot.writeString(self.old_space_name)
      oprot.writeFieldEnd()
    if self.new_space_name != None:
      oprot.writeFieldBegin('new_space_name', TType.STRING, 2)
      oprot.writeString(self.new_space_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.old_space_name is not None:
      value = pprint.pformat(self.old_space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    old_space_name=%s' % (value))
    if self.new_space_name is not None:
      value = pprint.pformat(self.new_space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_space_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropSpaceReq:
  """
  Attributes:
   - space_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropSpaceReq')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListSpacesReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSpacesReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListSpacesResp:
  """
  Attributes:
   - code
   - leader
   - spaces
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.spaces = []
          (_etype193, _size190) = iprot.readListBegin()
          if _size190 >= 0:
            for _i194 in range(_size190):
              _elem195 = IdName()
              _elem195.read(iprot)
              self.spaces.append(_elem195)
          else: 
            while iprot.peekList():
              _elem196 = IdName()
              _elem196.read(iprot)
              self.spaces.append(_elem196)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSpacesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.spaces != None:
      oprot.writeFieldBegin('spaces', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.spaces))
      for iter197 in self.spaces:
        iter197.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.spaces is not None:
      value = pprint.pformat(self.spaces, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    spaces=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetSpaceReq:
  """
  Attributes:
   - space_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSpaceReq')
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 1)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetSpaceResp:
  """
  Attributes:
   - code
   - leader
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = SpaceItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSpaceResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - schema
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AlterTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - tag_items
   - schema_prop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tag_items = []
          (_etype201, _size198) = iprot.readListBegin()
          if _size198 >= 0:
            for _i202 in range(_size198):
              _elem203 = AlterSchemaItem()
              _elem203.read(iprot)
              self.tag_items.append(_elem203)
          else: 
            while iprot.peekList():
              _elem204 = AlterSchemaItem()
              _elem204.read(iprot)
              self.tag_items.append(_elem204)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema_prop = SchemaProp()
          self.schema_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.tag_items != None:
      oprot.writeFieldBegin('tag_items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tag_items))
      for iter205 in self.tag_items:
        iter205.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_prop != None:
      oprot.writeFieldBegin('schema_prop', TType.STRUCT, 4)
      self.schema_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.tag_items is not None:
      value = pprint.pformat(self.tag_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_items=%s' % (value))
    if self.schema_prop is not None:
      value = pprint.pformat(self.schema_prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_prop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListTagsReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagsReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListTagsResp:
  """
  Attributes:
   - code
   - leader
   - tags
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tags = []
          (_etype209, _size206) = iprot.readListBegin()
          if _size206 >= 0:
            for _i210 in range(_size206):
              _elem211 = TagItem()
              _elem211.read(iprot)
              self.tags.append(_elem211)
          else: 
            while iprot.peekList():
              _elem212 = TagItem()
              _elem212.read(iprot)
              self.tags.append(_elem212)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.tags != None:
      oprot.writeFieldBegin('tags', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tags))
      for iter213 in self.tags:
        iter213.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.tags is not None:
      value = pprint.pformat(self.tags, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tags=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetTagReq:
  """
  Attributes:
   - space_id
   - tag_name
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 2)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetTagResp:
  """
  Attributes:
   - code
   - leader
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - schema
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AlterEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - edge_items
   - schema_prop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edge_items = []
          (_etype217, _size214) = iprot.readListBegin()
          if _size214 >= 0:
            for _i218 in range(_size214):
              _elem219 = AlterSchemaItem()
              _elem219.read(iprot)
              self.edge_items.append(_elem219)
          else: 
            while iprot.peekList():
              _elem220 = AlterSchemaItem()
              _elem220.read(iprot)
              self.edge_items.append(_elem220)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.schema_prop = SchemaProp()
          self.schema_prop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.edge_items != None:
      oprot.writeFieldBegin('edge_items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edge_items))
      for iter221 in self.edge_items:
        iter221.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.schema_prop != None:
      oprot.writeFieldBegin('schema_prop', TType.STRUCT, 4)
      self.schema_prop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.edge_items is not None:
      value = pprint.pformat(self.edge_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_items=%s' % (value))
    if self.schema_prop is not None:
      value = pprint.pformat(self.schema_prop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema_prop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 3)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetEdgeResp:
  """
  Attributes:
   - code
   - leader
   - schema
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.schema = Schema()
          self.schema.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.schema != None:
      oprot.writeFieldBegin('schema', TType.STRUCT, 3)
      self.schema.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.schema is not None:
      value = pprint.pformat(self.schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    schema=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropEdgeReq:
  """
  Attributes:
   - space_id
   - edge_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropEdgeReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 2)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListEdgesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListEdgesResp:
  """
  Attributes:
   - code
   - leader
   - edges
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.edges = []
          (_etype225, _size222) = iprot.readListBegin()
          if _size222 >= 0:
            for _i226 in range(_size222):
              _elem227 = EdgeItem()
              _elem227.read(iprot)
              self.edges.append(_elem227)
          else: 
            while iprot.peekList():
              _elem228 = EdgeItem()
              _elem228.read(iprot)
              self.edges.append(_elem228)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.edges != None:
      oprot.writeFieldBegin('edges', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.edges))
      for iter229 in self.edges:
        iter229.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.edges is not None:
      value = pprint.pformat(self.edges, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edges=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddHostsReq:
  """
  Attributes:
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype233, _size230) = iprot.readListBegin()
          if _size230 >= 0:
            for _i234 in range(_size230):
              _elem235 = nebula3.common.ttypes.HostAddr()
              _elem235.read(iprot)
              self.hosts.append(_elem235)
          else: 
            while iprot.peekList():
              _elem236 = nebula3.common.ttypes.HostAddr()
              _elem236.read(iprot)
              self.hosts.append(_elem236)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddHostsReq')
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter237 in self.hosts:
        iter237.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropHostsReq:
  """
  Attributes:
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype241, _size238) = iprot.readListBegin()
          if _size238 >= 0:
            for _i242 in range(_size238):
              _elem243 = nebula3.common.ttypes.HostAddr()
              _elem243.read(iprot)
              self.hosts.append(_elem243)
          else: 
            while iprot.peekList():
              _elem244 = nebula3.common.ttypes.HostAddr()
              _elem244.read(iprot)
              self.hosts.append(_elem244)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropHostsReq')
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter245 in self.hosts:
        iter245.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListHostsReq:
  """
  Attributes:
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListHostsReq')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListHostsResp:
  """
  Attributes:
   - code
   - leader
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype249, _size246) = iprot.readListBegin()
          if _size246 >= 0:
            for _i250 in range(_size246):
              _elem251 = HostItem()
              _elem251.read(iprot)
              self.hosts.append(_elem251)
          else: 
            while iprot.peekList():
              _elem252 = HostItem()
              _elem252.read(iprot)
              self.hosts.append(_elem252)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListHostsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter253 in self.hosts:
        iter253.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PartItem:
  """
  Attributes:
   - part_id
   - leader
   - peers
   - losts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.peers = []
          (_etype257, _size254) = iprot.readListBegin()
          if _size254 >= 0:
            for _i258 in range(_size254):
              _elem259 = nebula3.common.ttypes.HostAddr()
              _elem259.read(iprot)
              self.peers.append(_elem259)
          else: 
            while iprot.peekList():
              _elem260 = nebula3.common.ttypes.HostAddr()
              _elem260.read(iprot)
              self.peers.append(_elem260)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.losts = []
          (_etype264, _size261) = iprot.readListBegin()
          if _size261 >= 0:
            for _i265 in range(_size261):
              _elem266 = nebula3.common.ttypes.HostAddr()
              _elem266.read(iprot)
              self.losts.append(_elem266)
          else: 
            while iprot.peekList():
              _elem267 = nebula3.common.ttypes.HostAddr()
              _elem267.read(iprot)
              self.losts.append(_elem267)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartItem')
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 1)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.peers))
      for iter268 in self.peers:
        iter268.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.losts != None:
      oprot.writeFieldBegin('losts', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.losts))
      for iter269 in self.losts:
        iter269.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.peers is not None:
      value = pprint.pformat(self.peers, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    peers=%s' % (value))
    if self.losts is not None:
      value = pprint.pformat(self.losts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    losts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListPartsReq:
  """
  Attributes:
   - space_id
   - part_ids
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.part_ids = []
          (_etype273, _size270) = iprot.readListBegin()
          if _size270 >= 0:
            for _i274 in range(_size270):
              _elem275 = iprot.readI32()
              self.part_ids.append(_elem275)
          else: 
            while iprot.peekList():
              _elem276 = iprot.readI32()
              self.part_ids.append(_elem276)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListPartsReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.part_ids != None:
      oprot.writeFieldBegin('part_ids', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.part_ids))
      for iter277 in self.part_ids:
        oprot.writeI32(iter277)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.part_ids is not None:
      value = pprint.pformat(self.part_ids, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_ids=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListPartsResp:
  """
  Attributes:
   - code
   - leader
   - parts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.parts = []
          (_etype281, _size278) = iprot.readListBegin()
          if _size278 >= 0:
            for _i282 in range(_size278):
              _elem283 = PartItem()
              _elem283.read(iprot)
              self.parts.append(_elem283)
          else: 
            while iprot.peekList():
              _elem284 = PartItem()
              _elem284.read(iprot)
              self.parts.append(_elem284)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListPartsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.parts))
      for iter285 in self.parts:
        iter285.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetPartsAllocReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPartsAllocReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetPartsAllocResp:
  """
  Attributes:
   - code
   - leader
   - parts
   - terms
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parts = {}
          (_ktype287, _vtype288, _size286 ) = iprot.readMapBegin() 
          if _size286 >= 0:
            for _i290 in range(_size286):
              _key291 = iprot.readI32()
              _val292 = []
              (_etype296, _size293) = iprot.readListBegin()
              if _size293 >= 0:
                for _i297 in range(_size293):
                  _elem298 = nebula3.common.ttypes.HostAddr()
                  _elem298.read(iprot)
                  _val292.append(_elem298)
              else: 
                while iprot.peekList():
                  _elem299 = nebula3.common.ttypes.HostAddr()
                  _elem299.read(iprot)
                  _val292.append(_elem299)
              iprot.readListEnd()
              self.parts[_key291] = _val292
          else: 
            while iprot.peekMap():
              _key300 = iprot.readI32()
              _val301 = []
              (_etype305, _size302) = iprot.readListBegin()
              if _size302 >= 0:
                for _i306 in range(_size302):
                  _elem307 = nebula3.common.ttypes.HostAddr()
                  _elem307.read(iprot)
                  _val301.append(_elem307)
              else: 
                while iprot.peekList():
                  _elem308 = nebula3.common.ttypes.HostAddr()
                  _elem308.read(iprot)
                  _val301.append(_elem308)
              iprot.readListEnd()
              self.parts[_key300] = _val301
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.terms = {}
          (_ktype310, _vtype311, _size309 ) = iprot.readMapBegin() 
          if _size309 >= 0:
            for _i313 in range(_size309):
              _key314 = iprot.readI32()
              _val315 = iprot.readI64()
              self.terms[_key314] = _val315
          else: 
            while iprot.peekMap():
              _key316 = iprot.readI32()
              _val317 = iprot.readI64()
              self.terms[_key316] = _val317
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetPartsAllocResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.parts != None:
      oprot.writeFieldBegin('parts', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.parts))
      for kiter318,viter319 in self.parts.items():
        oprot.writeI32(kiter318)
        oprot.writeListBegin(TType.STRUCT, len(viter319))
        for iter320 in viter319:
          iter320.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.terms != None:
      oprot.writeFieldBegin('terms', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.I64, len(self.terms))
      for kiter321,viter322 in self.terms.items():
        oprot.writeI32(kiter321)
        oprot.writeI64(viter322)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.parts is not None:
      value = pprint.pformat(self.parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    parts=%s' % (value))
    if self.terms is not None:
      value = pprint.pformat(self.terms, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terms=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetWorkerIdReq:
  """
  Attributes:
   - host
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.host = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetWorkerIdReq')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRING, 1)
      oprot.writeString(self.host)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetWorkerIdResp:
  """
  Attributes:
   - code
   - leader
   - workerid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.workerid = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetWorkerIdResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.workerid != None:
      oprot.writeFieldBegin('workerid', TType.I64, 3)
      oprot.writeI64(self.workerid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.workerid is not None:
      value = pprint.pformat(self.workerid, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    workerid=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class MultiPutReq:
  """
  Attributes:
   - segment
   - pairs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.pairs = []
          (_etype326, _size323) = iprot.readListBegin()
          if _size323 >= 0:
            for _i327 in range(_size323):
              _elem328 = nebula3.common.ttypes.KeyValue()
              _elem328.read(iprot)
              self.pairs.append(_elem328)
          else: 
            while iprot.peekList():
              _elem329 = nebula3.common.ttypes.KeyValue()
              _elem329.read(iprot)
              self.pairs.append(_elem329)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MultiPutReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.pairs != None:
      oprot.writeFieldBegin('pairs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.pairs))
      for iter330 in self.pairs:
        iter330.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.pairs is not None:
      value = pprint.pformat(self.pairs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    pairs=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetReq:
  """
  Attributes:
   - segment
   - key
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetResp:
  """
  Attributes:
   - code
   - leader
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class MultiGetReq:
  """
  Attributes:
   - segment
   - keys
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.keys = []
          (_etype334, _size331) = iprot.readListBegin()
          if _size331 >= 0:
            for _i335 in range(_size331):
              _elem336 = iprot.readString()
              self.keys.append(_elem336)
          else: 
            while iprot.peekList():
              _elem337 = iprot.readString()
              self.keys.append(_elem337)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MultiGetReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.keys != None:
      oprot.writeFieldBegin('keys', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter338 in self.keys:
        oprot.writeString(iter338)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.keys is not None:
      value = pprint.pformat(self.keys, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    keys=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class MultiGetResp:
  """
  Attributes:
   - code
   - leader
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype342, _size339) = iprot.readListBegin()
          if _size339 >= 0:
            for _i343 in range(_size339):
              _elem344 = iprot.readString()
              self.values.append(_elem344)
          else: 
            while iprot.peekList():
              _elem345 = iprot.readString()
              self.values.append(_elem345)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MultiGetResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter346 in self.values:
        oprot.writeString(iter346)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RemoveReq:
  """
  Attributes:
   - segment
   - key
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.key is not None:
      value = pprint.pformat(self.key, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    key=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RemoveRangeReq:
  """
  Attributes:
   - segment
   - start
   - end
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.end = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveRangeReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.end != None:
      oprot.writeFieldBegin('end', TType.STRING, 3)
      oprot.writeString(self.end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.start is not None:
      value = pprint.pformat(self.start, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start=%s' % (value))
    if self.end is not None:
      value = pprint.pformat(self.end, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanReq:
  """
  Attributes:
   - segment
   - start
   - end
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.segment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.start = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.end = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanReq')
    if self.segment != None:
      oprot.writeFieldBegin('segment', TType.STRING, 1)
      oprot.writeString(self.segment)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.STRING, 2)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.end != None:
      oprot.writeFieldBegin('end', TType.STRING, 3)
      oprot.writeString(self.end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.segment is not None:
      value = pprint.pformat(self.segment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    segment=%s' % (value))
    if self.start is not None:
      value = pprint.pformat(self.start, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start=%s' % (value))
    if self.end is not None:
      value = pprint.pformat(self.end, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    end=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ScanResp:
  """
  Attributes:
   - code
   - leader
   - values
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.values = []
          (_etype350, _size347) = iprot.readListBegin()
          if _size347 >= 0:
            for _i351 in range(_size347):
              _elem352 = iprot.readString()
              self.values.append(_elem352)
          else: 
            while iprot.peekList():
              _elem353 = iprot.readString()
              self.values.append(_elem353)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ScanResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.values != None:
      oprot.writeFieldBegin('values', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.values))
      for iter354 in self.values:
        oprot.writeString(iter354)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.values is not None:
      value = pprint.pformat(self.values, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    values=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class HBResp:
  """
  Attributes:
   - code
   - leader
   - cluster_id
   - last_update_time_in_ms
   - meta_version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.cluster_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.last_update_time_in_ms = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.meta_version = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HBResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.cluster_id != None:
      oprot.writeFieldBegin('cluster_id', TType.I64, 3)
      oprot.writeI64(self.cluster_id)
      oprot.writeFieldEnd()
    if self.last_update_time_in_ms != None:
      oprot.writeFieldBegin('last_update_time_in_ms', TType.I64, 4)
      oprot.writeI64(self.last_update_time_in_ms)
      oprot.writeFieldEnd()
    if self.meta_version != None:
      oprot.writeFieldBegin('meta_version', TType.I32, 5)
      oprot.writeI32(self.meta_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.cluster_id is not None:
      value = pprint.pformat(self.cluster_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cluster_id=%s' % (value))
    if self.last_update_time_in_ms is not None:
      value = pprint.pformat(self.last_update_time_in_ms, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    last_update_time_in_ms=%s' % (value))
    if self.meta_version is not None:
      value = pprint.pformat(self.meta_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    meta_version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class LeaderInfo:
  """
  Attributes:
   - part_id
   - term
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.term = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LeaderInfo')
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 1)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.term != None:
      oprot.writeFieldBegin('term', TType.I64, 2)
      oprot.writeI64(self.term)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.term is not None:
      value = pprint.pformat(self.term, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    term=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class PartitionList:
  """
  Attributes:
   - part_list
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.part_list = []
          (_etype358, _size355) = iprot.readListBegin()
          if _size355 >= 0:
            for _i359 in range(_size355):
              _elem360 = iprot.readI32()
              self.part_list.append(_elem360)
          else: 
            while iprot.peekList():
              _elem361 = iprot.readI32()
              self.part_list.append(_elem361)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PartitionList')
    if self.part_list != None:
      oprot.writeFieldBegin('part_list', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.part_list))
      for iter362 in self.part_list:
        oprot.writeI32(iter362)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.part_list is not None:
      value = pprint.pformat(self.part_list, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_list=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class HBReq:
  """
  Attributes:
   - role
   - host
   - cluster_id
   - leader_partIds
   - git_info_sha
   - disk_parts
   - dir
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.role = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.cluster_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.leader_partIds = {}
          (_ktype364, _vtype365, _size363 ) = iprot.readMapBegin() 
          if _size363 >= 0:
            for _i367 in range(_size363):
              _key368 = iprot.readI32()
              _val369 = []
              (_etype373, _size370) = iprot.readListBegin()
              if _size370 >= 0:
                for _i374 in range(_size370):
                  _elem375 = LeaderInfo()
                  _elem375.read(iprot)
                  _val369.append(_elem375)
              else: 
                while iprot.peekList():
                  _elem376 = LeaderInfo()
                  _elem376.read(iprot)
                  _val369.append(_elem376)
              iprot.readListEnd()
              self.leader_partIds[_key368] = _val369
          else: 
            while iprot.peekMap():
              _key377 = iprot.readI32()
              _val378 = []
              (_etype382, _size379) = iprot.readListBegin()
              if _size379 >= 0:
                for _i383 in range(_size379):
                  _elem384 = LeaderInfo()
                  _elem384.read(iprot)
                  _val378.append(_elem384)
              else: 
                while iprot.peekList():
                  _elem385 = LeaderInfo()
                  _elem385.read(iprot)
                  _val378.append(_elem385)
              iprot.readListEnd()
              self.leader_partIds[_key377] = _val378
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.git_info_sha = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.disk_parts = {}
          (_ktype387, _vtype388, _size386 ) = iprot.readMapBegin() 
          if _size386 >= 0:
            for _i390 in range(_size386):
              _key391 = iprot.readI32()
              _val392 = {}
              (_ktype394, _vtype395, _size393 ) = iprot.readMapBegin() 
              if _size393 >= 0:
                for _i397 in range(_size393):
                  _key398 = iprot.readString()
                  _val399 = PartitionList()
                  _val399.read(iprot)
                  _val392[_key398] = _val399
              else: 
                while iprot.peekMap():
                  _key400 = iprot.readString()
                  _val401 = PartitionList()
                  _val401.read(iprot)
                  _val392[_key400] = _val401
              iprot.readMapEnd()
              self.disk_parts[_key391] = _val392
          else: 
            while iprot.peekMap():
              _key402 = iprot.readI32()
              _val403 = {}
              (_ktype405, _vtype406, _size404 ) = iprot.readMapBegin() 
              if _size404 >= 0:
                for _i408 in range(_size404):
                  _key409 = iprot.readString()
                  _val410 = PartitionList()
                  _val410.read(iprot)
                  _val403[_key409] = _val410
              else: 
                while iprot.peekMap():
                  _key411 = iprot.readString()
                  _val412 = PartitionList()
                  _val412.read(iprot)
                  _val403[_key411] = _val412
              iprot.readMapEnd()
              self.disk_parts[_key402] = _val403
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.dir = nebula3.common.ttypes.DirInfo()
          self.dir.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HBReq')
    if self.role != None:
      oprot.writeFieldBegin('role', TType.I32, 1)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.cluster_id != None:
      oprot.writeFieldBegin('cluster_id', TType.I64, 3)
      oprot.writeI64(self.cluster_id)
      oprot.writeFieldEnd()
    if self.leader_partIds != None:
      oprot.writeFieldBegin('leader_partIds', TType.MAP, 4)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.leader_partIds))
      for kiter413,viter414 in self.leader_partIds.items():
        oprot.writeI32(kiter413)
        oprot.writeListBegin(TType.STRUCT, len(viter414))
        for iter415 in viter414:
          iter415.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.git_info_sha != None:
      oprot.writeFieldBegin('git_info_sha', TType.STRING, 5)
      oprot.writeString(self.git_info_sha)
      oprot.writeFieldEnd()
    if self.disk_parts != None:
      oprot.writeFieldBegin('disk_parts', TType.MAP, 6)
      oprot.writeMapBegin(TType.I32, TType.MAP, len(self.disk_parts))
      for kiter416,viter417 in self.disk_parts.items():
        oprot.writeI32(kiter416)
        oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(viter417))
        for kiter418,viter419 in viter417.items():
          oprot.writeString(kiter418)
          viter419.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.dir != None:
      oprot.writeFieldBegin('dir', TType.STRUCT, 7)
      self.dir.write(oprot)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.STRING, 8)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.role is not None:
      value = pprint.pformat(self.role, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.cluster_id is not None:
      value = pprint.pformat(self.cluster_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    cluster_id=%s' % (value))
    if self.leader_partIds is not None:
      value = pprint.pformat(self.leader_partIds, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader_partIds=%s' % (value))
    if self.git_info_sha is not None:
      value = pprint.pformat(self.git_info_sha, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    git_info_sha=%s' % (value))
    if self.disk_parts is not None:
      value = pprint.pformat(self.disk_parts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    disk_parts=%s' % (value))
    if self.dir is not None:
      value = pprint.pformat(self.dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dir=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ServiceInfo:
  """
  Attributes:
   - dir
   - addr
   - role
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dir = nebula3.common.ttypes.DirInfo()
          self.dir.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.addr = nebula3.common.ttypes.HostAddr()
          self.addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.role = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ServiceInfo')
    if self.dir != None:
      oprot.writeFieldBegin('dir', TType.STRUCT, 1)
      self.dir.write(oprot)
      oprot.writeFieldEnd()
    if self.addr != None:
      oprot.writeFieldBegin('addr', TType.STRUCT, 2)
      self.addr.write(oprot)
      oprot.writeFieldEnd()
    if self.role != None:
      oprot.writeFieldBegin('role', TType.I32, 3)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.dir is not None:
      value = pprint.pformat(self.dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dir=%s' % (value))
    if self.addr is not None:
      value = pprint.pformat(self.addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    addr=%s' % (value))
    if self.role is not None:
      value = pprint.pformat(self.role, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AgentHBReq:
  """
  Attributes:
   - host
   - git_info_sha
   - version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.git_info_sha = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AgentHBReq')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 1)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.git_info_sha != None:
      oprot.writeFieldBegin('git_info_sha', TType.STRING, 2)
      oprot.writeString(self.git_info_sha)
      oprot.writeFieldEnd()
    if self.version != None:
      oprot.writeFieldBegin('version', TType.STRING, 3)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.git_info_sha is not None:
      value = pprint.pformat(self.git_info_sha, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    git_info_sha=%s' % (value))
    if self.version is not None:
      value = pprint.pformat(self.version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AgentHBResp:
  """
  Attributes:
   - code
   - leader
   - service_list
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.service_list = []
          (_etype423, _size420) = iprot.readListBegin()
          if _size420 >= 0:
            for _i424 in range(_size420):
              _elem425 = ServiceInfo()
              _elem425.read(iprot)
              self.service_list.append(_elem425)
          else: 
            while iprot.peekList():
              _elem426 = ServiceInfo()
              _elem426.read(iprot)
              self.service_list.append(_elem426)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AgentHBResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.service_list != None:
      oprot.writeFieldBegin('service_list', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.service_list))
      for iter427 in self.service_list:
        iter427.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.service_list is not None:
      value = pprint.pformat(self.service_list, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    service_list=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexFieldDef:
  """
  Attributes:
   - name
   - type_length
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.type_length = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexFieldDef')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.type_length != None:
      oprot.writeFieldBegin('type_length', TType.I16, 2)
      oprot.writeI16(self.type_length)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.type_length is not None:
      value = pprint.pformat(self.type_length, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type_length=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateTagIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - tag_name
   - fields
   - if_not_exists
   - comment
   - index_params
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tag_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype431, _size428) = iprot.readListBegin()
          if _size428 >= 0:
            for _i432 in range(_size428):
              _elem433 = IndexFieldDef()
              _elem433.read(iprot)
              self.fields.append(_elem433)
          else: 
            while iprot.peekList():
              _elem434 = IndexFieldDef()
              _elem434.read(iprot)
              self.fields.append(_elem434)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.index_params = IndexParams()
          self.index_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateTagIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.tag_name != None:
      oprot.writeFieldBegin('tag_name', TType.STRING, 3)
      oprot.writeString(self.tag_name)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter435 in self.fields:
        iter435.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 5)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 6)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.index_params != None:
      oprot.writeFieldBegin('index_params', TType.STRUCT, 7)
      self.index_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.tag_name is not None:
      value = pprint.pformat(self.tag_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tag_name=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    if self.index_params is not None:
      value = pprint.pformat(self.index_params, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_params=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropTagIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropTagIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetTagIndexReq:
  """
  Attributes:
   - space_id
   - index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetTagIndexResp:
  """
  Attributes:
   - code
   - leader
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = IndexItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetTagIndexResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListTagIndexesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagIndexesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListTagIndexesResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype439, _size436) = iprot.readListBegin()
          if _size436 >= 0:
            for _i440 in range(_size436):
              _elem441 = IndexItem()
              _elem441.read(iprot)
              self.items.append(_elem441)
          else: 
            while iprot.peekList():
              _elem442 = IndexItem()
              _elem442.read(iprot)
              self.items.append(_elem442)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListTagIndexesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter443 in self.items:
        iter443.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateEdgeIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - edge_name
   - fields
   - if_not_exists
   - comment
   - index_params
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.edge_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fields = []
          (_etype447, _size444) = iprot.readListBegin()
          if _size444 >= 0:
            for _i448 in range(_size444):
              _elem449 = IndexFieldDef()
              _elem449.read(iprot)
              self.fields.append(_elem449)
          else: 
            while iprot.peekList():
              _elem450 = IndexFieldDef()
              _elem450.read(iprot)
              self.fields.append(_elem450)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.comment = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.index_params = IndexParams()
          self.index_params.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateEdgeIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.edge_name != None:
      oprot.writeFieldBegin('edge_name', TType.STRING, 3)
      oprot.writeString(self.edge_name)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.fields))
      for iter451 in self.fields:
        iter451.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 5)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    if self.comment != None:
      oprot.writeFieldBegin('comment', TType.STRING, 6)
      oprot.writeString(self.comment)
      oprot.writeFieldEnd()
    if self.index_params != None:
      oprot.writeFieldBegin('index_params', TType.STRUCT, 7)
      self.index_params.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.edge_name is not None:
      value = pprint.pformat(self.edge_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    edge_name=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    if self.comment is not None:
      value = pprint.pformat(self.comment, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    comment=%s' % (value))
    if self.index_params is not None:
      value = pprint.pformat(self.index_params, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_params=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropEdgeIndexReq:
  """
  Attributes:
   - space_id
   - index_name
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropEdgeIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetEdgeIndexReq:
  """
  Attributes:
   - space_id
   - index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetEdgeIndexResp:
  """
  Attributes:
   - code
   - leader
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.item = IndexItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetEdgeIndexResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 3)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListEdgeIndexesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgeIndexesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListEdgeIndexesResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype455, _size452) = iprot.readListBegin()
          if _size452 >= 0:
            for _i456 in range(_size452):
              _elem457 = IndexItem()
              _elem457.read(iprot)
              self.items.append(_elem457)
          else: 
            while iprot.peekList():
              _elem458 = IndexItem()
              _elem458.read(iprot)
              self.items.append(_elem458)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListEdgeIndexesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter459 in self.items:
        iter459.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RebuildIndexReq:
  """
  Attributes:
   - space_id
   - index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RebuildIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.index_name != None:
      oprot.writeFieldBegin('index_name', TType.STRING, 2)
      oprot.writeString(self.index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.index_name is not None:
      value = pprint.pformat(self.index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateUserReq:
  """
  Attributes:
   - account
   - encoded_pwd
   - if_not_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.if_not_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateUserReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.encoded_pwd != None:
      oprot.writeFieldBegin('encoded_pwd', TType.STRING, 2)
      oprot.writeString(self.encoded_pwd)
      oprot.writeFieldEnd()
    if self.if_not_exists != None:
      oprot.writeFieldBegin('if_not_exists', TType.BOOL, 3)
      oprot.writeBool(self.if_not_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.encoded_pwd is not None:
      value = pprint.pformat(self.encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    encoded_pwd=%s' % (value))
    if self.if_not_exists is not None:
      value = pprint.pformat(self.if_not_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_not_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropUserReq:
  """
  Attributes:
   - account
   - if_exists
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.if_exists = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropUserReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.if_exists != None:
      oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
      oprot.writeBool(self.if_exists)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.if_exists is not None:
      value = pprint.pformat(self.if_exists, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    if_exists=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AlterUserReq:
  """
  Attributes:
   - account
   - encoded_pwd
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlterUserReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.encoded_pwd != None:
      oprot.writeFieldBegin('encoded_pwd', TType.STRING, 2)
      oprot.writeString(self.encoded_pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.encoded_pwd is not None:
      value = pprint.pformat(self.encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    encoded_pwd=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GrantRoleReq:
  """
  Attributes:
   - role_item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role_item = RoleItem()
          self.role_item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GrantRoleReq')
    if self.role_item != None:
      oprot.writeFieldBegin('role_item', TType.STRUCT, 1)
      self.role_item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.role_item is not None:
      value = pprint.pformat(self.role_item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role_item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RevokeRoleReq:
  """
  Attributes:
   - role_item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.role_item = RoleItem()
          self.role_item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RevokeRoleReq')
    if self.role_item != None:
      oprot.writeFieldBegin('role_item', TType.STRUCT, 1)
      self.role_item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.role_item is not None:
      value = pprint.pformat(self.role_item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    role_item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListUsersReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListUsersReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListUsersResp:
  """
  Attributes:
   - code
   - leader
   - users
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.users = {}
          (_ktype461, _vtype462, _size460 ) = iprot.readMapBegin() 
          if _size460 >= 0:
            for _i464 in range(_size460):
              _key465 = iprot.readString()
              _val466 = iprot.readString()
              self.users[_key465] = _val466
          else: 
            while iprot.peekMap():
              _key467 = iprot.readString()
              _val468 = iprot.readString()
              self.users[_key467] = _val468
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListUsersResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.users != None:
      oprot.writeFieldBegin('users', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.users))
      for kiter469,viter470 in self.users.items():
        oprot.writeString(kiter469)
        oprot.writeString(viter470)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.users is not None:
      value = pprint.pformat(self.users, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    users=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListRolesReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListRolesReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListRolesResp:
  """
  Attributes:
   - code
   - leader
   - roles
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.roles = []
          (_etype474, _size471) = iprot.readListBegin()
          if _size471 >= 0:
            for _i475 in range(_size471):
              _elem476 = RoleItem()
              _elem476.read(iprot)
              self.roles.append(_elem476)
          else: 
            while iprot.peekList():
              _elem477 = RoleItem()
              _elem477.read(iprot)
              self.roles.append(_elem477)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListRolesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.roles != None:
      oprot.writeFieldBegin('roles', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.roles))
      for iter478 in self.roles:
        iter478.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.roles is not None:
      value = pprint.pformat(self.roles, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    roles=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetUserRolesReq:
  """
  Attributes:
   - account
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetUserRolesReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ChangePasswordReq:
  """
  Attributes:
   - account
   - new_encoded_pwd
   - old_encoded_pwd
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.account = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.new_encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.old_encoded_pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ChangePasswordReq')
    if self.account != None:
      oprot.writeFieldBegin('account', TType.STRING, 1)
      oprot.writeString(self.account)
      oprot.writeFieldEnd()
    if self.new_encoded_pwd != None:
      oprot.writeFieldBegin('new_encoded_pwd', TType.STRING, 2)
      oprot.writeString(self.new_encoded_pwd)
      oprot.writeFieldEnd()
    if self.old_encoded_pwd != None:
      oprot.writeFieldBegin('old_encoded_pwd', TType.STRING, 3)
      oprot.writeString(self.old_encoded_pwd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.account is not None:
      value = pprint.pformat(self.account, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    account=%s' % (value))
    if self.new_encoded_pwd is not None:
      value = pprint.pformat(self.new_encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    new_encoded_pwd=%s' % (value))
    if self.old_encoded_pwd is not None:
      value = pprint.pformat(self.old_encoded_pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    old_encoded_pwd=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class BalanceTask:
  """
  Attributes:
   - id
   - command
   - result
   - start_time
   - stop_time
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.command = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.result = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.stop_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BalanceTask')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.STRING, 1)
      oprot.writeString(self.id)
      oprot.writeFieldEnd()
    if self.command != None:
      oprot.writeFieldBegin('command', TType.STRING, 2)
      oprot.writeString(self.command)
      oprot.writeFieldEnd()
    if self.result != None:
      oprot.writeFieldBegin('result', TType.I32, 3)
      oprot.writeI32(self.result)
      oprot.writeFieldEnd()
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 4)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.stop_time != None:
      oprot.writeFieldBegin('stop_time', TType.I64, 5)
      oprot.writeI64(self.stop_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.id is not None:
      value = pprint.pformat(self.id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    id=%s' % (value))
    if self.command is not None:
      value = pprint.pformat(self.command, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    command=%s' % (value))
    if self.result is not None:
      value = pprint.pformat(self.result, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    result=%s' % (value))
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.stop_time is not None:
      value = pprint.pformat(self.stop_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stop_time=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ConfigItem:
  """
  Attributes:
   - module
   - name
   - mode
   - value
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.module = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.mode = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.value = nebula3.common.ttypes.Value()
          self.value.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ConfigItem')
    if self.module != None:
      oprot.writeFieldBegin('module', TType.I32, 1)
      oprot.writeI32(self.module)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.mode != None:
      oprot.writeFieldBegin('mode', TType.I32, 3)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRUCT, 4)
      self.value.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.module is not None:
      value = pprint.pformat(self.module, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    module=%s' % (value))
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.mode is not None:
      value = pprint.pformat(self.mode, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mode=%s' % (value))
    if self.value is not None:
      value = pprint.pformat(self.value, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    value=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RegConfigReq:
  """
  Attributes:
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.items = []
          (_etype482, _size479) = iprot.readListBegin()
          if _size479 >= 0:
            for _i483 in range(_size479):
              _elem484 = ConfigItem()
              _elem484.read(iprot)
              self.items.append(_elem484)
          else: 
            while iprot.peekList():
              _elem485 = ConfigItem()
              _elem485.read(iprot)
              self.items.append(_elem485)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RegConfigReq')
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter486 in self.items:
        iter486.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetConfigReq:
  """
  Attributes:
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.item = ConfigItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetConfigReq')
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 1)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetConfigResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype490, _size487) = iprot.readListBegin()
          if _size487 >= 0:
            for _i491 in range(_size487):
              _elem492 = ConfigItem()
              _elem492.read(iprot)
              self.items.append(_elem492)
          else: 
            while iprot.peekList():
              _elem493 = ConfigItem()
              _elem493.read(iprot)
              self.items.append(_elem493)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetConfigResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter494 in self.items:
        iter494.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SetConfigReq:
  """
  Attributes:
   - item
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.item = ConfigItem()
          self.item.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SetConfigReq')
    if self.item != None:
      oprot.writeFieldBegin('item', TType.STRUCT, 1)
      self.item.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.item is not None:
      value = pprint.pformat(self.item, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    item=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListConfigsReq:
  """
  Attributes:
   - space
   - module
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.space = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.module = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListConfigsReq')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.STRING, 1)
      oprot.writeString(self.space)
      oprot.writeFieldEnd()
    if self.module != None:
      oprot.writeFieldBegin('module', TType.I32, 2)
      oprot.writeI32(self.module)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.module is not None:
      value = pprint.pformat(self.module, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    module=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListConfigsResp:
  """
  Attributes:
   - code
   - leader
   - items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.items = []
          (_etype498, _size495) = iprot.readListBegin()
          if _size495 >= 0:
            for _i499 in range(_size495):
              _elem500 = ConfigItem()
              _elem500.read(iprot)
              self.items.append(_elem500)
          else: 
            while iprot.peekList():
              _elem501 = ConfigItem()
              _elem501.read(iprot)
              self.items.append(_elem501)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListConfigsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.items != None:
      oprot.writeFieldBegin('items', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.items))
      for iter502 in self.items:
        iter502.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.items is not None:
      value = pprint.pformat(self.items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateSnapshotReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSnapshotReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropSnapshotReq:
  """
  Attributes:
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropSnapshotReq')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListSnapshotsReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSnapshotsReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Snapshot:
  """
  Attributes:
   - name
   - status
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.hosts = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Snapshot')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.STRING, 3)
      oprot.writeString(self.hosts)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListSnapshotsResp:
  """
  Attributes:
   - code
   - leader
   - snapshots
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.snapshots = []
          (_etype506, _size503) = iprot.readListBegin()
          if _size503 >= 0:
            for _i507 in range(_size503):
              _elem508 = Snapshot()
              _elem508.read(iprot)
              self.snapshots.append(_elem508)
          else: 
            while iprot.peekList():
              _elem509 = Snapshot()
              _elem509.read(iprot)
              self.snapshots.append(_elem509)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSnapshotsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.snapshots != None:
      oprot.writeFieldBegin('snapshots', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.snapshots))
      for iter510 in self.snapshots:
        iter510.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.snapshots is not None:
      value = pprint.pformat(self.snapshots, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    snapshots=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListIndexStatusReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListIndexStatusReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class IndexStatus:
  """
  Attributes:
   - name
   - status
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.status = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndexStatus')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.STRING, 2)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListIndexStatusResp:
  """
  Attributes:
   - code
   - leader
   - statuses
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.statuses = []
          (_etype514, _size511) = iprot.readListBegin()
          if _size511 >= 0:
            for _i515 in range(_size511):
              _elem516 = IndexStatus()
              _elem516.read(iprot)
              self.statuses.append(_elem516)
          else: 
            while iprot.peekList():
              _elem517 = IndexStatus()
              _elem517.read(iprot)
              self.statuses.append(_elem517)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListIndexStatusResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.statuses != None:
      oprot.writeFieldBegin('statuses', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.statuses))
      for iter518 in self.statuses:
        iter518.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.statuses is not None:
      value = pprint.pformat(self.statuses, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    statuses=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class MergeZoneReq:
  """
  Attributes:
   - zones
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.zones = []
          (_etype522, _size519) = iprot.readListBegin()
          if _size519 >= 0:
            for _i523 in range(_size519):
              _elem524 = iprot.readString()
              self.zones.append(_elem524)
          else: 
            while iprot.peekList():
              _elem525 = iprot.readString()
              self.zones.append(_elem525)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MergeZoneReq')
    if self.zones != None:
      oprot.writeFieldBegin('zones', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.zones))
      for iter526 in self.zones:
        oprot.writeString(iter526)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 2)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zones is not None:
      value = pprint.pformat(self.zones, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zones=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropZoneReq:
  """
  Attributes:
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropZoneReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DivideZoneReq:
  """
  Attributes:
   - zone_name
   - zone_items
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.zone_items = {}
          (_ktype528, _vtype529, _size527 ) = iprot.readMapBegin() 
          if _size527 >= 0:
            for _i531 in range(_size527):
              _key532 = iprot.readString()
              _val533 = []
              (_etype537, _size534) = iprot.readListBegin()
              if _size534 >= 0:
                for _i538 in range(_size534):
                  _elem539 = nebula3.common.ttypes.HostAddr()
                  _elem539.read(iprot)
                  _val533.append(_elem539)
              else: 
                while iprot.peekList():
                  _elem540 = nebula3.common.ttypes.HostAddr()
                  _elem540.read(iprot)
                  _val533.append(_elem540)
              iprot.readListEnd()
              self.zone_items[_key532] = _val533
          else: 
            while iprot.peekMap():
              _key541 = iprot.readString()
              _val542 = []
              (_etype546, _size543) = iprot.readListBegin()
              if _size543 >= 0:
                for _i547 in range(_size543):
                  _elem548 = nebula3.common.ttypes.HostAddr()
                  _elem548.read(iprot)
                  _val542.append(_elem548)
              else: 
                while iprot.peekList():
                  _elem549 = nebula3.common.ttypes.HostAddr()
                  _elem549.read(iprot)
                  _val542.append(_elem549)
              iprot.readListEnd()
              self.zone_items[_key541] = _val542
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DivideZoneReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.zone_items != None:
      oprot.writeFieldBegin('zone_items', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.zone_items))
      for kiter550,viter551 in self.zone_items.items():
        oprot.writeString(kiter550)
        oprot.writeListBegin(TType.STRUCT, len(viter551))
        for iter552 in viter551:
          iter552.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.zone_items is not None:
      value = pprint.pformat(self.zone_items, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_items=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RenameZoneReq:
  """
  Attributes:
   - original_zone_name
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.original_zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RenameZoneReq')
    if self.original_zone_name != None:
      oprot.writeFieldBegin('original_zone_name', TType.STRING, 1)
      oprot.writeString(self.original_zone_name)
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 2)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.original_zone_name is not None:
      value = pprint.pformat(self.original_zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    original_zone_name=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddHostsIntoZoneReq:
  """
  Attributes:
   - hosts
   - zone_name
   - is_new
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype556, _size553) = iprot.readListBegin()
          if _size553 >= 0:
            for _i557 in range(_size553):
              _elem558 = nebula3.common.ttypes.HostAddr()
              _elem558.read(iprot)
              self.hosts.append(_elem558)
          else: 
            while iprot.peekList():
              _elem559 = nebula3.common.ttypes.HostAddr()
              _elem559.read(iprot)
              self.hosts.append(_elem559)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_new = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddHostsIntoZoneReq')
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter560 in self.hosts:
        iter560.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 2)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.is_new != None:
      oprot.writeFieldBegin('is_new', TType.BOOL, 3)
      oprot.writeBool(self.is_new)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.is_new is not None:
      value = pprint.pformat(self.is_new, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    is_new=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetZoneReq:
  """
  Attributes:
   - zone_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetZoneReq')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetZoneResp:
  """
  Attributes:
   - code
   - leader
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype564, _size561) = iprot.readListBegin()
          if _size561 >= 0:
            for _i565 in range(_size561):
              _elem566 = nebula3.common.ttypes.HostAddr()
              _elem566.read(iprot)
              self.hosts.append(_elem566)
          else: 
            while iprot.peekList():
              _elem567 = nebula3.common.ttypes.HostAddr()
              _elem567.read(iprot)
              self.hosts.append(_elem567)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetZoneResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter568 in self.hosts:
        iter568.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListZonesReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListZonesReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Zone:
  """
  Attributes:
   - zone_name
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zone_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nodes = []
          (_etype572, _size569) = iprot.readListBegin()
          if _size569 >= 0:
            for _i573 in range(_size569):
              _elem574 = nebula3.common.ttypes.HostAddr()
              _elem574.read(iprot)
              self.nodes.append(_elem574)
          else: 
            while iprot.peekList():
              _elem575 = nebula3.common.ttypes.HostAddr()
              _elem575.read(iprot)
              self.nodes.append(_elem575)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Zone')
    if self.zone_name != None:
      oprot.writeFieldBegin('zone_name', TType.STRING, 1)
      oprot.writeString(self.zone_name)
      oprot.writeFieldEnd()
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.nodes))
      for iter576 in self.nodes:
        iter576.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.zone_name is not None:
      value = pprint.pformat(self.zone_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zone_name=%s' % (value))
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListZonesResp:
  """
  Attributes:
   - code
   - leader
   - zones
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.zones = []
          (_etype580, _size577) = iprot.readListBegin()
          if _size577 >= 0:
            for _i581 in range(_size577):
              _elem582 = Zone()
              _elem582.read(iprot)
              self.zones.append(_elem582)
          else: 
            while iprot.peekList():
              _elem583 = Zone()
              _elem583.read(iprot)
              self.zones.append(_elem583)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListZonesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.zones != None:
      oprot.writeFieldBegin('zones', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.zones))
      for iter584 in self.zones:
        iter584.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.zones is not None:
      value = pprint.pformat(self.zones, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    zones=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class AddListenerReq:
  """
  Attributes:
   - space_id
   - type
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype588, _size585) = iprot.readListBegin()
          if _size585 >= 0:
            for _i589 in range(_size585):
              _elem590 = nebula3.common.ttypes.HostAddr()
              _elem590.read(iprot)
              self.hosts.append(_elem590)
          else: 
            while iprot.peekList():
              _elem591 = nebula3.common.ttypes.HostAddr()
              _elem591.read(iprot)
              self.hosts.append(_elem591)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddListenerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter592 in self.hosts:
        iter592.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RemoveListenerReq:
  """
  Attributes:
   - space_id
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveListenerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListListenerReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListListenerReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListenerInfo:
  """
  Attributes:
   - type
   - host
   - part_id
   - status
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.part_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListenerInfo')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.part_id != None:
      oprot.writeFieldBegin('part_id', TType.I32, 3)
      oprot.writeI32(self.part_id)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 4)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.part_id is not None:
      value = pprint.pformat(self.part_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    part_id=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListListenerResp:
  """
  Attributes:
   - code
   - leader
   - listeners
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.listeners = []
          (_etype596, _size593) = iprot.readListBegin()
          if _size593 >= 0:
            for _i597 in range(_size593):
              _elem598 = ListenerInfo()
              _elem598.read(iprot)
              self.listeners.append(_elem598)
          else: 
            while iprot.peekList():
              _elem599 = ListenerInfo()
              _elem599.read(iprot)
              self.listeners.append(_elem599)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListListenerResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.listeners != None:
      oprot.writeFieldBegin('listeners', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.listeners))
      for iter600 in self.listeners:
        iter600.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.listeners is not None:
      value = pprint.pformat(self.listeners, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listeners=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetStatsReq:
  """
  Attributes:
   - space_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetStatsReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetStatsResp:
  """
  Attributes:
   - code
   - leader
   - stats
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.stats = StatsItem()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetStatsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.stats != None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 3)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.stats is not None:
      value = pprint.pformat(self.stats, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stats=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class HostBackupInfo:
  """
  Attributes:
   - host
   - checkpoints
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.checkpoints = []
          (_etype604, _size601) = iprot.readListBegin()
          if _size601 >= 0:
            for _i605 in range(_size601):
              _elem606 = nebula3.common.ttypes.CheckpointInfo()
              _elem606.read(iprot)
              self.checkpoints.append(_elem606)
          else: 
            while iprot.peekList():
              _elem607 = nebula3.common.ttypes.CheckpointInfo()
              _elem607.read(iprot)
              self.checkpoints.append(_elem607)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostBackupInfo')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 1)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.checkpoints != None:
      oprot.writeFieldBegin('checkpoints', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.checkpoints))
      for iter608 in self.checkpoints:
        iter608.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.checkpoints is not None:
      value = pprint.pformat(self.checkpoints, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    checkpoints=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SpaceBackupInfo:
  """
  Attributes:
   - space
   - host_backups
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.space = SpaceDesc()
          self.space.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.host_backups = []
          (_etype612, _size609) = iprot.readListBegin()
          if _size609 >= 0:
            for _i613 in range(_size609):
              _elem614 = HostBackupInfo()
              _elem614.read(iprot)
              self.host_backups.append(_elem614)
          else: 
            while iprot.peekList():
              _elem615 = HostBackupInfo()
              _elem615.read(iprot)
              self.host_backups.append(_elem615)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SpaceBackupInfo')
    if self.space != None:
      oprot.writeFieldBegin('space', TType.STRUCT, 1)
      self.space.write(oprot)
      oprot.writeFieldEnd()
    if self.host_backups != None:
      oprot.writeFieldBegin('host_backups', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.host_backups))
      for iter616 in self.host_backups:
        iter616.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space is not None:
      value = pprint.pformat(self.space, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space=%s' % (value))
    if self.host_backups is not None:
      value = pprint.pformat(self.host_backups, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host_backups=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class BackupMeta:
  """
  Attributes:
   - space_backups
   - meta_files
   - backup_name
   - full
   - all_spaces
   - create_time
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.space_backups = {}
          (_ktype618, _vtype619, _size617 ) = iprot.readMapBegin() 
          if _size617 >= 0:
            for _i621 in range(_size617):
              _key622 = iprot.readI32()
              _val623 = SpaceBackupInfo()
              _val623.read(iprot)
              self.space_backups[_key622] = _val623
          else: 
            while iprot.peekMap():
              _key624 = iprot.readI32()
              _val625 = SpaceBackupInfo()
              _val625.read(iprot)
              self.space_backups[_key624] = _val625
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.meta_files = []
          (_etype629, _size626) = iprot.readListBegin()
          if _size626 >= 0:
            for _i630 in range(_size626):
              _elem631 = iprot.readString()
              self.meta_files.append(_elem631)
          else: 
            while iprot.peekList():
              _elem632 = iprot.readString()
              self.meta_files.append(_elem632)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.backup_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.full = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.all_spaces = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.create_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BackupMeta')
    if self.space_backups != None:
      oprot.writeFieldBegin('space_backups', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.space_backups))
      for kiter633,viter634 in self.space_backups.items():
        oprot.writeI32(kiter633)
        viter634.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.meta_files != None:
      oprot.writeFieldBegin('meta_files', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.meta_files))
      for iter635 in self.meta_files:
        oprot.writeString(iter635)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.backup_name != None:
      oprot.writeFieldBegin('backup_name', TType.STRING, 3)
      oprot.writeString(self.backup_name)
      oprot.writeFieldEnd()
    if self.full != None:
      oprot.writeFieldBegin('full', TType.BOOL, 4)
      oprot.writeBool(self.full)
      oprot.writeFieldEnd()
    if self.all_spaces != None:
      oprot.writeFieldBegin('all_spaces', TType.BOOL, 5)
      oprot.writeBool(self.all_spaces)
      oprot.writeFieldEnd()
    if self.create_time != None:
      oprot.writeFieldBegin('create_time', TType.I64, 6)
      oprot.writeI64(self.create_time)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_backups is not None:
      value = pprint.pformat(self.space_backups, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_backups=%s' % (value))
    if self.meta_files is not None:
      value = pprint.pformat(self.meta_files, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    meta_files=%s' % (value))
    if self.backup_name is not None:
      value = pprint.pformat(self.backup_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    backup_name=%s' % (value))
    if self.full is not None:
      value = pprint.pformat(self.full, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    full=%s' % (value))
    if self.all_spaces is not None:
      value = pprint.pformat(self.all_spaces, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    all_spaces=%s' % (value))
    if self.create_time is not None:
      value = pprint.pformat(self.create_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    create_time=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateBackupReq:
  """
  Attributes:
   - spaces
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.spaces = []
          (_etype639, _size636) = iprot.readListBegin()
          if _size636 >= 0:
            for _i640 in range(_size636):
              _elem641 = iprot.readString()
              self.spaces.append(_elem641)
          else: 
            while iprot.peekList():
              _elem642 = iprot.readString()
              self.spaces.append(_elem642)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateBackupReq')
    if self.spaces != None:
      oprot.writeFieldBegin('spaces', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.spaces))
      for iter643 in self.spaces:
        oprot.writeString(iter643)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.spaces is not None:
      value = pprint.pformat(self.spaces, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    spaces=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateBackupResp:
  """
  Attributes:
   - code
   - leader
   - meta
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.meta = BackupMeta()
          self.meta.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateBackupResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.meta != None:
      oprot.writeFieldBegin('meta', TType.STRUCT, 3)
      self.meta.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.meta is not None:
      value = pprint.pformat(self.meta, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    meta=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class HostPair:
  """
  Attributes:
   - from_host
   - to_host
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.from_host = nebula3.common.ttypes.HostAddr()
          self.from_host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.to_host = nebula3.common.ttypes.HostAddr()
          self.to_host.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HostPair')
    if self.from_host != None:
      oprot.writeFieldBegin('from_host', TType.STRUCT, 1)
      self.from_host.write(oprot)
      oprot.writeFieldEnd()
    if self.to_host != None:
      oprot.writeFieldBegin('to_host', TType.STRUCT, 2)
      self.to_host.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.from_host is not None:
      value = pprint.pformat(self.from_host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    from_host=%s' % (value))
    if self.to_host is not None:
      value = pprint.pformat(self.to_host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    to_host=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RestoreMetaReq:
  """
  Attributes:
   - files
   - hosts
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.files = []
          (_etype647, _size644) = iprot.readListBegin()
          if _size644 >= 0:
            for _i648 in range(_size644):
              _elem649 = iprot.readString()
              self.files.append(_elem649)
          else: 
            while iprot.peekList():
              _elem650 = iprot.readString()
              self.files.append(_elem650)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.hosts = []
          (_etype654, _size651) = iprot.readListBegin()
          if _size651 >= 0:
            for _i655 in range(_size651):
              _elem656 = HostPair()
              _elem656.read(iprot)
              self.hosts.append(_elem656)
          else: 
            while iprot.peekList():
              _elem657 = HostPair()
              _elem657.read(iprot)
              self.hosts.append(_elem657)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RestoreMetaReq')
    if self.files != None:
      oprot.writeFieldBegin('files', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.files))
      for iter658 in self.files:
        oprot.writeString(iter658)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.hosts != None:
      oprot.writeFieldBegin('hosts', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.hosts))
      for iter659 in self.hosts:
        iter659.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.files is not None:
      value = pprint.pformat(self.files, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    files=%s' % (value))
    if self.hosts is not None:
      value = pprint.pformat(self.hosts, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    hosts=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ServiceClient:
  """
  Attributes:
   - host
   - user
   - pwd
   - conn_type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.pwd = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.conn_type = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ServiceClient')
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 1)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.user != None:
      oprot.writeFieldBegin('user', TType.STRING, 2)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.pwd != None:
      oprot.writeFieldBegin('pwd', TType.STRING, 3)
      oprot.writeString(self.pwd)
      oprot.writeFieldEnd()
    if self.conn_type != None:
      oprot.writeFieldBegin('conn_type', TType.STRING, 4)
      oprot.writeString(self.conn_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.user is not None:
      value = pprint.pformat(self.user, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user=%s' % (value))
    if self.pwd is not None:
      value = pprint.pformat(self.pwd, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    pwd=%s' % (value))
    if self.conn_type is not None:
      value = pprint.pformat(self.conn_type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    conn_type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SignInServiceReq:
  """
  Attributes:
   - type
   - clients
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.clients = []
          (_etype663, _size660) = iprot.readListBegin()
          if _size660 >= 0:
            for _i664 in range(_size660):
              _elem665 = ServiceClient()
              _elem665.read(iprot)
              self.clients.append(_elem665)
          else: 
            while iprot.peekList():
              _elem666 = ServiceClient()
              _elem666.read(iprot)
              self.clients.append(_elem666)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SignInServiceReq')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.clients != None:
      oprot.writeFieldBegin('clients', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.clients))
      for iter667 in self.clients:
        iter667.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    if self.clients is not None:
      value = pprint.pformat(self.clients, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clients=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class SignOutServiceReq:
  """
  Attributes:
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SignOutServiceReq')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListServiceClientsReq:
  """
  Attributes:
   - type
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListServiceClientsReq')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.type is not None:
      value = pprint.pformat(self.type, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    type=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListServiceClientsResp:
  """
  Attributes:
   - code
   - leader
   - clients
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.clients = {}
          (_ktype669, _vtype670, _size668 ) = iprot.readMapBegin() 
          if _size668 >= 0:
            for _i672 in range(_size668):
              _key673 = iprot.readI32()
              _val674 = []
              (_etype678, _size675) = iprot.readListBegin()
              if _size675 >= 0:
                for _i679 in range(_size675):
                  _elem680 = ServiceClient()
                  _elem680.read(iprot)
                  _val674.append(_elem680)
              else: 
                while iprot.peekList():
                  _elem681 = ServiceClient()
                  _elem681.read(iprot)
                  _val674.append(_elem681)
              iprot.readListEnd()
              self.clients[_key673] = _val674
          else: 
            while iprot.peekMap():
              _key682 = iprot.readI32()
              _val683 = []
              (_etype687, _size684) = iprot.readListBegin()
              if _size684 >= 0:
                for _i688 in range(_size684):
                  _elem689 = ServiceClient()
                  _elem689.read(iprot)
                  _val683.append(_elem689)
              else: 
                while iprot.peekList():
                  _elem690 = ServiceClient()
                  _elem690.read(iprot)
                  _val683.append(_elem690)
              iprot.readListEnd()
              self.clients[_key682] = _val683
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListServiceClientsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.clients != None:
      oprot.writeFieldBegin('clients', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.LIST, len(self.clients))
      for kiter691,viter692 in self.clients.items():
        oprot.writeI32(kiter691)
        oprot.writeListBegin(TType.STRUCT, len(viter692))
        for iter693 in viter692:
          iter693.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.clients is not None:
      value = pprint.pformat(self.clients, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clients=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class FTIndex:
  """
  Attributes:
   - space_id
   - depend_schema
   - fields
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.depend_schema = nebula3.common.ttypes.SchemaID()
          self.depend_schema.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fields = []
          (_etype697, _size694) = iprot.readListBegin()
          if _size694 >= 0:
            for _i698 in range(_size694):
              _elem699 = iprot.readString()
              self.fields.append(_elem699)
          else: 
            while iprot.peekList():
              _elem700 = iprot.readString()
              self.fields.append(_elem700)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FTIndex')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.depend_schema != None:
      oprot.writeFieldBegin('depend_schema', TType.STRUCT, 2)
      self.depend_schema.write(oprot)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.fields))
      for iter701 in self.fields:
        oprot.writeString(iter701)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.depend_schema is not None:
      value = pprint.pformat(self.depend_schema, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    depend_schema=%s' % (value))
    if self.fields is not None:
      value = pprint.pformat(self.fields, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fields=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateFTIndexReq:
  """
  Attributes:
   - fulltext_index_name
   - index
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.fulltext_index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.index = FTIndex()
          self.index.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateFTIndexReq')
    if self.fulltext_index_name != None:
      oprot.writeFieldBegin('fulltext_index_name', TType.STRING, 1)
      oprot.writeString(self.fulltext_index_name)
      oprot.writeFieldEnd()
    if self.index != None:
      oprot.writeFieldBegin('index', TType.STRUCT, 2)
      self.index.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.fulltext_index_name is not None:
      value = pprint.pformat(self.fulltext_index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fulltext_index_name=%s' % (value))
    if self.index is not None:
      value = pprint.pformat(self.index, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    index=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class DropFTIndexReq:
  """
  Attributes:
   - space_id
   - fulltext_index_name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.space_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fulltext_index_name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DropFTIndexReq')
    if self.space_id != None:
      oprot.writeFieldBegin('space_id', TType.I32, 1)
      oprot.writeI32(self.space_id)
      oprot.writeFieldEnd()
    if self.fulltext_index_name != None:
      oprot.writeFieldBegin('fulltext_index_name', TType.STRING, 2)
      oprot.writeString(self.fulltext_index_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.space_id is not None:
      value = pprint.pformat(self.space_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_id=%s' % (value))
    if self.fulltext_index_name is not None:
      value = pprint.pformat(self.fulltext_index_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fulltext_index_name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListFTIndexesReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListFTIndexesReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListFTIndexesResp:
  """
  Attributes:
   - code
   - leader
   - indexes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.indexes = {}
          (_ktype703, _vtype704, _size702 ) = iprot.readMapBegin() 
          if _size702 >= 0:
            for _i706 in range(_size702):
              _key707 = iprot.readString()
              _val708 = FTIndex()
              _val708.read(iprot)
              self.indexes[_key707] = _val708
          else: 
            while iprot.peekMap():
              _key709 = iprot.readString()
              _val710 = FTIndex()
              _val710.read(iprot)
              self.indexes[_key709] = _val710
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListFTIndexesResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.indexes != None:
      oprot.writeFieldBegin('indexes', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.indexes))
      for kiter711,viter712 in self.indexes.items():
        oprot.writeString(kiter711)
        viter712.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.indexes is not None:
      value = pprint.pformat(self.indexes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indexes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class QueryDesc:
  """
  Attributes:
   - start_time
   - status
   - duration
   - query
   - graph_addr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.start_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.status = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.duration = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.query = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.graph_addr = nebula3.common.ttypes.HostAddr()
          self.graph_addr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('QueryDesc')
    if self.start_time != None:
      oprot.writeFieldBegin('start_time', TType.I64, 1)
      oprot.writeI64(self.start_time)
      oprot.writeFieldEnd()
    if self.status != None:
      oprot.writeFieldBegin('status', TType.I32, 2)
      oprot.writeI32(self.status)
      oprot.writeFieldEnd()
    if self.duration != None:
      oprot.writeFieldBegin('duration', TType.I64, 3)
      oprot.writeI64(self.duration)
      oprot.writeFieldEnd()
    if self.query != None:
      oprot.writeFieldBegin('query', TType.STRING, 4)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.graph_addr != None:
      oprot.writeFieldBegin('graph_addr', TType.STRUCT, 5)
      self.graph_addr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.start_time is not None:
      value = pprint.pformat(self.start_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    start_time=%s' % (value))
    if self.status is not None:
      value = pprint.pformat(self.status, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    status=%s' % (value))
    if self.duration is not None:
      value = pprint.pformat(self.duration, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    duration=%s' % (value))
    if self.query is not None:
      value = pprint.pformat(self.query, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    query=%s' % (value))
    if self.graph_addr is not None:
      value = pprint.pformat(self.graph_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    graph_addr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class Session:
  """
  Attributes:
   - session_id
   - create_time
   - update_time
   - user_name
   - space_name
   - graph_addr
   - timezone
   - client_ip
   - configs
   - queries
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.create_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.update_time = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.user_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.space_name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.graph_addr = nebula3.common.ttypes.HostAddr()
          self.graph_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.timezone = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.configs = {}
          (_ktype714, _vtype715, _size713 ) = iprot.readMapBegin() 
          if _size713 >= 0:
            for _i717 in range(_size713):
              _key718 = iprot.readString()
              _val719 = nebula3.common.ttypes.Value()
              _val719.read(iprot)
              self.configs[_key718] = _val719
          else: 
            while iprot.peekMap():
              _key720 = iprot.readString()
              _val721 = nebula3.common.ttypes.Value()
              _val721.read(iprot)
              self.configs[_key720] = _val721
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.queries = {}
          (_ktype723, _vtype724, _size722 ) = iprot.readMapBegin() 
          if _size722 >= 0:
            for _i726 in range(_size722):
              _key727 = iprot.readI64()
              _val728 = QueryDesc()
              _val728.read(iprot)
              self.queries[_key727] = _val728
          else: 
            while iprot.peekMap():
              _key729 = iprot.readI64()
              _val730 = QueryDesc()
              _val730.read(iprot)
              self.queries[_key729] = _val730
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Session')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    if self.create_time != None:
      oprot.writeFieldBegin('create_time', TType.I64, 2)
      oprot.writeI64(self.create_time)
      oprot.writeFieldEnd()
    if self.update_time != None:
      oprot.writeFieldBegin('update_time', TType.I64, 3)
      oprot.writeI64(self.update_time)
      oprot.writeFieldEnd()
    if self.user_name != None:
      oprot.writeFieldBegin('user_name', TType.STRING, 4)
      oprot.writeString(self.user_name)
      oprot.writeFieldEnd()
    if self.space_name != None:
      oprot.writeFieldBegin('space_name', TType.STRING, 5)
      oprot.writeString(self.space_name)
      oprot.writeFieldEnd()
    if self.graph_addr != None:
      oprot.writeFieldBegin('graph_addr', TType.STRUCT, 6)
      self.graph_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.timezone != None:
      oprot.writeFieldBegin('timezone', TType.I32, 7)
      oprot.writeI32(self.timezone)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 8)
      oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    if self.configs != None:
      oprot.writeFieldBegin('configs', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.configs))
      for kiter731,viter732 in self.configs.items():
        oprot.writeString(kiter731)
        viter732.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.queries != None:
      oprot.writeFieldBegin('queries', TType.MAP, 10)
      oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.queries))
      for kiter733,viter734 in self.queries.items():
        oprot.writeI64(kiter733)
        viter734.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    if self.create_time is not None:
      value = pprint.pformat(self.create_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    create_time=%s' % (value))
    if self.update_time is not None:
      value = pprint.pformat(self.update_time, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    update_time=%s' % (value))
    if self.user_name is not None:
      value = pprint.pformat(self.user_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user_name=%s' % (value))
    if self.space_name is not None:
      value = pprint.pformat(self.space_name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    space_name=%s' % (value))
    if self.graph_addr is not None:
      value = pprint.pformat(self.graph_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    graph_addr=%s' % (value))
    if self.timezone is not None:
      value = pprint.pformat(self.timezone, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timezone=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    if self.configs is not None:
      value = pprint.pformat(self.configs, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    configs=%s' % (value))
    if self.queries is not None:
      value = pprint.pformat(self.queries, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    queries=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateSessionReq:
  """
  Attributes:
   - user
   - graph_addr
   - client_ip
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.user = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.graph_addr = nebula3.common.ttypes.HostAddr()
          self.graph_addr.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.client_ip = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSessionReq')
    if self.user != None:
      oprot.writeFieldBegin('user', TType.STRING, 1)
      oprot.writeString(self.user)
      oprot.writeFieldEnd()
    if self.graph_addr != None:
      oprot.writeFieldBegin('graph_addr', TType.STRUCT, 2)
      self.graph_addr.write(oprot)
      oprot.writeFieldEnd()
    if self.client_ip != None:
      oprot.writeFieldBegin('client_ip', TType.STRING, 3)
      oprot.writeString(self.client_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.user is not None:
      value = pprint.pformat(self.user, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    user=%s' % (value))
    if self.graph_addr is not None:
      value = pprint.pformat(self.graph_addr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    graph_addr=%s' % (value))
    if self.client_ip is not None:
      value = pprint.pformat(self.client_ip, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_ip=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class CreateSessionResp:
  """
  Attributes:
   - code
   - leader
   - session
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CreateSessionResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateSessionsReq:
  """
  Attributes:
   - sessions
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.sessions = []
          (_etype738, _size735) = iprot.readListBegin()
          if _size735 >= 0:
            for _i739 in range(_size735):
              _elem740 = Session()
              _elem740.read(iprot)
              self.sessions.append(_elem740)
          else: 
            while iprot.peekList():
              _elem741 = Session()
              _elem741.read(iprot)
              self.sessions.append(_elem741)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateSessionsReq')
    if self.sessions != None:
      oprot.writeFieldBegin('sessions', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.sessions))
      for iter742 in self.sessions:
        iter742.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessions is not None:
      value = pprint.pformat(self.sessions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessions=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class UpdateSessionsResp:
  """
  Attributes:
   - code
   - leader
   - killed_queries
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.killed_queries = {}
          (_ktype744, _vtype745, _size743 ) = iprot.readMapBegin() 
          if _size743 >= 0:
            for _i747 in range(_size743):
              _key748 = iprot.readI64()
              _val749 = {}
              (_ktype751, _vtype752, _size750 ) = iprot.readMapBegin() 
              if _size750 >= 0:
                for _i754 in range(_size750):
                  _key755 = iprot.readI64()
                  _val756 = QueryDesc()
                  _val756.read(iprot)
                  _val749[_key755] = _val756
              else: 
                while iprot.peekMap():
                  _key757 = iprot.readI64()
                  _val758 = QueryDesc()
                  _val758.read(iprot)
                  _val749[_key757] = _val758
              iprot.readMapEnd()
              self.killed_queries[_key748] = _val749
          else: 
            while iprot.peekMap():
              _key759 = iprot.readI64()
              _val760 = {}
              (_ktype762, _vtype763, _size761 ) = iprot.readMapBegin() 
              if _size761 >= 0:
                for _i765 in range(_size761):
                  _key766 = iprot.readI64()
                  _val767 = QueryDesc()
                  _val767.read(iprot)
                  _val760[_key766] = _val767
              else: 
                while iprot.peekMap():
                  _key768 = iprot.readI64()
                  _val769 = QueryDesc()
                  _val769.read(iprot)
                  _val760[_key768] = _val769
              iprot.readMapEnd()
              self.killed_queries[_key759] = _val760
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UpdateSessionsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.killed_queries != None:
      oprot.writeFieldBegin('killed_queries', TType.MAP, 3)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.killed_queries))
      for kiter770,viter771 in self.killed_queries.items():
        oprot.writeI64(kiter770)
        oprot.writeMapBegin(TType.I64, TType.STRUCT, len(viter771))
        for kiter772,viter773 in viter771.items():
          oprot.writeI64(kiter772)
          viter773.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.killed_queries is not None:
      value = pprint.pformat(self.killed_queries, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    killed_queries=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListSessionsReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSessionsReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListSessionsResp:
  """
  Attributes:
   - code
   - leader
   - sessions
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.sessions = []
          (_etype777, _size774) = iprot.readListBegin()
          if _size774 >= 0:
            for _i778 in range(_size774):
              _elem779 = Session()
              _elem779.read(iprot)
              self.sessions.append(_elem779)
          else: 
            while iprot.peekList():
              _elem780 = Session()
              _elem780.read(iprot)
              self.sessions.append(_elem780)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListSessionsResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.sessions != None:
      oprot.writeFieldBegin('sessions', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.sessions))
      for iter781 in self.sessions:
        iter781.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.sessions is not None:
      value = pprint.pformat(self.sessions, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessions=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetSessionReq:
  """
  Attributes:
   - session_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSessionReq')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetSessionResp:
  """
  Attributes:
   - code
   - leader
   - session
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.session = Session()
          self.session.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetSessionResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.session != None:
      oprot.writeFieldBegin('session', TType.STRUCT, 3)
      self.session.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.session is not None:
      value = pprint.pformat(self.session, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class RemoveSessionReq:
  """
  Attributes:
   - session_id
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.session_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RemoveSessionReq')
    if self.session_id != None:
      oprot.writeFieldBegin('session_id', TType.I64, 1)
      oprot.writeI64(self.session_id)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.session_id is not None:
      value = pprint.pformat(self.session_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    session_id=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class KillQueryReq:
  """
  Attributes:
   - kill_queries
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.kill_queries = {}
          (_ktype783, _vtype784, _size782 ) = iprot.readMapBegin() 
          if _size782 >= 0:
            for _i786 in range(_size782):
              _key787 = iprot.readI64()
              _val788 = set()
              (_etype792, _size789) = iprot.readSetBegin()
              if _size789 >= 0:
                for _i793 in range(_size789):
                  _elem794 = iprot.readI64()
                  _val788.add(_elem794)
              else: 
                while iprot.peekSet():
                  _elem795 = iprot.readI64()
                  _val788.add(_elem795)
              iprot.readSetEnd()
              self.kill_queries[_key787] = _val788
          else: 
            while iprot.peekMap():
              _key796 = iprot.readI64()
              _val797 = set()
              (_etype801, _size798) = iprot.readSetBegin()
              if _size798 >= 0:
                for _i802 in range(_size798):
                  _elem803 = iprot.readI64()
                  _val797.add(_elem803)
              else: 
                while iprot.peekSet():
                  _elem804 = iprot.readI64()
                  _val797.add(_elem804)
              iprot.readSetEnd()
              self.kill_queries[_key796] = _val797
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KillQueryReq')
    if self.kill_queries != None:
      oprot.writeFieldBegin('kill_queries', TType.MAP, 1)
      oprot.writeMapBegin(TType.I64, TType.SET, len(self.kill_queries))
      for kiter805,viter806 in self.kill_queries.items():
        oprot.writeI64(kiter805)
        oprot.writeSetBegin(TType.I64, len(viter806))
        for iter807 in viter806:
          oprot.writeI64(iter807)
        oprot.writeSetEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.kill_queries is not None:
      value = pprint.pformat(self.kill_queries, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    kill_queries=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ReportTaskReq:
  """
  Attributes:
   - code
   - job_id
   - task_id
   - stats
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.job_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.task_id = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.stats = StatsItem()
          self.stats.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ReportTaskReq')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.job_id != None:
      oprot.writeFieldBegin('job_id', TType.I32, 2)
      oprot.writeI32(self.job_id)
      oprot.writeFieldEnd()
    if self.task_id != None:
      oprot.writeFieldBegin('task_id', TType.I32, 3)
      oprot.writeI32(self.task_id)
      oprot.writeFieldEnd()
    if self.stats != None:
      oprot.writeFieldBegin('stats', TType.STRUCT, 4)
      self.stats.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.job_id is not None:
      value = pprint.pformat(self.job_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    job_id=%s' % (value))
    if self.task_id is not None:
      value = pprint.pformat(self.task_id, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    task_id=%s' % (value))
    if self.stats is not None:
      value = pprint.pformat(self.stats, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stats=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListClusterInfoResp:
  """
  Attributes:
   - code
   - leader
   - host_services
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.host_services = {}
          (_ktype809, _vtype810, _size808 ) = iprot.readMapBegin() 
          if _size808 >= 0:
            for _i812 in range(_size808):
              _key813 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val814 = []
              (_etype818, _size815) = iprot.readListBegin()
              if _size815 >= 0:
                for _i819 in range(_size815):
                  _elem820 = ServiceInfo()
                  _elem820.read(iprot)
                  _val814.append(_elem820)
              else: 
                while iprot.peekList():
                  _elem821 = ServiceInfo()
                  _elem821.read(iprot)
                  _val814.append(_elem821)
              iprot.readListEnd()
              self.host_services[_key813] = _val814
          else: 
            while iprot.peekMap():
              _key822 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val823 = []
              (_etype827, _size824) = iprot.readListBegin()
              if _size824 >= 0:
                for _i828 in range(_size824):
                  _elem829 = ServiceInfo()
                  _elem829.read(iprot)
                  _val823.append(_elem829)
              else: 
                while iprot.peekList():
                  _elem830 = ServiceInfo()
                  _elem830.read(iprot)
                  _val823.append(_elem830)
              iprot.readListEnd()
              self.host_services[_key822] = _val823
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListClusterInfoResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.host_services != None:
      oprot.writeFieldBegin('host_services', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.host_services))
      for kiter831,viter832 in self.host_services.items():
        oprot.writeString(kiter831.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter831, bytes) else oprot.writeString(kiter831)
        oprot.writeListBegin(TType.STRUCT, len(viter832))
        for iter833 in viter832:
          iter833.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.host_services is not None:
      value = pprint.pformat(self.host_services, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host_services=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class ListClusterInfoReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ListClusterInfoReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetMetaDirInfoResp:
  """
  Attributes:
   - code
   - dir
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dir = nebula3.common.ttypes.DirInfo()
          self.dir.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetMetaDirInfoResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.dir != None:
      oprot.writeFieldBegin('dir', TType.STRUCT, 2)
      self.dir.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.dir is not None:
      value = pprint.pformat(self.dir, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    dir=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class GetMetaDirInfoReq:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GetMetaDirInfoReq')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class VerifyClientVersionResp:
  """
  Attributes:
   - code
   - leader
   - error_msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.leader = nebula3.common.ttypes.HostAddr()
          self.leader.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.error_msg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VerifyClientVersionResp')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.leader != None:
      oprot.writeFieldBegin('leader', TType.STRUCT, 2)
      self.leader.write(oprot)
      oprot.writeFieldEnd()
    if self.error_msg != None:
      oprot.writeFieldBegin('error_msg', TType.STRING, 3)
      oprot.writeString(self.error_msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.code is not None:
      value = pprint.pformat(self.code, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    code=%s' % (value))
    if self.leader is not None:
      value = pprint.pformat(self.leader, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    leader=%s' % (value))
    if self.error_msg is not None:
      value = pprint.pformat(self.error_msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    error_msg=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

class VerifyClientVersionReq:
  """
  Attributes:
   - client_version
   - host
   - build_version
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.client_version = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.host = nebula3.common.ttypes.HostAddr()
          self.host.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.build_version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VerifyClientVersionReq')
    if self.client_version != None:
      oprot.writeFieldBegin('client_version', TType.STRING, 1)
      oprot.writeString(self.client_version)
      oprot.writeFieldEnd()
    if self.host != None:
      oprot.writeFieldBegin('host', TType.STRUCT, 2)
      self.host.write(oprot)
      oprot.writeFieldEnd()
    if self.build_version != None:
      oprot.writeFieldBegin('build_version', TType.STRING, 3)
      oprot.writeString(self.build_version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.client_version is not None:
      value = pprint.pformat(self.client_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    client_version=%s' % (value))
    if self.host is not None:
      value = pprint.pformat(self.host, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    host=%s' % (value))
    if self.build_version is not None:
      value = pprint.pformat(self.build_version, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    build_version=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

SchemaVer = UnimplementedTypedef()
ClusterID = UnimplementedTypedef()
all_structs.append(ID)
ID.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'tag_id', None, None, 2, ), # 2
  (3, TType.I32, 'edge_type', None, None, 2, ), # 3
  (4, TType.I32, 'index_id', None, None, 2, ), # 4
  (5, TType.I64, 'cluster_id', None, None, 2, ), # 5
)

ID.thrift_struct_annotations = {
}
ID.thrift_field_annotations = {
}

def ID__init__(self, space_id=None, tag_id=None, edge_type=None, index_id=None, cluster_id=None,):
  self.field = 0
  self.value = None
  if space_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = space_id
  if tag_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = tag_id
  if edge_type is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = edge_type
  if index_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = index_id
  if cluster_id is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = cluster_id

ID.__init__ = ID__init__

all_structs.append(ColumnTypeDef)
ColumnTypeDef.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', nebula3.common.ttypes.PropertyType, None, 0, ), # 1
  (2, TType.I16, 'type_length', None, 0, 1, ), # 2
  (3, TType.I32, 'geo_shape', GeoShape, None, 1, ), # 3
)

ColumnTypeDef.thrift_struct_annotations = {
}
ColumnTypeDef.thrift_field_annotations = {
}

def ColumnTypeDef__init__(self, type=None, type_length=ColumnTypeDef.thrift_spec[2][4], geo_shape=None,):
  self.type = type
  self.type_length = type_length
  self.geo_shape = geo_shape

ColumnTypeDef.__init__ = ColumnTypeDef__init__

def ColumnTypeDef__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('type_length', 0)
  state.setdefault('geo_shape', None)
  self.__dict__ = state

ColumnTypeDef.__getstate__ = lambda self: self.__dict__.copy()
ColumnTypeDef.__setstate__ = ColumnTypeDef__setstate__

all_structs.append(ColumnDef)
ColumnDef.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.STRUCT, 'type', [ColumnTypeDef, ColumnTypeDef.thrift_spec, False], None, 0, ), # 2
  (3, TType.STRING, 'default_value', False, None, 1, ), # 3
  (4, TType.BOOL, 'nullable', None, False, 1, ), # 4
  (5, TType.STRING, 'comment', False, None, 1, ), # 5
)

ColumnDef.thrift_struct_annotations = {
}
ColumnDef.thrift_field_annotations = {
}

def ColumnDef__init__(self, name=None, type=None, default_value=None, nullable=ColumnDef.thrift_spec[4][4], comment=None,):
  self.name = name
  self.type = type
  self.default_value = default_value
  self.nullable = nullable
  self.comment = comment

ColumnDef.__init__ = ColumnDef__init__

def ColumnDef__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('type', None)
  state.setdefault('default_value', None)
  state.setdefault('nullable', False)
  state.setdefault('comment', None)
  self.__dict__ = state

ColumnDef.__getstate__ = lambda self: self.__dict__.copy()
ColumnDef.__setstate__ = ColumnDef__setstate__

all_structs.append(SchemaProp)
SchemaProp.thrift_spec = (
  None, # 0
  (1, TType.I64, 'ttl_duration', None, None, 1, ), # 1
  (2, TType.STRING, 'ttl_col', False, None, 1, ), # 2
  (3, TType.STRING, 'comment', False, None, 1, ), # 3
)

SchemaProp.thrift_struct_annotations = {
}
SchemaProp.thrift_field_annotations = {
}

def SchemaProp__init__(self, ttl_duration=None, ttl_col=None, comment=None,):
  self.ttl_duration = ttl_duration
  self.ttl_col = ttl_col
  self.comment = comment

SchemaProp.__init__ = SchemaProp__init__

def SchemaProp__setstate__(self, state):
  state.setdefault('ttl_duration', None)
  state.setdefault('ttl_col', None)
  state.setdefault('comment', None)
  self.__dict__ = state

SchemaProp.__getstate__ = lambda self: self.__dict__.copy()
SchemaProp.__setstate__ = SchemaProp__setstate__

all_structs.append(Schema)
Schema.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'columns', (TType.STRUCT,[ColumnDef, ColumnDef.thrift_spec, False]), None, 2, ), # 1
  (2, TType.STRUCT, 'schema_prop', [SchemaProp, SchemaProp.thrift_spec, False], None, 2, ), # 2
)

Schema.thrift_struct_annotations = {
}
Schema.thrift_field_annotations = {
}

def Schema__init__(self, columns=None, schema_prop=None,):
  self.columns = columns
  self.schema_prop = schema_prop

Schema.__init__ = Schema__init__

def Schema__setstate__(self, state):
  state.setdefault('columns', None)
  state.setdefault('schema_prop', None)
  self.__dict__ = state

Schema.__getstate__ = lambda self: self.__dict__.copy()
Schema.__setstate__ = Schema__setstate__

all_structs.append(IdName)
IdName.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'id', [ID, ID.thrift_spec, True], None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
)

IdName.thrift_struct_annotations = {
}
IdName.thrift_field_annotations = {
}

def IdName__init__(self, id=None, name=None,):
  self.id = id
  self.name = name

IdName.__init__ = IdName__init__

def IdName__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('name', None)
  self.__dict__ = state

IdName.__getstate__ = lambda self: self.__dict__.copy()
IdName.__setstate__ = IdName__setstate__

all_structs.append(SpaceDesc)
SpaceDesc.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
  (2, TType.I32, 'partition_num', None, 0, 2, ), # 2
  (3, TType.I32, 'replica_factor', None, 0, 2, ), # 3
  (4, TType.STRING, 'charset_name', False, None, 2, ), # 4
  (5, TType.STRING, 'collate_name', False, None, 2, ), # 5
  (6, TType.STRUCT, 'vid_type', [ColumnTypeDef, ColumnTypeDef.thrift_spec, False], ColumnTypeDef(**{
    "type" :     7,
    "type_length" : 8,
  }), 2, ), # 6
  (7, TType.LIST, 'zone_names', (TType.STRING,False), None, 2, ), # 7
  (8, TType.I32, 'isolation_level', IsolationLevel, None, 1, ), # 8
  (9, TType.STRING, 'comment', False, None, 1, ), # 9
)

SpaceDesc.thrift_struct_annotations = {
}
SpaceDesc.thrift_field_annotations = {
}

def SpaceDesc__init__(self, space_name=None, partition_num=SpaceDesc.thrift_spec[2][4], replica_factor=SpaceDesc.thrift_spec[3][4], charset_name=None, collate_name=None, vid_type=SpaceDesc.thrift_spec[6][4], zone_names=None, isolation_level=None, comment=None,):
  self.space_name = space_name
  self.partition_num = partition_num
  self.replica_factor = replica_factor
  self.charset_name = charset_name
  self.collate_name = collate_name
  if vid_type is self.thrift_spec[6][4]:
    vid_type = ColumnTypeDef(**{
    "type" :     7,
    "type_length" : 8,
  })
  self.vid_type = vid_type
  self.zone_names = zone_names
  self.isolation_level = isolation_level
  self.comment = comment

SpaceDesc.__init__ = SpaceDesc__init__

def SpaceDesc__setstate__(self, state):
  state.setdefault('space_name', None)
  state.setdefault('partition_num', 0)
  state.setdefault('replica_factor', 0)
  state.setdefault('charset_name', None)
  state.setdefault('collate_name', None)
  state.setdefault('vid_type', ColumnTypeDef(**{
    "type" :     7,
    "type_length" : 8,
  }))
  state.setdefault('zone_names', None)
  state.setdefault('isolation_level', None)
  state.setdefault('comment', None)
  self.__dict__ = state

SpaceDesc.__getstate__ = lambda self: self.__dict__.copy()
SpaceDesc.__setstate__ = SpaceDesc__setstate__

all_structs.append(SpaceItem)
SpaceItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRUCT, 'properties', [SpaceDesc, SpaceDesc.thrift_spec, False], None, 2, ), # 2
)

SpaceItem.thrift_struct_annotations = {
}
SpaceItem.thrift_field_annotations = {
}

def SpaceItem__init__(self, space_id=None, properties=None,):
  self.space_id = space_id
  self.properties = properties

SpaceItem.__init__ = SpaceItem__init__

def SpaceItem__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('properties', None)
  self.__dict__ = state

SpaceItem.__getstate__ = lambda self: self.__dict__.copy()
SpaceItem.__setstate__ = SpaceItem__setstate__

all_structs.append(TagItem)
TagItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'tag_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
  (4, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 4
)

TagItem.thrift_struct_annotations = {
}
TagItem.thrift_field_annotations = {
}

def TagItem__init__(self, tag_id=None, tag_name=None, version=None, schema=None,):
  self.tag_id = tag_id
  self.tag_name = tag_name
  self.version = version
  self.schema = schema

TagItem.__init__ = TagItem__init__

def TagItem__setstate__(self, state):
  state.setdefault('tag_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('version', None)
  state.setdefault('schema', None)
  self.__dict__ = state

TagItem.__getstate__ = lambda self: self.__dict__.copy()
TagItem.__setstate__ = TagItem__setstate__

all_structs.append(AlterSchemaItem)
AlterSchemaItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'op', AlterSchemaOp, None, 2, ), # 1
  (2, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 2
)

AlterSchemaItem.thrift_struct_annotations = {
}
AlterSchemaItem.thrift_field_annotations = {
}

def AlterSchemaItem__init__(self, op=None, schema=None,):
  self.op = op
  self.schema = schema

AlterSchemaItem.__init__ = AlterSchemaItem__init__

def AlterSchemaItem__setstate__(self, state):
  state.setdefault('op', None)
  state.setdefault('schema', None)
  self.__dict__ = state

AlterSchemaItem.__getstate__ = lambda self: self.__dict__.copy()
AlterSchemaItem.__setstate__ = AlterSchemaItem__setstate__

all_structs.append(EdgeItem)
EdgeItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'edge_type', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
  (4, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 4
)

EdgeItem.thrift_struct_annotations = {
}
EdgeItem.thrift_field_annotations = {
}

def EdgeItem__init__(self, edge_type=None, edge_name=None, version=None, schema=None,):
  self.edge_type = edge_type
  self.edge_name = edge_name
  self.version = version
  self.schema = schema

EdgeItem.__init__ = EdgeItem__init__

def EdgeItem__setstate__(self, state):
  state.setdefault('edge_type', None)
  state.setdefault('edge_name', None)
  state.setdefault('version', None)
  state.setdefault('schema', None)
  self.__dict__ = state

EdgeItem.__getstate__ = lambda self: self.__dict__.copy()
EdgeItem.__setstate__ = EdgeItem__setstate__

all_structs.append(IndexParams)
IndexParams.thrift_spec = (
  None, # 0
  (1, TType.I32, 's2_max_level', None, None, 1, ), # 1
  (2, TType.I32, 's2_max_cells', None, None, 1, ), # 2
)

IndexParams.thrift_struct_annotations = {
}
IndexParams.thrift_field_annotations = {
}

def IndexParams__init__(self, s2_max_level=None, s2_max_cells=None,):
  self.s2_max_level = s2_max_level
  self.s2_max_cells = s2_max_cells

IndexParams.__init__ = IndexParams__init__

def IndexParams__setstate__(self, state):
  state.setdefault('s2_max_level', None)
  state.setdefault('s2_max_cells', None)
  self.__dict__ = state

IndexParams.__getstate__ = lambda self: self.__dict__.copy()
IndexParams.__setstate__ = IndexParams__setstate__

all_structs.append(IndexItem)
IndexItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'index_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'schema_id', [nebula3.common.ttypes.SchemaID, nebula3.common.ttypes.SchemaID.thrift_spec, True], None, 2, ), # 3
  (4, TType.STRING, 'schema_name', False, None, 2, ), # 4
  (5, TType.LIST, 'fields', (TType.STRUCT,[ColumnDef, ColumnDef.thrift_spec, False]), None, 2, ), # 5
  (6, TType.STRING, 'comment', False, None, 1, ), # 6
  (7, TType.STRUCT, 'index_params', [IndexParams, IndexParams.thrift_spec, False], None, 1, ), # 7
)

IndexItem.thrift_struct_annotations = {
}
IndexItem.thrift_field_annotations = {
}

def IndexItem__init__(self, index_id=None, index_name=None, schema_id=None, schema_name=None, fields=None, comment=None, index_params=None,):
  self.index_id = index_id
  self.index_name = index_name
  self.schema_id = schema_id
  self.schema_name = schema_name
  self.fields = fields
  self.comment = comment
  self.index_params = index_params

IndexItem.__init__ = IndexItem__init__

def IndexItem__setstate__(self, state):
  state.setdefault('index_id', None)
  state.setdefault('index_name', None)
  state.setdefault('schema_id', None)
  state.setdefault('schema_name', None)
  state.setdefault('fields', None)
  state.setdefault('comment', None)
  state.setdefault('index_params', None)
  self.__dict__ = state

IndexItem.__getstate__ = lambda self: self.__dict__.copy()
IndexItem.__setstate__ = IndexItem__setstate__

all_structs.append(HostItem)
HostItem.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'hostAddr', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'status', HostStatus, None, 2, ), # 2
  (3, TType.MAP, 'leader_parts', (TType.STRING,False,TType.LIST,(TType.I32,None)), None, 2, ), # 3
  (4, TType.MAP, 'all_parts', (TType.STRING,False,TType.LIST,(TType.I32,None)), None, 2, ), # 4
  (5, TType.I32, 'role', HostRole, None, 2, ), # 5
  (6, TType.STRING, 'git_info_sha', False, None, 2, ), # 6
  (7, TType.STRING, 'zone_name', False, None, 1, ), # 7
  (8, TType.STRING, 'version', False, None, 1, ), # 8
)

HostItem.thrift_struct_annotations = {
}
HostItem.thrift_field_annotations = {
}

def HostItem__init__(self, hostAddr=None, status=None, leader_parts=None, all_parts=None, role=None, git_info_sha=None, zone_name=None, version=None,):
  self.hostAddr = hostAddr
  self.status = status
  self.leader_parts = leader_parts
  self.all_parts = all_parts
  self.role = role
  self.git_info_sha = git_info_sha
  self.zone_name = zone_name
  self.version = version

HostItem.__init__ = HostItem__init__

def HostItem__setstate__(self, state):
  state.setdefault('hostAddr', None)
  state.setdefault('status', None)
  state.setdefault('leader_parts', None)
  state.setdefault('all_parts', None)
  state.setdefault('role', None)
  state.setdefault('git_info_sha', None)
  state.setdefault('zone_name', None)
  state.setdefault('version', None)
  self.__dict__ = state

HostItem.__getstate__ = lambda self: self.__dict__.copy()
HostItem.__setstate__ = HostItem__setstate__

all_structs.append(UserItem)
UserItem.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.BOOL, 'is_lock', None, None, 2, ), # 2
  (3, TType.I32, 'max_queries_per_hour', None, None, 2, ), # 3
  (4, TType.I32, 'max_updates_per_hour', None, None, 2, ), # 4
  (5, TType.I32, 'max_connections_per_hour', None, None, 2, ), # 5
  (6, TType.I32, 'max_user_connections', None, None, 2, ), # 6
)

UserItem.thrift_struct_annotations = {
}
UserItem.thrift_field_annotations = {
}

def UserItem__init__(self, account=None, is_lock=None, max_queries_per_hour=None, max_updates_per_hour=None, max_connections_per_hour=None, max_user_connections=None,):
  self.account = account
  self.is_lock = is_lock
  self.max_queries_per_hour = max_queries_per_hour
  self.max_updates_per_hour = max_updates_per_hour
  self.max_connections_per_hour = max_connections_per_hour
  self.max_user_connections = max_user_connections

UserItem.__init__ = UserItem__init__

def UserItem__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('is_lock', None)
  state.setdefault('max_queries_per_hour', None)
  state.setdefault('max_updates_per_hour', None)
  state.setdefault('max_connections_per_hour', None)
  state.setdefault('max_user_connections', None)
  self.__dict__ = state

UserItem.__getstate__ = lambda self: self.__dict__.copy()
UserItem.__setstate__ = UserItem__setstate__

all_structs.append(RoleItem)
RoleItem.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'user_id', False, None, 2, ), # 1
  (2, TType.I32, 'space_id', None, None, 2, ), # 2
  (3, TType.I32, 'role_type', RoleType, None, 2, ), # 3
)

RoleItem.thrift_struct_annotations = {
}
RoleItem.thrift_field_annotations = {
}

def RoleItem__init__(self, user_id=None, space_id=None, role_type=None,):
  self.user_id = user_id
  self.space_id = space_id
  self.role_type = role_type

RoleItem.__init__ = RoleItem__init__

def RoleItem__setstate__(self, state):
  state.setdefault('user_id', None)
  state.setdefault('space_id', None)
  state.setdefault('role_type', None)
  self.__dict__ = state

RoleItem.__getstate__ = lambda self: self.__dict__.copy()
RoleItem.__setstate__ = RoleItem__setstate__

all_structs.append(ExecResp)
ExecResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'id', [ID, ID.thrift_spec, True], None, 2, ), # 2
  (3, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 3
)

ExecResp.thrift_struct_annotations = {
}
ExecResp.thrift_field_annotations = {
}

def ExecResp__init__(self, code=None, id=None, leader=None,):
  self.code = code
  self.id = id
  self.leader = leader

ExecResp.__init__ = ExecResp__init__

def ExecResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('id', None)
  state.setdefault('leader', None)
  self.__dict__ = state

ExecResp.__getstate__ = lambda self: self.__dict__.copy()
ExecResp.__setstate__ = ExecResp__setstate__

all_structs.append(AlterSpaceReq)
AlterSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
  (2, TType.I32, 'op', AlterSpaceOp, None, 2, ), # 2
  (3, TType.LIST, 'paras', (TType.STRING,False), None, 2, ), # 3
)

AlterSpaceReq.thrift_struct_annotations = {
}
AlterSpaceReq.thrift_field_annotations = {
}

def AlterSpaceReq__init__(self, space_name=None, op=None, paras=None,):
  self.space_name = space_name
  self.op = op
  self.paras = paras

AlterSpaceReq.__init__ = AlterSpaceReq__init__

def AlterSpaceReq__setstate__(self, state):
  state.setdefault('space_name', None)
  state.setdefault('op', None)
  state.setdefault('paras', None)
  self.__dict__ = state

AlterSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
AlterSpaceReq.__setstate__ = AlterSpaceReq__setstate__

all_structs.append(AdminJobReq)
AdminJobReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'op', AdminJobOp, None, 2, ), # 1
  (2, TType.I32, 'cmd', AdminCmd, None, 2, ), # 2
  (3, TType.LIST, 'paras', (TType.STRING,False), None, 2, ), # 3
)

AdminJobReq.thrift_struct_annotations = {
}
AdminJobReq.thrift_field_annotations = {
}

def AdminJobReq__init__(self, op=None, cmd=None, paras=None,):
  self.op = op
  self.cmd = cmd
  self.paras = paras

AdminJobReq.__init__ = AdminJobReq__init__

def AdminJobReq__setstate__(self, state):
  state.setdefault('op', None)
  state.setdefault('cmd', None)
  state.setdefault('paras', None)
  self.__dict__ = state

AdminJobReq.__getstate__ = lambda self: self.__dict__.copy()
AdminJobReq.__setstate__ = AdminJobReq__setstate__

all_structs.append(JobDesc)
JobDesc.thrift_spec = (
  None, # 0
  (1, TType.I32, 'id', None, None, 2, ), # 1
  (2, TType.I32, 'cmd', AdminCmd, None, 2, ), # 2
  (3, TType.LIST, 'paras', (TType.STRING,True), None, 2, ), # 3
  (4, TType.I32, 'status', JobStatus, None, 2, ), # 4
  (5, TType.I64, 'start_time', None, None, 2, ), # 5
  (6, TType.I64, 'stop_time', None, None, 2, ), # 6
)

JobDesc.thrift_struct_annotations = {
}
JobDesc.thrift_field_annotations = {
}

def JobDesc__init__(self, id=None, cmd=None, paras=None, status=None, start_time=None, stop_time=None,):
  self.id = id
  self.cmd = cmd
  self.paras = paras
  self.status = status
  self.start_time = start_time
  self.stop_time = stop_time

JobDesc.__init__ = JobDesc__init__

def JobDesc__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('cmd', None)
  state.setdefault('paras', None)
  state.setdefault('status', None)
  state.setdefault('start_time', None)
  state.setdefault('stop_time', None)
  self.__dict__ = state

JobDesc.__getstate__ = lambda self: self.__dict__.copy()
JobDesc.__setstate__ = JobDesc__setstate__

all_structs.append(TaskDesc)
TaskDesc.thrift_spec = (
  None, # 0
  (1, TType.I32, 'task_id', None, None, 2, ), # 1
  (2, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'status', JobStatus, None, 2, ), # 3
  (4, TType.I64, 'start_time', None, None, 2, ), # 4
  (5, TType.I64, 'stop_time', None, None, 2, ), # 5
  (6, TType.I32, 'job_id', None, None, 2, ), # 6
)

TaskDesc.thrift_struct_annotations = {
}
TaskDesc.thrift_field_annotations = {
}

def TaskDesc__init__(self, task_id=None, host=None, status=None, start_time=None, stop_time=None, job_id=None,):
  self.task_id = task_id
  self.host = host
  self.status = status
  self.start_time = start_time
  self.stop_time = stop_time
  self.job_id = job_id

TaskDesc.__init__ = TaskDesc__init__

def TaskDesc__setstate__(self, state):
  state.setdefault('task_id', None)
  state.setdefault('host', None)
  state.setdefault('status', None)
  state.setdefault('start_time', None)
  state.setdefault('stop_time', None)
  state.setdefault('job_id', None)
  self.__dict__ = state

TaskDesc.__getstate__ = lambda self: self.__dict__.copy()
TaskDesc.__setstate__ = TaskDesc__setstate__

all_structs.append(AdminJobResult)
AdminJobResult.thrift_spec = (
  None, # 0
  (1, TType.I32, 'job_id', None, None, 1, ), # 1
  (2, TType.LIST, 'job_desc', (TType.STRUCT,[JobDesc, JobDesc.thrift_spec, False]), None, 1, ), # 2
  (3, TType.LIST, 'task_desc', (TType.STRUCT,[TaskDesc, TaskDesc.thrift_spec, False]), None, 1, ), # 3
  (4, TType.I32, 'recovered_job_num', None, None, 1, ), # 4
)

AdminJobResult.thrift_struct_annotations = {
}
AdminJobResult.thrift_field_annotations = {
}

def AdminJobResult__init__(self, job_id=None, job_desc=None, task_desc=None, recovered_job_num=None,):
  self.job_id = job_id
  self.job_desc = job_desc
  self.task_desc = task_desc
  self.recovered_job_num = recovered_job_num

AdminJobResult.__init__ = AdminJobResult__init__

def AdminJobResult__setstate__(self, state):
  state.setdefault('job_id', None)
  state.setdefault('job_desc', None)
  state.setdefault('task_desc', None)
  state.setdefault('recovered_job_num', None)
  self.__dict__ = state

AdminJobResult.__getstate__ = lambda self: self.__dict__.copy()
AdminJobResult.__setstate__ = AdminJobResult__setstate__

all_structs.append(AdminJobResp)
AdminJobResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'result', [AdminJobResult, AdminJobResult.thrift_spec, False], None, 2, ), # 3
)

AdminJobResp.thrift_struct_annotations = {
}
AdminJobResp.thrift_field_annotations = {
}

def AdminJobResp__init__(self, code=None, leader=None, result=None,):
  self.code = code
  self.leader = leader
  self.result = result

AdminJobResp.__init__ = AdminJobResp__init__

def AdminJobResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('result', None)
  self.__dict__ = state

AdminJobResp.__getstate__ = lambda self: self.__dict__.copy()
AdminJobResp.__setstate__ = AdminJobResp__setstate__

all_structs.append(Correlativity)
Correlativity.thrift_spec = (
  None, # 0
  (1, TType.I32, 'part_id', None, None, 2, ), # 1
  (2, TType.DOUBLE, 'proportion', None, None, 2, ), # 2
)

Correlativity.thrift_struct_annotations = {
}
Correlativity.thrift_field_annotations = {
}

def Correlativity__init__(self, part_id=None, proportion=None,):
  self.part_id = part_id
  self.proportion = proportion

Correlativity.__init__ = Correlativity__init__

def Correlativity__setstate__(self, state):
  state.setdefault('part_id', None)
  state.setdefault('proportion', None)
  self.__dict__ = state

Correlativity.__getstate__ = lambda self: self.__dict__.copy()
Correlativity.__setstate__ = Correlativity__setstate__

all_structs.append(StatsItem)
StatsItem.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'tag_vertices', (TType.STRING,False,TType.I64,None), None, 2, ), # 1
  (2, TType.MAP, 'edges', (TType.STRING,False,TType.I64,None), None, 2, ), # 2
  (3, TType.I64, 'space_vertices', None, None, 2, ), # 3
  (4, TType.I64, 'space_edges', None, None, 2, ), # 4
  (5, TType.MAP, 'positive_part_correlativity', (TType.I32,None,TType.LIST,(TType.STRUCT,[Correlativity, Correlativity.thrift_spec, False])), None, 2, ), # 5
  (6, TType.MAP, 'negative_part_correlativity', (TType.I32,None,TType.LIST,(TType.STRUCT,[Correlativity, Correlativity.thrift_spec, False])), None, 2, ), # 6
  (7, TType.I32, 'status', JobStatus, None, 2, ), # 7
)

StatsItem.thrift_struct_annotations = {
}
StatsItem.thrift_field_annotations = {
}

def StatsItem__init__(self, tag_vertices=None, edges=None, space_vertices=None, space_edges=None, positive_part_correlativity=None, negative_part_correlativity=None, status=None,):
  self.tag_vertices = tag_vertices
  self.edges = edges
  self.space_vertices = space_vertices
  self.space_edges = space_edges
  self.positive_part_correlativity = positive_part_correlativity
  self.negative_part_correlativity = negative_part_correlativity
  self.status = status

StatsItem.__init__ = StatsItem__init__

def StatsItem__setstate__(self, state):
  state.setdefault('tag_vertices', None)
  state.setdefault('edges', None)
  state.setdefault('space_vertices', None)
  state.setdefault('space_edges', None)
  state.setdefault('positive_part_correlativity', None)
  state.setdefault('negative_part_correlativity', None)
  state.setdefault('status', None)
  self.__dict__ = state

StatsItem.__getstate__ = lambda self: self.__dict__.copy()
StatsItem.__setstate__ = StatsItem__setstate__

all_structs.append(CreateSpaceReq)
CreateSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'properties', [SpaceDesc, SpaceDesc.thrift_spec, False], None, 2, ), # 1
  (2, TType.BOOL, 'if_not_exists', None, None, 2, ), # 2
)

CreateSpaceReq.thrift_struct_annotations = {
}
CreateSpaceReq.thrift_field_annotations = {
}

def CreateSpaceReq__init__(self, properties=None, if_not_exists=None,):
  self.properties = properties
  self.if_not_exists = if_not_exists

CreateSpaceReq.__init__ = CreateSpaceReq__init__

def CreateSpaceReq__setstate__(self, state):
  state.setdefault('properties', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
CreateSpaceReq.__setstate__ = CreateSpaceReq__setstate__

all_structs.append(CreateSpaceAsReq)
CreateSpaceAsReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'old_space_name', False, None, 2, ), # 1
  (2, TType.STRING, 'new_space_name', False, None, 2, ), # 2
)

CreateSpaceAsReq.thrift_struct_annotations = {
}
CreateSpaceAsReq.thrift_field_annotations = {
}

def CreateSpaceAsReq__init__(self, old_space_name=None, new_space_name=None,):
  self.old_space_name = old_space_name
  self.new_space_name = new_space_name

CreateSpaceAsReq.__init__ = CreateSpaceAsReq__init__

def CreateSpaceAsReq__setstate__(self, state):
  state.setdefault('old_space_name', None)
  state.setdefault('new_space_name', None)
  self.__dict__ = state

CreateSpaceAsReq.__getstate__ = lambda self: self.__dict__.copy()
CreateSpaceAsReq.__setstate__ = CreateSpaceAsReq__setstate__

all_structs.append(DropSpaceReq)
DropSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
  (2, TType.BOOL, 'if_exists', None, None, 2, ), # 2
)

DropSpaceReq.thrift_struct_annotations = {
}
DropSpaceReq.thrift_field_annotations = {
}

def DropSpaceReq__init__(self, space_name=None, if_exists=None,):
  self.space_name = space_name
  self.if_exists = if_exists

DropSpaceReq.__init__ = DropSpaceReq__init__

def DropSpaceReq__setstate__(self, state):
  state.setdefault('space_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
DropSpaceReq.__setstate__ = DropSpaceReq__setstate__

all_structs.append(ListSpacesReq)
ListSpacesReq.thrift_spec = (
)

ListSpacesReq.thrift_struct_annotations = {
}
ListSpacesReq.thrift_field_annotations = {
}

all_structs.append(ListSpacesResp)
ListSpacesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'spaces', (TType.STRUCT,[IdName, IdName.thrift_spec, False]), None, 2, ), # 3
)

ListSpacesResp.thrift_struct_annotations = {
}
ListSpacesResp.thrift_field_annotations = {
}

def ListSpacesResp__init__(self, code=None, leader=None, spaces=None,):
  self.code = code
  self.leader = leader
  self.spaces = spaces

ListSpacesResp.__init__ = ListSpacesResp__init__

def ListSpacesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('spaces', None)
  self.__dict__ = state

ListSpacesResp.__getstate__ = lambda self: self.__dict__.copy()
ListSpacesResp.__setstate__ = ListSpacesResp__setstate__

all_structs.append(GetSpaceReq)
GetSpaceReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space_name', False, None, 2, ), # 1
)

GetSpaceReq.thrift_struct_annotations = {
}
GetSpaceReq.thrift_field_annotations = {
}

def GetSpaceReq__init__(self, space_name=None,):
  self.space_name = space_name

GetSpaceReq.__init__ = GetSpaceReq__init__

def GetSpaceReq__setstate__(self, state):
  state.setdefault('space_name', None)
  self.__dict__ = state

GetSpaceReq.__getstate__ = lambda self: self.__dict__.copy()
GetSpaceReq.__setstate__ = GetSpaceReq__setstate__

all_structs.append(GetSpaceResp)
GetSpaceResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'item', [SpaceItem, SpaceItem.thrift_spec, False], None, 2, ), # 3
)

GetSpaceResp.thrift_struct_annotations = {
}
GetSpaceResp.thrift_field_annotations = {
}

def GetSpaceResp__init__(self, code=None, leader=None, item=None,):
  self.code = code
  self.leader = leader
  self.item = item

GetSpaceResp.__init__ = GetSpaceResp__init__

def GetSpaceResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('item', None)
  self.__dict__ = state

GetSpaceResp.__getstate__ = lambda self: self.__dict__.copy()
GetSpaceResp.__setstate__ = GetSpaceResp__setstate__

all_structs.append(CreateTagReq)
CreateTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
)

CreateTagReq.thrift_struct_annotations = {
}
CreateTagReq.thrift_field_annotations = {
}

def CreateTagReq__init__(self, space_id=None, tag_name=None, schema=None, if_not_exists=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.schema = schema
  self.if_not_exists = if_not_exists

CreateTagReq.__init__ = CreateTagReq__init__

def CreateTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('schema', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateTagReq.__getstate__ = lambda self: self.__dict__.copy()
CreateTagReq.__setstate__ = CreateTagReq__setstate__

all_structs.append(AlterTagReq)
AlterTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.LIST, 'tag_items', (TType.STRUCT,[AlterSchemaItem, AlterSchemaItem.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'schema_prop', [SchemaProp, SchemaProp.thrift_spec, False], None, 2, ), # 4
)

AlterTagReq.thrift_struct_annotations = {
}
AlterTagReq.thrift_field_annotations = {
}

def AlterTagReq__init__(self, space_id=None, tag_name=None, tag_items=None, schema_prop=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.tag_items = tag_items
  self.schema_prop = schema_prop

AlterTagReq.__init__ = AlterTagReq__init__

def AlterTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('tag_items', None)
  state.setdefault('schema_prop', None)
  self.__dict__ = state

AlterTagReq.__getstate__ = lambda self: self.__dict__.copy()
AlterTagReq.__setstate__ = AlterTagReq__setstate__

all_structs.append(DropTagReq)
DropTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropTagReq.thrift_struct_annotations = {
}
DropTagReq.thrift_field_annotations = {
}

def DropTagReq__init__(self, space_id=None, tag_name=None, if_exists=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.if_exists = if_exists

DropTagReq.__init__ = DropTagReq__init__

def DropTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropTagReq.__getstate__ = lambda self: self.__dict__.copy()
DropTagReq.__setstate__ = DropTagReq__setstate__

all_structs.append(ListTagsReq)
ListTagsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListTagsReq.thrift_struct_annotations = {
}
ListTagsReq.thrift_field_annotations = {
}

def ListTagsReq__init__(self, space_id=None,):
  self.space_id = space_id

ListTagsReq.__init__ = ListTagsReq__init__

def ListTagsReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListTagsReq.__getstate__ = lambda self: self.__dict__.copy()
ListTagsReq.__setstate__ = ListTagsReq__setstate__

all_structs.append(ListTagsResp)
ListTagsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'tags', (TType.STRUCT,[TagItem, TagItem.thrift_spec, False]), None, 2, ), # 3
)

ListTagsResp.thrift_struct_annotations = {
}
ListTagsResp.thrift_field_annotations = {
}

def ListTagsResp__init__(self, code=None, leader=None, tags=None,):
  self.code = code
  self.leader = leader
  self.tags = tags

ListTagsResp.__init__ = ListTagsResp__init__

def ListTagsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('tags', None)
  self.__dict__ = state

ListTagsResp.__getstate__ = lambda self: self.__dict__.copy()
ListTagsResp.__setstate__ = ListTagsResp__setstate__

all_structs.append(GetTagReq)
GetTagReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'tag_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
)

GetTagReq.thrift_struct_annotations = {
}
GetTagReq.thrift_field_annotations = {
}

def GetTagReq__init__(self, space_id=None, tag_name=None, version=None,):
  self.space_id = space_id
  self.tag_name = tag_name
  self.version = version

GetTagReq.__init__ = GetTagReq__init__

def GetTagReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('tag_name', None)
  state.setdefault('version', None)
  self.__dict__ = state

GetTagReq.__getstate__ = lambda self: self.__dict__.copy()
GetTagReq.__setstate__ = GetTagReq__setstate__

all_structs.append(GetTagResp)
GetTagResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
)

GetTagResp.thrift_struct_annotations = {
}
GetTagResp.thrift_field_annotations = {
}

def GetTagResp__init__(self, code=None, leader=None, schema=None,):
  self.code = code
  self.leader = leader
  self.schema = schema

GetTagResp.__init__ = GetTagResp__init__

def GetTagResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('schema', None)
  self.__dict__ = state

GetTagResp.__getstate__ = lambda self: self.__dict__.copy()
GetTagResp.__setstate__ = GetTagResp__setstate__

all_structs.append(CreateEdgeReq)
CreateEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
  (4, TType.BOOL, 'if_not_exists', None, None, 2, ), # 4
)

CreateEdgeReq.thrift_struct_annotations = {
}
CreateEdgeReq.thrift_field_annotations = {
}

def CreateEdgeReq__init__(self, space_id=None, edge_name=None, schema=None, if_not_exists=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.schema = schema
  self.if_not_exists = if_not_exists

CreateEdgeReq.__init__ = CreateEdgeReq__init__

def CreateEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('schema', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
CreateEdgeReq.__setstate__ = CreateEdgeReq__setstate__

all_structs.append(AlterEdgeReq)
AlterEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.LIST, 'edge_items', (TType.STRUCT,[AlterSchemaItem, AlterSchemaItem.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'schema_prop', [SchemaProp, SchemaProp.thrift_spec, False], None, 2, ), # 4
)

AlterEdgeReq.thrift_struct_annotations = {
}
AlterEdgeReq.thrift_field_annotations = {
}

def AlterEdgeReq__init__(self, space_id=None, edge_name=None, edge_items=None, schema_prop=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.edge_items = edge_items
  self.schema_prop = schema_prop

AlterEdgeReq.__init__ = AlterEdgeReq__init__

def AlterEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('edge_items', None)
  state.setdefault('schema_prop', None)
  self.__dict__ = state

AlterEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
AlterEdgeReq.__setstate__ = AlterEdgeReq__setstate__

all_structs.append(GetEdgeReq)
GetEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.I64, 'version', None, None, 2, ), # 3
)

GetEdgeReq.thrift_struct_annotations = {
}
GetEdgeReq.thrift_field_annotations = {
}

def GetEdgeReq__init__(self, space_id=None, edge_name=None, version=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.version = version

GetEdgeReq.__init__ = GetEdgeReq__init__

def GetEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('version', None)
  self.__dict__ = state

GetEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeReq.__setstate__ = GetEdgeReq__setstate__

all_structs.append(GetEdgeResp)
GetEdgeResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'schema', [Schema, Schema.thrift_spec, False], None, 2, ), # 3
)

GetEdgeResp.thrift_struct_annotations = {
}
GetEdgeResp.thrift_field_annotations = {
}

def GetEdgeResp__init__(self, code=None, leader=None, schema=None,):
  self.code = code
  self.leader = leader
  self.schema = schema

GetEdgeResp.__init__ = GetEdgeResp__init__

def GetEdgeResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('schema', None)
  self.__dict__ = state

GetEdgeResp.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeResp.__setstate__ = GetEdgeResp__setstate__

all_structs.append(DropEdgeReq)
DropEdgeReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'edge_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropEdgeReq.thrift_struct_annotations = {
}
DropEdgeReq.thrift_field_annotations = {
}

def DropEdgeReq__init__(self, space_id=None, edge_name=None, if_exists=None,):
  self.space_id = space_id
  self.edge_name = edge_name
  self.if_exists = if_exists

DropEdgeReq.__init__ = DropEdgeReq__init__

def DropEdgeReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('edge_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropEdgeReq.__getstate__ = lambda self: self.__dict__.copy()
DropEdgeReq.__setstate__ = DropEdgeReq__setstate__

all_structs.append(ListEdgesReq)
ListEdgesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListEdgesReq.thrift_struct_annotations = {
}
ListEdgesReq.thrift_field_annotations = {
}

def ListEdgesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListEdgesReq.__init__ = ListEdgesReq__init__

def ListEdgesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListEdgesReq.__getstate__ = lambda self: self.__dict__.copy()
ListEdgesReq.__setstate__ = ListEdgesReq__setstate__

all_structs.append(ListEdgesResp)
ListEdgesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'edges', (TType.STRUCT,[EdgeItem, EdgeItem.thrift_spec, False]), None, 2, ), # 3
)

ListEdgesResp.thrift_struct_annotations = {
}
ListEdgesResp.thrift_field_annotations = {
}

def ListEdgesResp__init__(self, code=None, leader=None, edges=None,):
  self.code = code
  self.leader = leader
  self.edges = edges

ListEdgesResp.__init__ = ListEdgesResp__init__

def ListEdgesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('edges', None)
  self.__dict__ = state

ListEdgesResp.__getstate__ = lambda self: self.__dict__.copy()
ListEdgesResp.__setstate__ = ListEdgesResp__setstate__

all_structs.append(AddHostsReq)
AddHostsReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'hosts', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 1
)

AddHostsReq.thrift_struct_annotations = {
}
AddHostsReq.thrift_field_annotations = {
}

def AddHostsReq__init__(self, hosts=None,):
  self.hosts = hosts

AddHostsReq.__init__ = AddHostsReq__init__

def AddHostsReq__setstate__(self, state):
  state.setdefault('hosts', None)
  self.__dict__ = state

AddHostsReq.__getstate__ = lambda self: self.__dict__.copy()
AddHostsReq.__setstate__ = AddHostsReq__setstate__

all_structs.append(DropHostsReq)
DropHostsReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'hosts', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 1
)

DropHostsReq.thrift_struct_annotations = {
}
DropHostsReq.thrift_field_annotations = {
}

def DropHostsReq__init__(self, hosts=None,):
  self.hosts = hosts

DropHostsReq.__init__ = DropHostsReq__init__

def DropHostsReq__setstate__(self, state):
  state.setdefault('hosts', None)
  self.__dict__ = state

DropHostsReq.__getstate__ = lambda self: self.__dict__.copy()
DropHostsReq.__setstate__ = DropHostsReq__setstate__

all_structs.append(ListHostsReq)
ListHostsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ListHostType, None, 2, ), # 1
)

ListHostsReq.thrift_struct_annotations = {
}
ListHostsReq.thrift_field_annotations = {
}

def ListHostsReq__init__(self, type=None,):
  self.type = type

ListHostsReq.__init__ = ListHostsReq__init__

def ListHostsReq__setstate__(self, state):
  state.setdefault('type', None)
  self.__dict__ = state

ListHostsReq.__getstate__ = lambda self: self.__dict__.copy()
ListHostsReq.__setstate__ = ListHostsReq__setstate__

all_structs.append(ListHostsResp)
ListHostsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'hosts', (TType.STRUCT,[HostItem, HostItem.thrift_spec, False]), None, 2, ), # 3
)

ListHostsResp.thrift_struct_annotations = {
}
ListHostsResp.thrift_field_annotations = {
}

def ListHostsResp__init__(self, code=None, leader=None, hosts=None,):
  self.code = code
  self.leader = leader
  self.hosts = hosts

ListHostsResp.__init__ = ListHostsResp__init__

def ListHostsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

ListHostsResp.__getstate__ = lambda self: self.__dict__.copy()
ListHostsResp.__setstate__ = ListHostsResp__setstate__

all_structs.append(PartItem)
PartItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'part_id', None, None, 0, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 1, ), # 2
  (3, TType.LIST, 'peers', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 0, ), # 3
  (4, TType.LIST, 'losts', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 0, ), # 4
)

PartItem.thrift_struct_annotations = {
}
PartItem.thrift_field_annotations = {
}

def PartItem__init__(self, part_id=None, leader=None, peers=None, losts=None,):
  self.part_id = part_id
  self.leader = leader
  self.peers = peers
  self.losts = losts

PartItem.__init__ = PartItem__init__

def PartItem__setstate__(self, state):
  state.setdefault('part_id', None)
  state.setdefault('leader', None)
  state.setdefault('peers', None)
  state.setdefault('losts', None)
  self.__dict__ = state

PartItem.__getstate__ = lambda self: self.__dict__.copy()
PartItem.__setstate__ = PartItem__setstate__

all_structs.append(ListPartsReq)
ListPartsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.LIST, 'part_ids', (TType.I32,None), None, 2, ), # 2
)

ListPartsReq.thrift_struct_annotations = {
}
ListPartsReq.thrift_field_annotations = {
}

def ListPartsReq__init__(self, space_id=None, part_ids=None,):
  self.space_id = space_id
  self.part_ids = part_ids

ListPartsReq.__init__ = ListPartsReq__init__

def ListPartsReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('part_ids', None)
  self.__dict__ = state

ListPartsReq.__getstate__ = lambda self: self.__dict__.copy()
ListPartsReq.__setstate__ = ListPartsReq__setstate__

all_structs.append(ListPartsResp)
ListPartsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'parts', (TType.STRUCT,[PartItem, PartItem.thrift_spec, False]), None, 2, ), # 3
)

ListPartsResp.thrift_struct_annotations = {
}
ListPartsResp.thrift_field_annotations = {
}

def ListPartsResp__init__(self, code=None, leader=None, parts=None,):
  self.code = code
  self.leader = leader
  self.parts = parts

ListPartsResp.__init__ = ListPartsResp__init__

def ListPartsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('parts', None)
  self.__dict__ = state

ListPartsResp.__getstate__ = lambda self: self.__dict__.copy()
ListPartsResp.__setstate__ = ListPartsResp__setstate__

all_structs.append(GetPartsAllocReq)
GetPartsAllocReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

GetPartsAllocReq.thrift_struct_annotations = {
}
GetPartsAllocReq.thrift_field_annotations = {
}

def GetPartsAllocReq__init__(self, space_id=None,):
  self.space_id = space_id

GetPartsAllocReq.__init__ = GetPartsAllocReq__init__

def GetPartsAllocReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

GetPartsAllocReq.__getstate__ = lambda self: self.__dict__.copy()
GetPartsAllocReq.__setstate__ = GetPartsAllocReq__setstate__

all_structs.append(GetPartsAllocResp)
GetPartsAllocResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'parts', (TType.I32,None,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False])), None, 2, ), # 3
  (4, TType.MAP, 'terms', (TType.I32,None,TType.I64,None), None, 1, ), # 4
)

GetPartsAllocResp.thrift_struct_annotations = {
}
GetPartsAllocResp.thrift_field_annotations = {
}

def GetPartsAllocResp__init__(self, code=None, leader=None, parts=None, terms=None,):
  self.code = code
  self.leader = leader
  self.parts = parts
  self.terms = terms

GetPartsAllocResp.__init__ = GetPartsAllocResp__init__

def GetPartsAllocResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('parts', None)
  state.setdefault('terms', None)
  self.__dict__ = state

GetPartsAllocResp.__getstate__ = lambda self: self.__dict__.copy()
GetPartsAllocResp.__setstate__ = GetPartsAllocResp__setstate__

all_structs.append(GetWorkerIdReq)
GetWorkerIdReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'host', False, None, 2, ), # 1
)

GetWorkerIdReq.thrift_struct_annotations = {
}
GetWorkerIdReq.thrift_field_annotations = {
}

def GetWorkerIdReq__init__(self, host=None,):
  self.host = host

GetWorkerIdReq.__init__ = GetWorkerIdReq__init__

def GetWorkerIdReq__setstate__(self, state):
  state.setdefault('host', None)
  self.__dict__ = state

GetWorkerIdReq.__getstate__ = lambda self: self.__dict__.copy()
GetWorkerIdReq.__setstate__ = GetWorkerIdReq__setstate__

all_structs.append(GetWorkerIdResp)
GetWorkerIdResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I64, 'workerid', None, None, 2, ), # 3
)

GetWorkerIdResp.thrift_struct_annotations = {
}
GetWorkerIdResp.thrift_field_annotations = {
}

def GetWorkerIdResp__init__(self, code=None, leader=None, workerid=None,):
  self.code = code
  self.leader = leader
  self.workerid = workerid

GetWorkerIdResp.__init__ = GetWorkerIdResp__init__

def GetWorkerIdResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('workerid', None)
  self.__dict__ = state

GetWorkerIdResp.__getstate__ = lambda self: self.__dict__.copy()
GetWorkerIdResp.__setstate__ = GetWorkerIdResp__setstate__

all_structs.append(MultiPutReq)
MultiPutReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.LIST, 'pairs', (TType.STRUCT,[nebula3.common.ttypes.KeyValue, nebula3.common.ttypes.KeyValue.thrift_spec, False]), None, 2, ), # 2
)

MultiPutReq.thrift_struct_annotations = {
}
MultiPutReq.thrift_field_annotations = {
}

def MultiPutReq__init__(self, segment=None, pairs=None,):
  self.segment = segment
  self.pairs = pairs

MultiPutReq.__init__ = MultiPutReq__init__

def MultiPutReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('pairs', None)
  self.__dict__ = state

MultiPutReq.__getstate__ = lambda self: self.__dict__.copy()
MultiPutReq.__setstate__ = MultiPutReq__setstate__

all_structs.append(GetReq)
GetReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'key', False, None, 2, ), # 2
)

GetReq.thrift_struct_annotations = {
}
GetReq.thrift_field_annotations = {
}

def GetReq__init__(self, segment=None, key=None,):
  self.segment = segment
  self.key = key

GetReq.__init__ = GetReq__init__

def GetReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('key', None)
  self.__dict__ = state

GetReq.__getstate__ = lambda self: self.__dict__.copy()
GetReq.__setstate__ = GetReq__setstate__

all_structs.append(GetResp)
GetResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'value', False, None, 2, ), # 3
)

GetResp.thrift_struct_annotations = {
}
GetResp.thrift_field_annotations = {
}

def GetResp__init__(self, code=None, leader=None, value=None,):
  self.code = code
  self.leader = leader
  self.value = value

GetResp.__init__ = GetResp__init__

def GetResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('value', None)
  self.__dict__ = state

GetResp.__getstate__ = lambda self: self.__dict__.copy()
GetResp.__setstate__ = GetResp__setstate__

all_structs.append(MultiGetReq)
MultiGetReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.LIST, 'keys', (TType.STRING,False), None, 2, ), # 2
)

MultiGetReq.thrift_struct_annotations = {
}
MultiGetReq.thrift_field_annotations = {
}

def MultiGetReq__init__(self, segment=None, keys=None,):
  self.segment = segment
  self.keys = keys

MultiGetReq.__init__ = MultiGetReq__init__

def MultiGetReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('keys', None)
  self.__dict__ = state

MultiGetReq.__getstate__ = lambda self: self.__dict__.copy()
MultiGetReq.__setstate__ = MultiGetReq__setstate__

all_structs.append(MultiGetResp)
MultiGetResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'values', (TType.STRING,False), None, 2, ), # 3
)

MultiGetResp.thrift_struct_annotations = {
}
MultiGetResp.thrift_field_annotations = {
}

def MultiGetResp__init__(self, code=None, leader=None, values=None,):
  self.code = code
  self.leader = leader
  self.values = values

MultiGetResp.__init__ = MultiGetResp__init__

def MultiGetResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('values', None)
  self.__dict__ = state

MultiGetResp.__getstate__ = lambda self: self.__dict__.copy()
MultiGetResp.__setstate__ = MultiGetResp__setstate__

all_structs.append(RemoveReq)
RemoveReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'key', False, None, 2, ), # 2
)

RemoveReq.thrift_struct_annotations = {
}
RemoveReq.thrift_field_annotations = {
}

def RemoveReq__init__(self, segment=None, key=None,):
  self.segment = segment
  self.key = key

RemoveReq.__init__ = RemoveReq__init__

def RemoveReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('key', None)
  self.__dict__ = state

RemoveReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveReq.__setstate__ = RemoveReq__setstate__

all_structs.append(RemoveRangeReq)
RemoveRangeReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'start', False, None, 2, ), # 2
  (3, TType.STRING, 'end', False, None, 2, ), # 3
)

RemoveRangeReq.thrift_struct_annotations = {
}
RemoveRangeReq.thrift_field_annotations = {
}

def RemoveRangeReq__init__(self, segment=None, start=None, end=None,):
  self.segment = segment
  self.start = start
  self.end = end

RemoveRangeReq.__init__ = RemoveRangeReq__init__

def RemoveRangeReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('start', None)
  state.setdefault('end', None)
  self.__dict__ = state

RemoveRangeReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveRangeReq.__setstate__ = RemoveRangeReq__setstate__

all_structs.append(ScanReq)
ScanReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'segment', False, None, 2, ), # 1
  (2, TType.STRING, 'start', False, None, 2, ), # 2
  (3, TType.STRING, 'end', False, None, 2, ), # 3
)

ScanReq.thrift_struct_annotations = {
}
ScanReq.thrift_field_annotations = {
}

def ScanReq__init__(self, segment=None, start=None, end=None,):
  self.segment = segment
  self.start = start
  self.end = end

ScanReq.__init__ = ScanReq__init__

def ScanReq__setstate__(self, state):
  state.setdefault('segment', None)
  state.setdefault('start', None)
  state.setdefault('end', None)
  self.__dict__ = state

ScanReq.__getstate__ = lambda self: self.__dict__.copy()
ScanReq.__setstate__ = ScanReq__setstate__

all_structs.append(ScanResp)
ScanResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'values', (TType.STRING,False), None, 2, ), # 3
)

ScanResp.thrift_struct_annotations = {
}
ScanResp.thrift_field_annotations = {
}

def ScanResp__init__(self, code=None, leader=None, values=None,):
  self.code = code
  self.leader = leader
  self.values = values

ScanResp.__init__ = ScanResp__init__

def ScanResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('values', None)
  self.__dict__ = state

ScanResp.__getstate__ = lambda self: self.__dict__.copy()
ScanResp.__setstate__ = ScanResp__setstate__

all_structs.append(HBResp)
HBResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I64, 'cluster_id', None, None, 2, ), # 3
  (4, TType.I64, 'last_update_time_in_ms', None, None, 2, ), # 4
  (5, TType.I32, 'meta_version', None, None, 2, ), # 5
)

HBResp.thrift_struct_annotations = {
}
HBResp.thrift_field_annotations = {
}

def HBResp__init__(self, code=None, leader=None, cluster_id=None, last_update_time_in_ms=None, meta_version=None,):
  self.code = code
  self.leader = leader
  self.cluster_id = cluster_id
  self.last_update_time_in_ms = last_update_time_in_ms
  self.meta_version = meta_version

HBResp.__init__ = HBResp__init__

def HBResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('cluster_id', None)
  state.setdefault('last_update_time_in_ms', None)
  state.setdefault('meta_version', None)
  self.__dict__ = state

HBResp.__getstate__ = lambda self: self.__dict__.copy()
HBResp.__setstate__ = HBResp__setstate__

all_structs.append(LeaderInfo)
LeaderInfo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'part_id', None, None, 2, ), # 1
  (2, TType.I64, 'term', None, None, 2, ), # 2
)

LeaderInfo.thrift_struct_annotations = {
}
LeaderInfo.thrift_field_annotations = {
}

def LeaderInfo__init__(self, part_id=None, term=None,):
  self.part_id = part_id
  self.term = term

LeaderInfo.__init__ = LeaderInfo__init__

def LeaderInfo__setstate__(self, state):
  state.setdefault('part_id', None)
  state.setdefault('term', None)
  self.__dict__ = state

LeaderInfo.__getstate__ = lambda self: self.__dict__.copy()
LeaderInfo.__setstate__ = LeaderInfo__setstate__

all_structs.append(PartitionList)
PartitionList.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'part_list', (TType.I32,None), None, 2, ), # 1
)

PartitionList.thrift_struct_annotations = {
}
PartitionList.thrift_field_annotations = {
}

def PartitionList__init__(self, part_list=None,):
  self.part_list = part_list

PartitionList.__init__ = PartitionList__init__

def PartitionList__setstate__(self, state):
  state.setdefault('part_list', None)
  self.__dict__ = state

PartitionList.__getstate__ = lambda self: self.__dict__.copy()
PartitionList.__setstate__ = PartitionList__setstate__

all_structs.append(HBReq)
HBReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'role', HostRole, None, 2, ), # 1
  (2, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I64, 'cluster_id', None, None, 2, ), # 3
  (4, TType.MAP, 'leader_partIds', (TType.I32,None,TType.LIST,(TType.STRUCT,[LeaderInfo, LeaderInfo.thrift_spec, False])), None, 1, ), # 4
  (5, TType.STRING, 'git_info_sha', False, None, 2, ), # 5
  (6, TType.MAP, 'disk_parts', (TType.I32,None,TType.MAP,(TType.STRING,False,TType.STRUCT,[PartitionList, PartitionList.thrift_spec, False])), None, 1, ), # 6
  (7, TType.STRUCT, 'dir', [nebula3.common.ttypes.DirInfo, nebula3.common.ttypes.DirInfo.thrift_spec, False], None, 1, ), # 7
  (8, TType.STRING, 'version', False, None, 1, ), # 8
)

HBReq.thrift_struct_annotations = {
}
HBReq.thrift_field_annotations = {
}

def HBReq__init__(self, role=None, host=None, cluster_id=None, leader_partIds=None, git_info_sha=None, disk_parts=None, dir=None, version=None,):
  self.role = role
  self.host = host
  self.cluster_id = cluster_id
  self.leader_partIds = leader_partIds
  self.git_info_sha = git_info_sha
  self.disk_parts = disk_parts
  self.dir = dir
  self.version = version

HBReq.__init__ = HBReq__init__

def HBReq__setstate__(self, state):
  state.setdefault('role', None)
  state.setdefault('host', None)
  state.setdefault('cluster_id', None)
  state.setdefault('leader_partIds', None)
  state.setdefault('git_info_sha', None)
  state.setdefault('disk_parts', None)
  state.setdefault('dir', None)
  state.setdefault('version', None)
  self.__dict__ = state

HBReq.__getstate__ = lambda self: self.__dict__.copy()
HBReq.__setstate__ = HBReq__setstate__

all_structs.append(ServiceInfo)
ServiceInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dir', [nebula3.common.ttypes.DirInfo, nebula3.common.ttypes.DirInfo.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'addr', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'role', HostRole, None, 2, ), # 3
)

ServiceInfo.thrift_struct_annotations = {
}
ServiceInfo.thrift_field_annotations = {
}

def ServiceInfo__init__(self, dir=None, addr=None, role=None,):
  self.dir = dir
  self.addr = addr
  self.role = role

ServiceInfo.__init__ = ServiceInfo__init__

def ServiceInfo__setstate__(self, state):
  state.setdefault('dir', None)
  state.setdefault('addr', None)
  state.setdefault('role', None)
  self.__dict__ = state

ServiceInfo.__getstate__ = lambda self: self.__dict__.copy()
ServiceInfo.__setstate__ = ServiceInfo__setstate__

all_structs.append(AgentHBReq)
AgentHBReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'git_info_sha', False, None, 2, ), # 2
  (3, TType.STRING, 'version', False, None, 1, ), # 3
)

AgentHBReq.thrift_struct_annotations = {
}
AgentHBReq.thrift_field_annotations = {
}

def AgentHBReq__init__(self, host=None, git_info_sha=None, version=None,):
  self.host = host
  self.git_info_sha = git_info_sha
  self.version = version

AgentHBReq.__init__ = AgentHBReq__init__

def AgentHBReq__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('git_info_sha', None)
  state.setdefault('version', None)
  self.__dict__ = state

AgentHBReq.__getstate__ = lambda self: self.__dict__.copy()
AgentHBReq.__setstate__ = AgentHBReq__setstate__

all_structs.append(AgentHBResp)
AgentHBResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'service_list', (TType.STRUCT,[ServiceInfo, ServiceInfo.thrift_spec, False]), None, 2, ), # 3
)

AgentHBResp.thrift_struct_annotations = {
}
AgentHBResp.thrift_field_annotations = {
}

def AgentHBResp__init__(self, code=None, leader=None, service_list=None,):
  self.code = code
  self.leader = leader
  self.service_list = service_list

AgentHBResp.__init__ = AgentHBResp__init__

def AgentHBResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('service_list', None)
  self.__dict__ = state

AgentHBResp.__getstate__ = lambda self: self.__dict__.copy()
AgentHBResp.__setstate__ = AgentHBResp__setstate__

all_structs.append(IndexFieldDef)
IndexFieldDef.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 0, ), # 1
  (2, TType.I16, 'type_length', None, None, 1, ), # 2
)

IndexFieldDef.thrift_struct_annotations = {
}
IndexFieldDef.thrift_field_annotations = {
}

def IndexFieldDef__init__(self, name=None, type_length=None,):
  self.name = name
  self.type_length = type_length

IndexFieldDef.__init__ = IndexFieldDef__init__

def IndexFieldDef__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('type_length', None)
  self.__dict__ = state

IndexFieldDef.__getstate__ = lambda self: self.__dict__.copy()
IndexFieldDef.__setstate__ = IndexFieldDef__setstate__

all_structs.append(CreateTagIndexReq)
CreateTagIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.STRING, 'tag_name', False, None, 2, ), # 3
  (4, TType.LIST, 'fields', (TType.STRUCT,[IndexFieldDef, IndexFieldDef.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'if_not_exists', None, None, 2, ), # 5
  (6, TType.STRING, 'comment', False, None, 1, ), # 6
  (7, TType.STRUCT, 'index_params', [IndexParams, IndexParams.thrift_spec, False], None, 1, ), # 7
)

CreateTagIndexReq.thrift_struct_annotations = {
}
CreateTagIndexReq.thrift_field_annotations = {
}

def CreateTagIndexReq__init__(self, space_id=None, index_name=None, tag_name=None, fields=None, if_not_exists=None, comment=None, index_params=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.tag_name = tag_name
  self.fields = fields
  self.if_not_exists = if_not_exists
  self.comment = comment
  self.index_params = index_params

CreateTagIndexReq.__init__ = CreateTagIndexReq__init__

def CreateTagIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('tag_name', None)
  state.setdefault('fields', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('comment', None)
  state.setdefault('index_params', None)
  self.__dict__ = state

CreateTagIndexReq.__getstate__ = lambda self: self.__dict__.copy()
CreateTagIndexReq.__setstate__ = CreateTagIndexReq__setstate__

all_structs.append(DropTagIndexReq)
DropTagIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropTagIndexReq.thrift_struct_annotations = {
}
DropTagIndexReq.thrift_field_annotations = {
}

def DropTagIndexReq__init__(self, space_id=None, index_name=None, if_exists=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.if_exists = if_exists

DropTagIndexReq.__init__ = DropTagIndexReq__init__

def DropTagIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropTagIndexReq.__getstate__ = lambda self: self.__dict__.copy()
DropTagIndexReq.__setstate__ = DropTagIndexReq__setstate__

all_structs.append(GetTagIndexReq)
GetTagIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
)

GetTagIndexReq.thrift_struct_annotations = {
}
GetTagIndexReq.thrift_field_annotations = {
}

def GetTagIndexReq__init__(self, space_id=None, index_name=None,):
  self.space_id = space_id
  self.index_name = index_name

GetTagIndexReq.__init__ = GetTagIndexReq__init__

def GetTagIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  self.__dict__ = state

GetTagIndexReq.__getstate__ = lambda self: self.__dict__.copy()
GetTagIndexReq.__setstate__ = GetTagIndexReq__setstate__

all_structs.append(GetTagIndexResp)
GetTagIndexResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'item', [IndexItem, IndexItem.thrift_spec, False], None, 2, ), # 3
)

GetTagIndexResp.thrift_struct_annotations = {
}
GetTagIndexResp.thrift_field_annotations = {
}

def GetTagIndexResp__init__(self, code=None, leader=None, item=None,):
  self.code = code
  self.leader = leader
  self.item = item

GetTagIndexResp.__init__ = GetTagIndexResp__init__

def GetTagIndexResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('item', None)
  self.__dict__ = state

GetTagIndexResp.__getstate__ = lambda self: self.__dict__.copy()
GetTagIndexResp.__setstate__ = GetTagIndexResp__setstate__

all_structs.append(ListTagIndexesReq)
ListTagIndexesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListTagIndexesReq.thrift_struct_annotations = {
}
ListTagIndexesReq.thrift_field_annotations = {
}

def ListTagIndexesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListTagIndexesReq.__init__ = ListTagIndexesReq__init__

def ListTagIndexesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListTagIndexesReq.__getstate__ = lambda self: self.__dict__.copy()
ListTagIndexesReq.__setstate__ = ListTagIndexesReq__setstate__

all_structs.append(ListTagIndexesResp)
ListTagIndexesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[IndexItem, IndexItem.thrift_spec, False]), None, 2, ), # 3
)

ListTagIndexesResp.thrift_struct_annotations = {
}
ListTagIndexesResp.thrift_field_annotations = {
}

def ListTagIndexesResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

ListTagIndexesResp.__init__ = ListTagIndexesResp__init__

def ListTagIndexesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

ListTagIndexesResp.__getstate__ = lambda self: self.__dict__.copy()
ListTagIndexesResp.__setstate__ = ListTagIndexesResp__setstate__

all_structs.append(CreateEdgeIndexReq)
CreateEdgeIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.STRING, 'edge_name', False, None, 2, ), # 3
  (4, TType.LIST, 'fields', (TType.STRUCT,[IndexFieldDef, IndexFieldDef.thrift_spec, False]), None, 2, ), # 4
  (5, TType.BOOL, 'if_not_exists', None, None, 2, ), # 5
  (6, TType.STRING, 'comment', False, None, 1, ), # 6
  (7, TType.STRUCT, 'index_params', [IndexParams, IndexParams.thrift_spec, False], None, 1, ), # 7
)

CreateEdgeIndexReq.thrift_struct_annotations = {
}
CreateEdgeIndexReq.thrift_field_annotations = {
}

def CreateEdgeIndexReq__init__(self, space_id=None, index_name=None, edge_name=None, fields=None, if_not_exists=None, comment=None, index_params=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.edge_name = edge_name
  self.fields = fields
  self.if_not_exists = if_not_exists
  self.comment = comment
  self.index_params = index_params

CreateEdgeIndexReq.__init__ = CreateEdgeIndexReq__init__

def CreateEdgeIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('edge_name', None)
  state.setdefault('fields', None)
  state.setdefault('if_not_exists', None)
  state.setdefault('comment', None)
  state.setdefault('index_params', None)
  self.__dict__ = state

CreateEdgeIndexReq.__getstate__ = lambda self: self.__dict__.copy()
CreateEdgeIndexReq.__setstate__ = CreateEdgeIndexReq__setstate__

all_structs.append(DropEdgeIndexReq)
DropEdgeIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_exists', None, None, 2, ), # 3
)

DropEdgeIndexReq.thrift_struct_annotations = {
}
DropEdgeIndexReq.thrift_field_annotations = {
}

def DropEdgeIndexReq__init__(self, space_id=None, index_name=None, if_exists=None,):
  self.space_id = space_id
  self.index_name = index_name
  self.if_exists = if_exists

DropEdgeIndexReq.__init__ = DropEdgeIndexReq__init__

def DropEdgeIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropEdgeIndexReq.__getstate__ = lambda self: self.__dict__.copy()
DropEdgeIndexReq.__setstate__ = DropEdgeIndexReq__setstate__

all_structs.append(GetEdgeIndexReq)
GetEdgeIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
)

GetEdgeIndexReq.thrift_struct_annotations = {
}
GetEdgeIndexReq.thrift_field_annotations = {
}

def GetEdgeIndexReq__init__(self, space_id=None, index_name=None,):
  self.space_id = space_id
  self.index_name = index_name

GetEdgeIndexReq.__init__ = GetEdgeIndexReq__init__

def GetEdgeIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  self.__dict__ = state

GetEdgeIndexReq.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeIndexReq.__setstate__ = GetEdgeIndexReq__setstate__

all_structs.append(GetEdgeIndexResp)
GetEdgeIndexResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'item', [IndexItem, IndexItem.thrift_spec, False], None, 2, ), # 3
)

GetEdgeIndexResp.thrift_struct_annotations = {
}
GetEdgeIndexResp.thrift_field_annotations = {
}

def GetEdgeIndexResp__init__(self, code=None, leader=None, item=None,):
  self.code = code
  self.leader = leader
  self.item = item

GetEdgeIndexResp.__init__ = GetEdgeIndexResp__init__

def GetEdgeIndexResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('item', None)
  self.__dict__ = state

GetEdgeIndexResp.__getstate__ = lambda self: self.__dict__.copy()
GetEdgeIndexResp.__setstate__ = GetEdgeIndexResp__setstate__

all_structs.append(ListEdgeIndexesReq)
ListEdgeIndexesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListEdgeIndexesReq.thrift_struct_annotations = {
}
ListEdgeIndexesReq.thrift_field_annotations = {
}

def ListEdgeIndexesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListEdgeIndexesReq.__init__ = ListEdgeIndexesReq__init__

def ListEdgeIndexesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListEdgeIndexesReq.__getstate__ = lambda self: self.__dict__.copy()
ListEdgeIndexesReq.__setstate__ = ListEdgeIndexesReq__setstate__

all_structs.append(ListEdgeIndexesResp)
ListEdgeIndexesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[IndexItem, IndexItem.thrift_spec, False]), None, 2, ), # 3
)

ListEdgeIndexesResp.thrift_struct_annotations = {
}
ListEdgeIndexesResp.thrift_field_annotations = {
}

def ListEdgeIndexesResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

ListEdgeIndexesResp.__init__ = ListEdgeIndexesResp__init__

def ListEdgeIndexesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

ListEdgeIndexesResp.__getstate__ = lambda self: self.__dict__.copy()
ListEdgeIndexesResp.__setstate__ = ListEdgeIndexesResp__setstate__

all_structs.append(RebuildIndexReq)
RebuildIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'index_name', False, None, 2, ), # 2
)

RebuildIndexReq.thrift_struct_annotations = {
}
RebuildIndexReq.thrift_field_annotations = {
}

def RebuildIndexReq__init__(self, space_id=None, index_name=None,):
  self.space_id = space_id
  self.index_name = index_name

RebuildIndexReq.__init__ = RebuildIndexReq__init__

def RebuildIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('index_name', None)
  self.__dict__ = state

RebuildIndexReq.__getstate__ = lambda self: self.__dict__.copy()
RebuildIndexReq.__setstate__ = RebuildIndexReq__setstate__

all_structs.append(CreateUserReq)
CreateUserReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.STRING, 'encoded_pwd', False, None, 2, ), # 2
  (3, TType.BOOL, 'if_not_exists', None, None, 2, ), # 3
)

CreateUserReq.thrift_struct_annotations = {
}
CreateUserReq.thrift_field_annotations = {
}

def CreateUserReq__init__(self, account=None, encoded_pwd=None, if_not_exists=None,):
  self.account = account
  self.encoded_pwd = encoded_pwd
  self.if_not_exists = if_not_exists

CreateUserReq.__init__ = CreateUserReq__init__

def CreateUserReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('encoded_pwd', None)
  state.setdefault('if_not_exists', None)
  self.__dict__ = state

CreateUserReq.__getstate__ = lambda self: self.__dict__.copy()
CreateUserReq.__setstate__ = CreateUserReq__setstate__

all_structs.append(DropUserReq)
DropUserReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.BOOL, 'if_exists', None, None, 2, ), # 2
)

DropUserReq.thrift_struct_annotations = {
}
DropUserReq.thrift_field_annotations = {
}

def DropUserReq__init__(self, account=None, if_exists=None,):
  self.account = account
  self.if_exists = if_exists

DropUserReq.__init__ = DropUserReq__init__

def DropUserReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('if_exists', None)
  self.__dict__ = state

DropUserReq.__getstate__ = lambda self: self.__dict__.copy()
DropUserReq.__setstate__ = DropUserReq__setstate__

all_structs.append(AlterUserReq)
AlterUserReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.STRING, 'encoded_pwd', False, None, 2, ), # 2
)

AlterUserReq.thrift_struct_annotations = {
}
AlterUserReq.thrift_field_annotations = {
}

def AlterUserReq__init__(self, account=None, encoded_pwd=None,):
  self.account = account
  self.encoded_pwd = encoded_pwd

AlterUserReq.__init__ = AlterUserReq__init__

def AlterUserReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('encoded_pwd', None)
  self.__dict__ = state

AlterUserReq.__getstate__ = lambda self: self.__dict__.copy()
AlterUserReq.__setstate__ = AlterUserReq__setstate__

all_structs.append(GrantRoleReq)
GrantRoleReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'role_item', [RoleItem, RoleItem.thrift_spec, False], None, 2, ), # 1
)

GrantRoleReq.thrift_struct_annotations = {
}
GrantRoleReq.thrift_field_annotations = {
}

def GrantRoleReq__init__(self, role_item=None,):
  self.role_item = role_item

GrantRoleReq.__init__ = GrantRoleReq__init__

def GrantRoleReq__setstate__(self, state):
  state.setdefault('role_item', None)
  self.__dict__ = state

GrantRoleReq.__getstate__ = lambda self: self.__dict__.copy()
GrantRoleReq.__setstate__ = GrantRoleReq__setstate__

all_structs.append(RevokeRoleReq)
RevokeRoleReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'role_item', [RoleItem, RoleItem.thrift_spec, False], None, 2, ), # 1
)

RevokeRoleReq.thrift_struct_annotations = {
}
RevokeRoleReq.thrift_field_annotations = {
}

def RevokeRoleReq__init__(self, role_item=None,):
  self.role_item = role_item

RevokeRoleReq.__init__ = RevokeRoleReq__init__

def RevokeRoleReq__setstate__(self, state):
  state.setdefault('role_item', None)
  self.__dict__ = state

RevokeRoleReq.__getstate__ = lambda self: self.__dict__.copy()
RevokeRoleReq.__setstate__ = RevokeRoleReq__setstate__

all_structs.append(ListUsersReq)
ListUsersReq.thrift_spec = (
)

ListUsersReq.thrift_struct_annotations = {
}
ListUsersReq.thrift_field_annotations = {
}

all_structs.append(ListUsersResp)
ListUsersResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'users', (TType.STRING,False,TType.STRING,False), None, 2, ), # 3
)

ListUsersResp.thrift_struct_annotations = {
}
ListUsersResp.thrift_field_annotations = {
}

def ListUsersResp__init__(self, code=None, leader=None, users=None,):
  self.code = code
  self.leader = leader
  self.users = users

ListUsersResp.__init__ = ListUsersResp__init__

def ListUsersResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('users', None)
  self.__dict__ = state

ListUsersResp.__getstate__ = lambda self: self.__dict__.copy()
ListUsersResp.__setstate__ = ListUsersResp__setstate__

all_structs.append(ListRolesReq)
ListRolesReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListRolesReq.thrift_struct_annotations = {
}
ListRolesReq.thrift_field_annotations = {
}

def ListRolesReq__init__(self, space_id=None,):
  self.space_id = space_id

ListRolesReq.__init__ = ListRolesReq__init__

def ListRolesReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListRolesReq.__getstate__ = lambda self: self.__dict__.copy()
ListRolesReq.__setstate__ = ListRolesReq__setstate__

all_structs.append(ListRolesResp)
ListRolesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'roles', (TType.STRUCT,[RoleItem, RoleItem.thrift_spec, False]), None, 2, ), # 3
)

ListRolesResp.thrift_struct_annotations = {
}
ListRolesResp.thrift_field_annotations = {
}

def ListRolesResp__init__(self, code=None, leader=None, roles=None,):
  self.code = code
  self.leader = leader
  self.roles = roles

ListRolesResp.__init__ = ListRolesResp__init__

def ListRolesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('roles', None)
  self.__dict__ = state

ListRolesResp.__getstate__ = lambda self: self.__dict__.copy()
ListRolesResp.__setstate__ = ListRolesResp__setstate__

all_structs.append(GetUserRolesReq)
GetUserRolesReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
)

GetUserRolesReq.thrift_struct_annotations = {
}
GetUserRolesReq.thrift_field_annotations = {
}

def GetUserRolesReq__init__(self, account=None,):
  self.account = account

GetUserRolesReq.__init__ = GetUserRolesReq__init__

def GetUserRolesReq__setstate__(self, state):
  state.setdefault('account', None)
  self.__dict__ = state

GetUserRolesReq.__getstate__ = lambda self: self.__dict__.copy()
GetUserRolesReq.__setstate__ = GetUserRolesReq__setstate__

all_structs.append(ChangePasswordReq)
ChangePasswordReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'account', False, None, 2, ), # 1
  (2, TType.STRING, 'new_encoded_pwd', False, None, 2, ), # 2
  (3, TType.STRING, 'old_encoded_pwd', False, None, 2, ), # 3
)

ChangePasswordReq.thrift_struct_annotations = {
}
ChangePasswordReq.thrift_field_annotations = {
}

def ChangePasswordReq__init__(self, account=None, new_encoded_pwd=None, old_encoded_pwd=None,):
  self.account = account
  self.new_encoded_pwd = new_encoded_pwd
  self.old_encoded_pwd = old_encoded_pwd

ChangePasswordReq.__init__ = ChangePasswordReq__init__

def ChangePasswordReq__setstate__(self, state):
  state.setdefault('account', None)
  state.setdefault('new_encoded_pwd', None)
  state.setdefault('old_encoded_pwd', None)
  self.__dict__ = state

ChangePasswordReq.__getstate__ = lambda self: self.__dict__.copy()
ChangePasswordReq.__setstate__ = ChangePasswordReq__setstate__

all_structs.append(BalanceTask)
BalanceTask.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'id', False, None, 2, ), # 1
  (2, TType.STRING, 'command', False, None, 2, ), # 2
  (3, TType.I32, 'result', TaskResult, None, 2, ), # 3
  (4, TType.I64, 'start_time', None, None, 2, ), # 4
  (5, TType.I64, 'stop_time', None, None, 2, ), # 5
)

BalanceTask.thrift_struct_annotations = {
}
BalanceTask.thrift_field_annotations = {
}

def BalanceTask__init__(self, id=None, command=None, result=None, start_time=None, stop_time=None,):
  self.id = id
  self.command = command
  self.result = result
  self.start_time = start_time
  self.stop_time = stop_time

BalanceTask.__init__ = BalanceTask__init__

def BalanceTask__setstate__(self, state):
  state.setdefault('id', None)
  state.setdefault('command', None)
  state.setdefault('result', None)
  state.setdefault('start_time', None)
  state.setdefault('stop_time', None)
  self.__dict__ = state

BalanceTask.__getstate__ = lambda self: self.__dict__.copy()
BalanceTask.__setstate__ = BalanceTask__setstate__

all_structs.append(ConfigItem)
ConfigItem.thrift_spec = (
  None, # 0
  (1, TType.I32, 'module', ConfigModule, None, 2, ), # 1
  (2, TType.STRING, 'name', False, None, 2, ), # 2
  (3, TType.I32, 'mode', ConfigMode, None, 2, ), # 3
  (4, TType.STRUCT, 'value', [nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True], None, 2, ), # 4
)

ConfigItem.thrift_struct_annotations = {
}
ConfigItem.thrift_field_annotations = {
}

def ConfigItem__init__(self, module=None, name=None, mode=None, value=None,):
  self.module = module
  self.name = name
  self.mode = mode
  self.value = value

ConfigItem.__init__ = ConfigItem__init__

def ConfigItem__setstate__(self, state):
  state.setdefault('module', None)
  state.setdefault('name', None)
  state.setdefault('mode', None)
  state.setdefault('value', None)
  self.__dict__ = state

ConfigItem.__getstate__ = lambda self: self.__dict__.copy()
ConfigItem.__setstate__ = ConfigItem__setstate__

all_structs.append(RegConfigReq)
RegConfigReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'items', (TType.STRUCT,[ConfigItem, ConfigItem.thrift_spec, False]), None, 2, ), # 1
)

RegConfigReq.thrift_struct_annotations = {
}
RegConfigReq.thrift_field_annotations = {
}

def RegConfigReq__init__(self, items=None,):
  self.items = items

RegConfigReq.__init__ = RegConfigReq__init__

def RegConfigReq__setstate__(self, state):
  state.setdefault('items', None)
  self.__dict__ = state

RegConfigReq.__getstate__ = lambda self: self.__dict__.copy()
RegConfigReq.__setstate__ = RegConfigReq__setstate__

all_structs.append(GetConfigReq)
GetConfigReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'item', [ConfigItem, ConfigItem.thrift_spec, False], None, 2, ), # 1
)

GetConfigReq.thrift_struct_annotations = {
}
GetConfigReq.thrift_field_annotations = {
}

def GetConfigReq__init__(self, item=None,):
  self.item = item

GetConfigReq.__init__ = GetConfigReq__init__

def GetConfigReq__setstate__(self, state):
  state.setdefault('item', None)
  self.__dict__ = state

GetConfigReq.__getstate__ = lambda self: self.__dict__.copy()
GetConfigReq.__setstate__ = GetConfigReq__setstate__

all_structs.append(GetConfigResp)
GetConfigResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[ConfigItem, ConfigItem.thrift_spec, False]), None, 2, ), # 3
)

GetConfigResp.thrift_struct_annotations = {
}
GetConfigResp.thrift_field_annotations = {
}

def GetConfigResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

GetConfigResp.__init__ = GetConfigResp__init__

def GetConfigResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

GetConfigResp.__getstate__ = lambda self: self.__dict__.copy()
GetConfigResp.__setstate__ = GetConfigResp__setstate__

all_structs.append(SetConfigReq)
SetConfigReq.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'item', [ConfigItem, ConfigItem.thrift_spec, False], None, 2, ), # 1
)

SetConfigReq.thrift_struct_annotations = {
}
SetConfigReq.thrift_field_annotations = {
}

def SetConfigReq__init__(self, item=None,):
  self.item = item

SetConfigReq.__init__ = SetConfigReq__init__

def SetConfigReq__setstate__(self, state):
  state.setdefault('item', None)
  self.__dict__ = state

SetConfigReq.__getstate__ = lambda self: self.__dict__.copy()
SetConfigReq.__setstate__ = SetConfigReq__setstate__

all_structs.append(ListConfigsReq)
ListConfigsReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'space', False, None, 2, ), # 1
  (2, TType.I32, 'module', ConfigModule, None, 2, ), # 2
)

ListConfigsReq.thrift_struct_annotations = {
}
ListConfigsReq.thrift_field_annotations = {
}

def ListConfigsReq__init__(self, space=None, module=None,):
  self.space = space
  self.module = module

ListConfigsReq.__init__ = ListConfigsReq__init__

def ListConfigsReq__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('module', None)
  self.__dict__ = state

ListConfigsReq.__getstate__ = lambda self: self.__dict__.copy()
ListConfigsReq.__setstate__ = ListConfigsReq__setstate__

all_structs.append(ListConfigsResp)
ListConfigsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'items', (TType.STRUCT,[ConfigItem, ConfigItem.thrift_spec, False]), None, 2, ), # 3
)

ListConfigsResp.thrift_struct_annotations = {
}
ListConfigsResp.thrift_field_annotations = {
}

def ListConfigsResp__init__(self, code=None, leader=None, items=None,):
  self.code = code
  self.leader = leader
  self.items = items

ListConfigsResp.__init__ = ListConfigsResp__init__

def ListConfigsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('items', None)
  self.__dict__ = state

ListConfigsResp.__getstate__ = lambda self: self.__dict__.copy()
ListConfigsResp.__setstate__ = ListConfigsResp__setstate__

all_structs.append(CreateSnapshotReq)
CreateSnapshotReq.thrift_spec = (
)

CreateSnapshotReq.thrift_struct_annotations = {
}
CreateSnapshotReq.thrift_field_annotations = {
}

all_structs.append(DropSnapshotReq)
DropSnapshotReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
)

DropSnapshotReq.thrift_struct_annotations = {
}
DropSnapshotReq.thrift_field_annotations = {
}

def DropSnapshotReq__init__(self, name=None,):
  self.name = name

DropSnapshotReq.__init__ = DropSnapshotReq__init__

def DropSnapshotReq__setstate__(self, state):
  state.setdefault('name', None)
  self.__dict__ = state

DropSnapshotReq.__getstate__ = lambda self: self.__dict__.copy()
DropSnapshotReq.__setstate__ = DropSnapshotReq__setstate__

all_structs.append(ListSnapshotsReq)
ListSnapshotsReq.thrift_spec = (
)

ListSnapshotsReq.thrift_struct_annotations = {
}
ListSnapshotsReq.thrift_field_annotations = {
}

all_structs.append(Snapshot)
Snapshot.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.I32, 'status', SnapshotStatus, None, 2, ), # 2
  (3, TType.STRING, 'hosts', False, None, 2, ), # 3
)

Snapshot.thrift_struct_annotations = {
}
Snapshot.thrift_field_annotations = {
}

def Snapshot__init__(self, name=None, status=None, hosts=None,):
  self.name = name
  self.status = status
  self.hosts = hosts

Snapshot.__init__ = Snapshot__init__

def Snapshot__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('status', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

Snapshot.__getstate__ = lambda self: self.__dict__.copy()
Snapshot.__setstate__ = Snapshot__setstate__

all_structs.append(ListSnapshotsResp)
ListSnapshotsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'snapshots', (TType.STRUCT,[Snapshot, Snapshot.thrift_spec, False]), None, 2, ), # 3
)

ListSnapshotsResp.thrift_struct_annotations = {
}
ListSnapshotsResp.thrift_field_annotations = {
}

def ListSnapshotsResp__init__(self, code=None, leader=None, snapshots=None,):
  self.code = code
  self.leader = leader
  self.snapshots = snapshots

ListSnapshotsResp.__init__ = ListSnapshotsResp__init__

def ListSnapshotsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('snapshots', None)
  self.__dict__ = state

ListSnapshotsResp.__getstate__ = lambda self: self.__dict__.copy()
ListSnapshotsResp.__setstate__ = ListSnapshotsResp__setstate__

all_structs.append(ListIndexStatusReq)
ListIndexStatusReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListIndexStatusReq.thrift_struct_annotations = {
}
ListIndexStatusReq.thrift_field_annotations = {
}

def ListIndexStatusReq__init__(self, space_id=None,):
  self.space_id = space_id

ListIndexStatusReq.__init__ = ListIndexStatusReq__init__

def ListIndexStatusReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListIndexStatusReq.__getstate__ = lambda self: self.__dict__.copy()
ListIndexStatusReq.__setstate__ = ListIndexStatusReq__setstate__

all_structs.append(IndexStatus)
IndexStatus.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'name', False, None, 2, ), # 1
  (2, TType.STRING, 'status', False, None, 2, ), # 2
)

IndexStatus.thrift_struct_annotations = {
}
IndexStatus.thrift_field_annotations = {
}

def IndexStatus__init__(self, name=None, status=None,):
  self.name = name
  self.status = status

IndexStatus.__init__ = IndexStatus__init__

def IndexStatus__setstate__(self, state):
  state.setdefault('name', None)
  state.setdefault('status', None)
  self.__dict__ = state

IndexStatus.__getstate__ = lambda self: self.__dict__.copy()
IndexStatus.__setstate__ = IndexStatus__setstate__

all_structs.append(ListIndexStatusResp)
ListIndexStatusResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'statuses', (TType.STRUCT,[IndexStatus, IndexStatus.thrift_spec, False]), None, 2, ), # 3
)

ListIndexStatusResp.thrift_struct_annotations = {
}
ListIndexStatusResp.thrift_field_annotations = {
}

def ListIndexStatusResp__init__(self, code=None, leader=None, statuses=None,):
  self.code = code
  self.leader = leader
  self.statuses = statuses

ListIndexStatusResp.__init__ = ListIndexStatusResp__init__

def ListIndexStatusResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('statuses', None)
  self.__dict__ = state

ListIndexStatusResp.__getstate__ = lambda self: self.__dict__.copy()
ListIndexStatusResp.__setstate__ = ListIndexStatusResp__setstate__

all_structs.append(MergeZoneReq)
MergeZoneReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'zones', (TType.STRING,False), None, 2, ), # 1
  (2, TType.STRING, 'zone_name', False, None, 2, ), # 2
)

MergeZoneReq.thrift_struct_annotations = {
}
MergeZoneReq.thrift_field_annotations = {
}

def MergeZoneReq__init__(self, zones=None, zone_name=None,):
  self.zones = zones
  self.zone_name = zone_name

MergeZoneReq.__init__ = MergeZoneReq__init__

def MergeZoneReq__setstate__(self, state):
  state.setdefault('zones', None)
  state.setdefault('zone_name', None)
  self.__dict__ = state

MergeZoneReq.__getstate__ = lambda self: self.__dict__.copy()
MergeZoneReq.__setstate__ = MergeZoneReq__setstate__

all_structs.append(DropZoneReq)
DropZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
)

DropZoneReq.thrift_struct_annotations = {
}
DropZoneReq.thrift_field_annotations = {
}

def DropZoneReq__init__(self, zone_name=None,):
  self.zone_name = zone_name

DropZoneReq.__init__ = DropZoneReq__init__

def DropZoneReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  self.__dict__ = state

DropZoneReq.__getstate__ = lambda self: self.__dict__.copy()
DropZoneReq.__setstate__ = DropZoneReq__setstate__

all_structs.append(DivideZoneReq)
DivideZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
  (2, TType.MAP, 'zone_items', (TType.STRING,False,TType.LIST,(TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False])), None, 2, ), # 2
)

DivideZoneReq.thrift_struct_annotations = {
}
DivideZoneReq.thrift_field_annotations = {
}

def DivideZoneReq__init__(self, zone_name=None, zone_items=None,):
  self.zone_name = zone_name
  self.zone_items = zone_items

DivideZoneReq.__init__ = DivideZoneReq__init__

def DivideZoneReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  state.setdefault('zone_items', None)
  self.__dict__ = state

DivideZoneReq.__getstate__ = lambda self: self.__dict__.copy()
DivideZoneReq.__setstate__ = DivideZoneReq__setstate__

all_structs.append(RenameZoneReq)
RenameZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'original_zone_name', False, None, 2, ), # 1
  (2, TType.STRING, 'zone_name', False, None, 2, ), # 2
)

RenameZoneReq.thrift_struct_annotations = {
}
RenameZoneReq.thrift_field_annotations = {
}

def RenameZoneReq__init__(self, original_zone_name=None, zone_name=None,):
  self.original_zone_name = original_zone_name
  self.zone_name = zone_name

RenameZoneReq.__init__ = RenameZoneReq__init__

def RenameZoneReq__setstate__(self, state):
  state.setdefault('original_zone_name', None)
  state.setdefault('zone_name', None)
  self.__dict__ = state

RenameZoneReq.__getstate__ = lambda self: self.__dict__.copy()
RenameZoneReq.__setstate__ = RenameZoneReq__setstate__

all_structs.append(AddHostsIntoZoneReq)
AddHostsIntoZoneReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'hosts', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 1
  (2, TType.STRING, 'zone_name', False, None, 2, ), # 2
  (3, TType.BOOL, 'is_new', None, None, 2, ), # 3
)

AddHostsIntoZoneReq.thrift_struct_annotations = {
}
AddHostsIntoZoneReq.thrift_field_annotations = {
}

def AddHostsIntoZoneReq__init__(self, hosts=None, zone_name=None, is_new=None,):
  self.hosts = hosts
  self.zone_name = zone_name
  self.is_new = is_new

AddHostsIntoZoneReq.__init__ = AddHostsIntoZoneReq__init__

def AddHostsIntoZoneReq__setstate__(self, state):
  state.setdefault('hosts', None)
  state.setdefault('zone_name', None)
  state.setdefault('is_new', None)
  self.__dict__ = state

AddHostsIntoZoneReq.__getstate__ = lambda self: self.__dict__.copy()
AddHostsIntoZoneReq.__setstate__ = AddHostsIntoZoneReq__setstate__

all_structs.append(GetZoneReq)
GetZoneReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
)

GetZoneReq.thrift_struct_annotations = {
}
GetZoneReq.thrift_field_annotations = {
}

def GetZoneReq__init__(self, zone_name=None,):
  self.zone_name = zone_name

GetZoneReq.__init__ = GetZoneReq__init__

def GetZoneReq__setstate__(self, state):
  state.setdefault('zone_name', None)
  self.__dict__ = state

GetZoneReq.__getstate__ = lambda self: self.__dict__.copy()
GetZoneReq.__setstate__ = GetZoneReq__setstate__

all_structs.append(GetZoneResp)
GetZoneResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'hosts', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

GetZoneResp.thrift_struct_annotations = {
}
GetZoneResp.thrift_field_annotations = {
}

def GetZoneResp__init__(self, code=None, leader=None, hosts=None,):
  self.code = code
  self.leader = leader
  self.hosts = hosts

GetZoneResp.__init__ = GetZoneResp__init__

def GetZoneResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

GetZoneResp.__getstate__ = lambda self: self.__dict__.copy()
GetZoneResp.__setstate__ = GetZoneResp__setstate__

all_structs.append(ListZonesReq)
ListZonesReq.thrift_spec = (
)

ListZonesReq.thrift_struct_annotations = {
}
ListZonesReq.thrift_field_annotations = {
}

all_structs.append(Zone)
Zone.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'zone_name', False, None, 2, ), # 1
  (2, TType.LIST, 'nodes', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 2
)

Zone.thrift_struct_annotations = {
}
Zone.thrift_field_annotations = {
}

def Zone__init__(self, zone_name=None, nodes=None,):
  self.zone_name = zone_name
  self.nodes = nodes

Zone.__init__ = Zone__init__

def Zone__setstate__(self, state):
  state.setdefault('zone_name', None)
  state.setdefault('nodes', None)
  self.__dict__ = state

Zone.__getstate__ = lambda self: self.__dict__.copy()
Zone.__setstate__ = Zone__setstate__

all_structs.append(ListZonesResp)
ListZonesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'zones', (TType.STRUCT,[Zone, Zone.thrift_spec, False]), None, 2, ), # 3
)

ListZonesResp.thrift_struct_annotations = {
}
ListZonesResp.thrift_field_annotations = {
}

def ListZonesResp__init__(self, code=None, leader=None, zones=None,):
  self.code = code
  self.leader = leader
  self.zones = zones

ListZonesResp.__init__ = ListZonesResp__init__

def ListZonesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('zones', None)
  self.__dict__ = state

ListZonesResp.__getstate__ = lambda self: self.__dict__.copy()
ListZonesResp.__setstate__ = ListZonesResp__setstate__

all_structs.append(AddListenerReq)
AddListenerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'type', ListenerType, None, 2, ), # 2
  (3, TType.LIST, 'hosts', (TType.STRUCT,[nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False]), None, 2, ), # 3
)

AddListenerReq.thrift_struct_annotations = {
}
AddListenerReq.thrift_field_annotations = {
}

def AddListenerReq__init__(self, space_id=None, type=None, hosts=None,):
  self.space_id = space_id
  self.type = type
  self.hosts = hosts

AddListenerReq.__init__ = AddListenerReq__init__

def AddListenerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('type', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

AddListenerReq.__getstate__ = lambda self: self.__dict__.copy()
AddListenerReq.__setstate__ = AddListenerReq__setstate__

all_structs.append(RemoveListenerReq)
RemoveListenerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.I32, 'type', ListenerType, None, 2, ), # 2
)

RemoveListenerReq.thrift_struct_annotations = {
}
RemoveListenerReq.thrift_field_annotations = {
}

def RemoveListenerReq__init__(self, space_id=None, type=None,):
  self.space_id = space_id
  self.type = type

RemoveListenerReq.__init__ = RemoveListenerReq__init__

def RemoveListenerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('type', None)
  self.__dict__ = state

RemoveListenerReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveListenerReq.__setstate__ = RemoveListenerReq__setstate__

all_structs.append(ListListenerReq)
ListListenerReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

ListListenerReq.thrift_struct_annotations = {
}
ListListenerReq.thrift_field_annotations = {
}

def ListListenerReq__init__(self, space_id=None,):
  self.space_id = space_id

ListListenerReq.__init__ = ListListenerReq__init__

def ListListenerReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

ListListenerReq.__getstate__ = lambda self: self.__dict__.copy()
ListListenerReq.__setstate__ = ListListenerReq__setstate__

all_structs.append(ListenerInfo)
ListenerInfo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ListenerType, None, 2, ), # 1
  (2, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.I32, 'part_id', None, None, 2, ), # 3
  (4, TType.I32, 'status', HostStatus, None, 2, ), # 4
)

ListenerInfo.thrift_struct_annotations = {
}
ListenerInfo.thrift_field_annotations = {
}

def ListenerInfo__init__(self, type=None, host=None, part_id=None, status=None,):
  self.type = type
  self.host = host
  self.part_id = part_id
  self.status = status

ListenerInfo.__init__ = ListenerInfo__init__

def ListenerInfo__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('host', None)
  state.setdefault('part_id', None)
  state.setdefault('status', None)
  self.__dict__ = state

ListenerInfo.__getstate__ = lambda self: self.__dict__.copy()
ListenerInfo.__setstate__ = ListenerInfo__setstate__

all_structs.append(ListListenerResp)
ListListenerResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'listeners', (TType.STRUCT,[ListenerInfo, ListenerInfo.thrift_spec, False]), None, 2, ), # 3
)

ListListenerResp.thrift_struct_annotations = {
}
ListListenerResp.thrift_field_annotations = {
}

def ListListenerResp__init__(self, code=None, leader=None, listeners=None,):
  self.code = code
  self.leader = leader
  self.listeners = listeners

ListListenerResp.__init__ = ListListenerResp__init__

def ListListenerResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('listeners', None)
  self.__dict__ = state

ListListenerResp.__getstate__ = lambda self: self.__dict__.copy()
ListListenerResp.__setstate__ = ListListenerResp__setstate__

all_structs.append(GetStatsReq)
GetStatsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
)

GetStatsReq.thrift_struct_annotations = {
}
GetStatsReq.thrift_field_annotations = {
}

def GetStatsReq__init__(self, space_id=None,):
  self.space_id = space_id

GetStatsReq.__init__ = GetStatsReq__init__

def GetStatsReq__setstate__(self, state):
  state.setdefault('space_id', None)
  self.__dict__ = state

GetStatsReq.__getstate__ = lambda self: self.__dict__.copy()
GetStatsReq.__setstate__ = GetStatsReq__setstate__

all_structs.append(GetStatsResp)
GetStatsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'stats', [StatsItem, StatsItem.thrift_spec, False], None, 2, ), # 3
)

GetStatsResp.thrift_struct_annotations = {
}
GetStatsResp.thrift_field_annotations = {
}

def GetStatsResp__init__(self, code=None, leader=None, stats=None,):
  self.code = code
  self.leader = leader
  self.stats = stats

GetStatsResp.__init__ = GetStatsResp__init__

def GetStatsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('stats', None)
  self.__dict__ = state

GetStatsResp.__getstate__ = lambda self: self.__dict__.copy()
GetStatsResp.__setstate__ = GetStatsResp__setstate__

all_structs.append(HostBackupInfo)
HostBackupInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'checkpoints', (TType.STRUCT,[nebula3.common.ttypes.CheckpointInfo, nebula3.common.ttypes.CheckpointInfo.thrift_spec, False]), None, 2, ), # 2
)

HostBackupInfo.thrift_struct_annotations = {
}
HostBackupInfo.thrift_field_annotations = {
}

def HostBackupInfo__init__(self, host=None, checkpoints=None,):
  self.host = host
  self.checkpoints = checkpoints

HostBackupInfo.__init__ = HostBackupInfo__init__

def HostBackupInfo__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('checkpoints', None)
  self.__dict__ = state

HostBackupInfo.__getstate__ = lambda self: self.__dict__.copy()
HostBackupInfo.__setstate__ = HostBackupInfo__setstate__

all_structs.append(SpaceBackupInfo)
SpaceBackupInfo.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'space', [SpaceDesc, SpaceDesc.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'host_backups', (TType.STRUCT,[HostBackupInfo, HostBackupInfo.thrift_spec, False]), None, 2, ), # 2
)

SpaceBackupInfo.thrift_struct_annotations = {
}
SpaceBackupInfo.thrift_field_annotations = {
}

def SpaceBackupInfo__init__(self, space=None, host_backups=None,):
  self.space = space
  self.host_backups = host_backups

SpaceBackupInfo.__init__ = SpaceBackupInfo__init__

def SpaceBackupInfo__setstate__(self, state):
  state.setdefault('space', None)
  state.setdefault('host_backups', None)
  self.__dict__ = state

SpaceBackupInfo.__getstate__ = lambda self: self.__dict__.copy()
SpaceBackupInfo.__setstate__ = SpaceBackupInfo__setstate__

all_structs.append(BackupMeta)
BackupMeta.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'space_backups', (TType.I32,None,TType.STRUCT,[SpaceBackupInfo, SpaceBackupInfo.thrift_spec, False]), None, 2, ), # 1
  (2, TType.LIST, 'meta_files', (TType.STRING,False), None, 2, ), # 2
  (3, TType.STRING, 'backup_name', False, None, 2, ), # 3
  (4, TType.BOOL, 'full', None, None, 2, ), # 4
  (5, TType.BOOL, 'all_spaces', None, None, 2, ), # 5
  (6, TType.I64, 'create_time', None, None, 2, ), # 6
)

BackupMeta.thrift_struct_annotations = {
}
BackupMeta.thrift_field_annotations = {
}

def BackupMeta__init__(self, space_backups=None, meta_files=None, backup_name=None, full=None, all_spaces=None, create_time=None,):
  self.space_backups = space_backups
  self.meta_files = meta_files
  self.backup_name = backup_name
  self.full = full
  self.all_spaces = all_spaces
  self.create_time = create_time

BackupMeta.__init__ = BackupMeta__init__

def BackupMeta__setstate__(self, state):
  state.setdefault('space_backups', None)
  state.setdefault('meta_files', None)
  state.setdefault('backup_name', None)
  state.setdefault('full', None)
  state.setdefault('all_spaces', None)
  state.setdefault('create_time', None)
  self.__dict__ = state

BackupMeta.__getstate__ = lambda self: self.__dict__.copy()
BackupMeta.__setstate__ = BackupMeta__setstate__

all_structs.append(CreateBackupReq)
CreateBackupReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'spaces', (TType.STRING,False), None, 1, ), # 1
)

CreateBackupReq.thrift_struct_annotations = {
}
CreateBackupReq.thrift_field_annotations = {
}

def CreateBackupReq__init__(self, spaces=None,):
  self.spaces = spaces

CreateBackupReq.__init__ = CreateBackupReq__init__

def CreateBackupReq__setstate__(self, state):
  state.setdefault('spaces', None)
  self.__dict__ = state

CreateBackupReq.__getstate__ = lambda self: self.__dict__.copy()
CreateBackupReq.__setstate__ = CreateBackupReq__setstate__

all_structs.append(CreateBackupResp)
CreateBackupResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'meta', [BackupMeta, BackupMeta.thrift_spec, False], None, 2, ), # 3
)

CreateBackupResp.thrift_struct_annotations = {
}
CreateBackupResp.thrift_field_annotations = {
}

def CreateBackupResp__init__(self, code=None, leader=None, meta=None,):
  self.code = code
  self.leader = leader
  self.meta = meta

CreateBackupResp.__init__ = CreateBackupResp__init__

def CreateBackupResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('meta', None)
  self.__dict__ = state

CreateBackupResp.__getstate__ = lambda self: self.__dict__.copy()
CreateBackupResp.__setstate__ = CreateBackupResp__setstate__

all_structs.append(HostPair)
HostPair.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'from_host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'to_host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
)

HostPair.thrift_struct_annotations = {
}
HostPair.thrift_field_annotations = {
}

def HostPair__init__(self, from_host=None, to_host=None,):
  self.from_host = from_host
  self.to_host = to_host

HostPair.__init__ = HostPair__init__

def HostPair__setstate__(self, state):
  state.setdefault('from_host', None)
  state.setdefault('to_host', None)
  self.__dict__ = state

HostPair.__getstate__ = lambda self: self.__dict__.copy()
HostPair.__setstate__ = HostPair__setstate__

all_structs.append(RestoreMetaReq)
RestoreMetaReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'files', (TType.STRING,False), None, 2, ), # 1
  (2, TType.LIST, 'hosts', (TType.STRUCT,[HostPair, HostPair.thrift_spec, False]), None, 2, ), # 2
)

RestoreMetaReq.thrift_struct_annotations = {
}
RestoreMetaReq.thrift_field_annotations = {
}

def RestoreMetaReq__init__(self, files=None, hosts=None,):
  self.files = files
  self.hosts = hosts

RestoreMetaReq.__init__ = RestoreMetaReq__init__

def RestoreMetaReq__setstate__(self, state):
  state.setdefault('files', None)
  state.setdefault('hosts', None)
  self.__dict__ = state

RestoreMetaReq.__getstate__ = lambda self: self.__dict__.copy()
RestoreMetaReq.__setstate__ = RestoreMetaReq__setstate__

all_structs.append(ServiceClient)
ServiceClient.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'user', False, None, 1, ), # 2
  (3, TType.STRING, 'pwd', False, None, 1, ), # 3
  (4, TType.STRING, 'conn_type', False, None, 1, ), # 4
)

ServiceClient.thrift_struct_annotations = {
}
ServiceClient.thrift_field_annotations = {
}

def ServiceClient__init__(self, host=None, user=None, pwd=None, conn_type=None,):
  self.host = host
  self.user = user
  self.pwd = pwd
  self.conn_type = conn_type

ServiceClient.__init__ = ServiceClient__init__

def ServiceClient__setstate__(self, state):
  state.setdefault('host', None)
  state.setdefault('user', None)
  state.setdefault('pwd', None)
  state.setdefault('conn_type', None)
  self.__dict__ = state

ServiceClient.__getstate__ = lambda self: self.__dict__.copy()
ServiceClient.__setstate__ = ServiceClient__setstate__

all_structs.append(SignInServiceReq)
SignInServiceReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ExternalServiceType, None, 2, ), # 1
  (2, TType.LIST, 'clients', (TType.STRUCT,[ServiceClient, ServiceClient.thrift_spec, False]), None, 2, ), # 2
)

SignInServiceReq.thrift_struct_annotations = {
}
SignInServiceReq.thrift_field_annotations = {
}

def SignInServiceReq__init__(self, type=None, clients=None,):
  self.type = type
  self.clients = clients

SignInServiceReq.__init__ = SignInServiceReq__init__

def SignInServiceReq__setstate__(self, state):
  state.setdefault('type', None)
  state.setdefault('clients', None)
  self.__dict__ = state

SignInServiceReq.__getstate__ = lambda self: self.__dict__.copy()
SignInServiceReq.__setstate__ = SignInServiceReq__setstate__

all_structs.append(SignOutServiceReq)
SignOutServiceReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ExternalServiceType, None, 2, ), # 1
)

SignOutServiceReq.thrift_struct_annotations = {
}
SignOutServiceReq.thrift_field_annotations = {
}

def SignOutServiceReq__init__(self, type=None,):
  self.type = type

SignOutServiceReq.__init__ = SignOutServiceReq__init__

def SignOutServiceReq__setstate__(self, state):
  state.setdefault('type', None)
  self.__dict__ = state

SignOutServiceReq.__getstate__ = lambda self: self.__dict__.copy()
SignOutServiceReq.__setstate__ = SignOutServiceReq__setstate__

all_structs.append(ListServiceClientsReq)
ListServiceClientsReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'type', ExternalServiceType, None, 2, ), # 1
)

ListServiceClientsReq.thrift_struct_annotations = {
}
ListServiceClientsReq.thrift_field_annotations = {
}

def ListServiceClientsReq__init__(self, type=None,):
  self.type = type

ListServiceClientsReq.__init__ = ListServiceClientsReq__init__

def ListServiceClientsReq__setstate__(self, state):
  state.setdefault('type', None)
  self.__dict__ = state

ListServiceClientsReq.__getstate__ = lambda self: self.__dict__.copy()
ListServiceClientsReq.__setstate__ = ListServiceClientsReq__setstate__

all_structs.append(ListServiceClientsResp)
ListServiceClientsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'clients', (TType.I32,ExternalServiceType,TType.LIST,(TType.STRUCT,[ServiceClient, ServiceClient.thrift_spec, False])), None, 2, ), # 3
)

ListServiceClientsResp.thrift_struct_annotations = {
}
ListServiceClientsResp.thrift_field_annotations = {
}

def ListServiceClientsResp__init__(self, code=None, leader=None, clients=None,):
  self.code = code
  self.leader = leader
  self.clients = clients

ListServiceClientsResp.__init__ = ListServiceClientsResp__init__

def ListServiceClientsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('clients', None)
  self.__dict__ = state

ListServiceClientsResp.__getstate__ = lambda self: self.__dict__.copy()
ListServiceClientsResp.__setstate__ = ListServiceClientsResp__setstate__

all_structs.append(FTIndex)
FTIndex.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRUCT, 'depend_schema', [nebula3.common.ttypes.SchemaID, nebula3.common.ttypes.SchemaID.thrift_spec, True], None, 2, ), # 2
  (3, TType.LIST, 'fields', (TType.STRING,False), None, 2, ), # 3
)

FTIndex.thrift_struct_annotations = {
}
FTIndex.thrift_field_annotations = {
}

def FTIndex__init__(self, space_id=None, depend_schema=None, fields=None,):
  self.space_id = space_id
  self.depend_schema = depend_schema
  self.fields = fields

FTIndex.__init__ = FTIndex__init__

def FTIndex__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('depend_schema', None)
  state.setdefault('fields', None)
  self.__dict__ = state

FTIndex.__getstate__ = lambda self: self.__dict__.copy()
FTIndex.__setstate__ = FTIndex__setstate__

all_structs.append(CreateFTIndexReq)
CreateFTIndexReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'fulltext_index_name', False, None, 2, ), # 1
  (2, TType.STRUCT, 'index', [FTIndex, FTIndex.thrift_spec, False], None, 2, ), # 2
)

CreateFTIndexReq.thrift_struct_annotations = {
}
CreateFTIndexReq.thrift_field_annotations = {
}

def CreateFTIndexReq__init__(self, fulltext_index_name=None, index=None,):
  self.fulltext_index_name = fulltext_index_name
  self.index = index

CreateFTIndexReq.__init__ = CreateFTIndexReq__init__

def CreateFTIndexReq__setstate__(self, state):
  state.setdefault('fulltext_index_name', None)
  state.setdefault('index', None)
  self.__dict__ = state

CreateFTIndexReq.__getstate__ = lambda self: self.__dict__.copy()
CreateFTIndexReq.__setstate__ = CreateFTIndexReq__setstate__

all_structs.append(DropFTIndexReq)
DropFTIndexReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'space_id', None, None, 2, ), # 1
  (2, TType.STRING, 'fulltext_index_name', False, None, 2, ), # 2
)

DropFTIndexReq.thrift_struct_annotations = {
}
DropFTIndexReq.thrift_field_annotations = {
}

def DropFTIndexReq__init__(self, space_id=None, fulltext_index_name=None,):
  self.space_id = space_id
  self.fulltext_index_name = fulltext_index_name

DropFTIndexReq.__init__ = DropFTIndexReq__init__

def DropFTIndexReq__setstate__(self, state):
  state.setdefault('space_id', None)
  state.setdefault('fulltext_index_name', None)
  self.__dict__ = state

DropFTIndexReq.__getstate__ = lambda self: self.__dict__.copy()
DropFTIndexReq.__setstate__ = DropFTIndexReq__setstate__

all_structs.append(ListFTIndexesReq)
ListFTIndexesReq.thrift_spec = (
)

ListFTIndexesReq.thrift_struct_annotations = {
}
ListFTIndexesReq.thrift_field_annotations = {
}

all_structs.append(ListFTIndexesResp)
ListFTIndexesResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'indexes', (TType.STRING,False,TType.STRUCT,[FTIndex, FTIndex.thrift_spec, False]), None, 2, ), # 3
)

ListFTIndexesResp.thrift_struct_annotations = {
}
ListFTIndexesResp.thrift_field_annotations = {
}

def ListFTIndexesResp__init__(self, code=None, leader=None, indexes=None,):
  self.code = code
  self.leader = leader
  self.indexes = indexes

ListFTIndexesResp.__init__ = ListFTIndexesResp__init__

def ListFTIndexesResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('indexes', None)
  self.__dict__ = state

ListFTIndexesResp.__getstate__ = lambda self: self.__dict__.copy()
ListFTIndexesResp.__setstate__ = ListFTIndexesResp__setstate__

all_structs.append(QueryDesc)
QueryDesc.thrift_spec = (
  None, # 0
  (1, TType.I64, 'start_time', None, None, 2, ), # 1
  (2, TType.I32, 'status', QueryStatus, None, 2, ), # 2
  (3, TType.I64, 'duration', None, None, 2, ), # 3
  (4, TType.STRING, 'query', False, None, 2, ), # 4
  (5, TType.STRUCT, 'graph_addr', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 5
)

QueryDesc.thrift_struct_annotations = {
}
QueryDesc.thrift_field_annotations = {
}

def QueryDesc__init__(self, start_time=None, status=None, duration=None, query=None, graph_addr=None,):
  self.start_time = start_time
  self.status = status
  self.duration = duration
  self.query = query
  self.graph_addr = graph_addr

QueryDesc.__init__ = QueryDesc__init__

def QueryDesc__setstate__(self, state):
  state.setdefault('start_time', None)
  state.setdefault('status', None)
  state.setdefault('duration', None)
  state.setdefault('query', None)
  state.setdefault('graph_addr', None)
  self.__dict__ = state

QueryDesc.__getstate__ = lambda self: self.__dict__.copy()
QueryDesc.__setstate__ = QueryDesc__setstate__

all_structs.append(Session)
Session.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 2, ), # 1
  (2, TType.I64, 'create_time', None, None, 2, ), # 2
  (3, TType.I64, 'update_time', None, None, 2, ), # 3
  (4, TType.STRING, 'user_name', False, None, 2, ), # 4
  (5, TType.STRING, 'space_name', False, None, 2, ), # 5
  (6, TType.STRUCT, 'graph_addr', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 6
  (7, TType.I32, 'timezone', None, None, 2, ), # 7
  (8, TType.STRING, 'client_ip', False, None, 2, ), # 8
  (9, TType.MAP, 'configs', (TType.STRING,False,TType.STRUCT,[nebula3.common.ttypes.Value, nebula3.common.ttypes.Value.thrift_spec, True]), None, 2, ), # 9
  (10, TType.MAP, 'queries', (TType.I64,None,TType.STRUCT,[QueryDesc, QueryDesc.thrift_spec, False]), None, 2, ), # 10
)

Session.thrift_struct_annotations = {
}
Session.thrift_field_annotations = {
}

def Session__init__(self, session_id=None, create_time=None, update_time=None, user_name=None, space_name=None, graph_addr=None, timezone=None, client_ip=None, configs=None, queries=None,):
  self.session_id = session_id
  self.create_time = create_time
  self.update_time = update_time
  self.user_name = user_name
  self.space_name = space_name
  self.graph_addr = graph_addr
  self.timezone = timezone
  self.client_ip = client_ip
  self.configs = configs
  self.queries = queries

Session.__init__ = Session__init__

def Session__setstate__(self, state):
  state.setdefault('session_id', None)
  state.setdefault('create_time', None)
  state.setdefault('update_time', None)
  state.setdefault('user_name', None)
  state.setdefault('space_name', None)
  state.setdefault('graph_addr', None)
  state.setdefault('timezone', None)
  state.setdefault('client_ip', None)
  state.setdefault('configs', None)
  state.setdefault('queries', None)
  self.__dict__ = state

Session.__getstate__ = lambda self: self.__dict__.copy()
Session.__setstate__ = Session__setstate__

all_structs.append(CreateSessionReq)
CreateSessionReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'user', False, None, 2, ), # 1
  (2, TType.STRUCT, 'graph_addr', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'client_ip', False, None, 2, ), # 3
)

CreateSessionReq.thrift_struct_annotations = {
}
CreateSessionReq.thrift_field_annotations = {
}

def CreateSessionReq__init__(self, user=None, graph_addr=None, client_ip=None,):
  self.user = user
  self.graph_addr = graph_addr
  self.client_ip = client_ip

CreateSessionReq.__init__ = CreateSessionReq__init__

def CreateSessionReq__setstate__(self, state):
  state.setdefault('user', None)
  state.setdefault('graph_addr', None)
  state.setdefault('client_ip', None)
  self.__dict__ = state

CreateSessionReq.__getstate__ = lambda self: self.__dict__.copy()
CreateSessionReq.__setstate__ = CreateSessionReq__setstate__

all_structs.append(CreateSessionResp)
CreateSessionResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 3
)

CreateSessionResp.thrift_struct_annotations = {
}
CreateSessionResp.thrift_field_annotations = {
}

def CreateSessionResp__init__(self, code=None, leader=None, session=None,):
  self.code = code
  self.leader = leader
  self.session = session

CreateSessionResp.__init__ = CreateSessionResp__init__

def CreateSessionResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('session', None)
  self.__dict__ = state

CreateSessionResp.__getstate__ = lambda self: self.__dict__.copy()
CreateSessionResp.__setstate__ = CreateSessionResp__setstate__

all_structs.append(UpdateSessionsReq)
UpdateSessionsReq.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'sessions', (TType.STRUCT,[Session, Session.thrift_spec, False]), None, 2, ), # 1
)

UpdateSessionsReq.thrift_struct_annotations = {
}
UpdateSessionsReq.thrift_field_annotations = {
}

def UpdateSessionsReq__init__(self, sessions=None,):
  self.sessions = sessions

UpdateSessionsReq.__init__ = UpdateSessionsReq__init__

def UpdateSessionsReq__setstate__(self, state):
  state.setdefault('sessions', None)
  self.__dict__ = state

UpdateSessionsReq.__getstate__ = lambda self: self.__dict__.copy()
UpdateSessionsReq.__setstate__ = UpdateSessionsReq__setstate__

all_structs.append(UpdateSessionsResp)
UpdateSessionsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'killed_queries', (TType.I64,None,TType.MAP,(TType.I64,None,TType.STRUCT,[QueryDesc, QueryDesc.thrift_spec, False])), None, 2, ), # 3
)

UpdateSessionsResp.thrift_struct_annotations = {
}
UpdateSessionsResp.thrift_field_annotations = {
}

def UpdateSessionsResp__init__(self, code=None, leader=None, killed_queries=None,):
  self.code = code
  self.leader = leader
  self.killed_queries = killed_queries

UpdateSessionsResp.__init__ = UpdateSessionsResp__init__

def UpdateSessionsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('killed_queries', None)
  self.__dict__ = state

UpdateSessionsResp.__getstate__ = lambda self: self.__dict__.copy()
UpdateSessionsResp.__setstate__ = UpdateSessionsResp__setstate__

all_structs.append(ListSessionsReq)
ListSessionsReq.thrift_spec = (
)

ListSessionsReq.thrift_struct_annotations = {
}
ListSessionsReq.thrift_field_annotations = {
}

all_structs.append(ListSessionsResp)
ListSessionsResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.LIST, 'sessions', (TType.STRUCT,[Session, Session.thrift_spec, False]), None, 2, ), # 3
)

ListSessionsResp.thrift_struct_annotations = {
}
ListSessionsResp.thrift_field_annotations = {
}

def ListSessionsResp__init__(self, code=None, leader=None, sessions=None,):
  self.code = code
  self.leader = leader
  self.sessions = sessions

ListSessionsResp.__init__ = ListSessionsResp__init__

def ListSessionsResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('sessions', None)
  self.__dict__ = state

ListSessionsResp.__getstate__ = lambda self: self.__dict__.copy()
ListSessionsResp.__setstate__ = ListSessionsResp__setstate__

all_structs.append(GetSessionReq)
GetSessionReq.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 2, ), # 1
)

GetSessionReq.thrift_struct_annotations = {
}
GetSessionReq.thrift_field_annotations = {
}

def GetSessionReq__init__(self, session_id=None,):
  self.session_id = session_id

GetSessionReq.__init__ = GetSessionReq__init__

def GetSessionReq__setstate__(self, state):
  state.setdefault('session_id', None)
  self.__dict__ = state

GetSessionReq.__getstate__ = lambda self: self.__dict__.copy()
GetSessionReq.__setstate__ = GetSessionReq__setstate__

all_structs.append(GetSessionResp)
GetSessionResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'session', [Session, Session.thrift_spec, False], None, 2, ), # 3
)

GetSessionResp.thrift_struct_annotations = {
}
GetSessionResp.thrift_field_annotations = {
}

def GetSessionResp__init__(self, code=None, leader=None, session=None,):
  self.code = code
  self.leader = leader
  self.session = session

GetSessionResp.__init__ = GetSessionResp__init__

def GetSessionResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('session', None)
  self.__dict__ = state

GetSessionResp.__getstate__ = lambda self: self.__dict__.copy()
GetSessionResp.__setstate__ = GetSessionResp__setstate__

all_structs.append(RemoveSessionReq)
RemoveSessionReq.thrift_spec = (
  None, # 0
  (1, TType.I64, 'session_id', None, None, 2, ), # 1
)

RemoveSessionReq.thrift_struct_annotations = {
}
RemoveSessionReq.thrift_field_annotations = {
}

def RemoveSessionReq__init__(self, session_id=None,):
  self.session_id = session_id

RemoveSessionReq.__init__ = RemoveSessionReq__init__

def RemoveSessionReq__setstate__(self, state):
  state.setdefault('session_id', None)
  self.__dict__ = state

RemoveSessionReq.__getstate__ = lambda self: self.__dict__.copy()
RemoveSessionReq.__setstate__ = RemoveSessionReq__setstate__

all_structs.append(KillQueryReq)
KillQueryReq.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'kill_queries', (TType.I64,None,TType.SET,(TType.I64,None)), None, 2, ), # 1
)

KillQueryReq.thrift_struct_annotations = {
}
KillQueryReq.thrift_field_annotations = {
}

def KillQueryReq__init__(self, kill_queries=None,):
  self.kill_queries = kill_queries

KillQueryReq.__init__ = KillQueryReq__init__

def KillQueryReq__setstate__(self, state):
  state.setdefault('kill_queries', None)
  self.__dict__ = state

KillQueryReq.__getstate__ = lambda self: self.__dict__.copy()
KillQueryReq.__setstate__ = KillQueryReq__setstate__

all_structs.append(ReportTaskReq)
ReportTaskReq.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.I32, 'job_id', None, None, 2, ), # 2
  (3, TType.I32, 'task_id', None, None, 2, ), # 3
  (4, TType.STRUCT, 'stats', [StatsItem, StatsItem.thrift_spec, False], None, 1, ), # 4
)

ReportTaskReq.thrift_struct_annotations = {
}
ReportTaskReq.thrift_field_annotations = {
}

def ReportTaskReq__init__(self, code=None, job_id=None, task_id=None, stats=None,):
  self.code = code
  self.job_id = job_id
  self.task_id = task_id
  self.stats = stats

ReportTaskReq.__init__ = ReportTaskReq__init__

def ReportTaskReq__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('job_id', None)
  state.setdefault('task_id', None)
  state.setdefault('stats', None)
  self.__dict__ = state

ReportTaskReq.__getstate__ = lambda self: self.__dict__.copy()
ReportTaskReq.__setstate__ = ReportTaskReq__setstate__

all_structs.append(ListClusterInfoResp)
ListClusterInfoResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.MAP, 'host_services', (TType.STRING,True,TType.LIST,(TType.STRUCT,[ServiceInfo, ServiceInfo.thrift_spec, False])), None, 2, ), # 3
)

ListClusterInfoResp.thrift_struct_annotations = {
}
ListClusterInfoResp.thrift_field_annotations = {
}

def ListClusterInfoResp__init__(self, code=None, leader=None, host_services=None,):
  self.code = code
  self.leader = leader
  self.host_services = host_services

ListClusterInfoResp.__init__ = ListClusterInfoResp__init__

def ListClusterInfoResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('host_services', None)
  self.__dict__ = state

ListClusterInfoResp.__getstate__ = lambda self: self.__dict__.copy()
ListClusterInfoResp.__setstate__ = ListClusterInfoResp__setstate__

all_structs.append(ListClusterInfoReq)
ListClusterInfoReq.thrift_spec = (
)

ListClusterInfoReq.thrift_struct_annotations = {
}
ListClusterInfoReq.thrift_field_annotations = {
}

all_structs.append(GetMetaDirInfoResp)
GetMetaDirInfoResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'dir', [nebula3.common.ttypes.DirInfo, nebula3.common.ttypes.DirInfo.thrift_spec, False], None, 2, ), # 2
)

GetMetaDirInfoResp.thrift_struct_annotations = {
}
GetMetaDirInfoResp.thrift_field_annotations = {
}

def GetMetaDirInfoResp__init__(self, code=None, dir=None,):
  self.code = code
  self.dir = dir

GetMetaDirInfoResp.__init__ = GetMetaDirInfoResp__init__

def GetMetaDirInfoResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('dir', None)
  self.__dict__ = state

GetMetaDirInfoResp.__getstate__ = lambda self: self.__dict__.copy()
GetMetaDirInfoResp.__setstate__ = GetMetaDirInfoResp__setstate__

all_structs.append(GetMetaDirInfoReq)
GetMetaDirInfoReq.thrift_spec = (
)

GetMetaDirInfoReq.thrift_struct_annotations = {
}
GetMetaDirInfoReq.thrift_field_annotations = {
}

all_structs.append(VerifyClientVersionResp)
VerifyClientVersionResp.thrift_spec = (
  None, # 0
  (1, TType.I32, 'code', nebula3.common.ttypes.ErrorCode, None, 2, ), # 1
  (2, TType.STRUCT, 'leader', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'error_msg', False, None, 1, ), # 3
)

VerifyClientVersionResp.thrift_struct_annotations = {
}
VerifyClientVersionResp.thrift_field_annotations = {
}

def VerifyClientVersionResp__init__(self, code=None, leader=None, error_msg=None,):
  self.code = code
  self.leader = leader
  self.error_msg = error_msg

VerifyClientVersionResp.__init__ = VerifyClientVersionResp__init__

def VerifyClientVersionResp__setstate__(self, state):
  state.setdefault('code', None)
  state.setdefault('leader', None)
  state.setdefault('error_msg', None)
  self.__dict__ = state

VerifyClientVersionResp.__getstate__ = lambda self: self.__dict__.copy()
VerifyClientVersionResp.__setstate__ = VerifyClientVersionResp__setstate__

all_structs.append(VerifyClientVersionReq)
VerifyClientVersionReq.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'client_version', False, "3.0.0", 0, ), # 1
  (2, TType.STRUCT, 'host', [nebula3.common.ttypes.HostAddr, nebula3.common.ttypes.HostAddr.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'build_version', False, None, 2, ), # 3
)

VerifyClientVersionReq.thrift_struct_annotations = {
}
VerifyClientVersionReq.thrift_field_annotations = {
}

def VerifyClientVersionReq__init__(self, client_version=VerifyClientVersionReq.thrift_spec[1][4], host=None, build_version=None,):
  self.client_version = client_version
  self.host = host
  self.build_version = build_version

VerifyClientVersionReq.__init__ = VerifyClientVersionReq__init__

def VerifyClientVersionReq__setstate__(self, state):
  state.setdefault('client_version', "3.0.0")
  state.setdefault('host', None)
  state.setdefault('build_version', None)
  self.__dict__ = state

VerifyClientVersionReq.__getstate__ = lambda self: self.__dict__.copy()
VerifyClientVersionReq.__setstate__ = VerifyClientVersionReq__setstate__

fix_spec(all_structs)
del all_structs
