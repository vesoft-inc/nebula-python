#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


from .ttypes import *
import common.ttypes

from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
if not '__pypy__' in sys.builtin_module_names:
  try:
    from thrift.protocol import fastproto
  except:
    pass

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

import thrift
if six.PY3 and not thrift.trollius:
  import asyncio
  from thrift.util.asyncio import call_as_future
else:
  import trollius as asyncio
  from thrift.util.trollius import call_as_future
from thrift.util.Decorators import *

class Iface:
  def authenticate(self, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    pass

  def signout(self, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    pass

  def execute(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass


class ContextIface:
  def authenticate(self, handler_ctx, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    pass

  def signout(self, handler_ctx, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    pass

  def execute(self, handler_ctx, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class authenticate_args:
  """
  Attributes:
   - username
   - password
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.username = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.password = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('authenticate_args')
    if self.username != None:
      oprot.writeFieldBegin('username', TType.STRING, 1)
      oprot.writeString(self.username.encode('utf-8')) if UTF8STRINGS and not isinstance(self.username, bytes) else oprot.writeString(self.username)
      oprot.writeFieldEnd()
    if self.password != None:
      oprot.writeFieldBegin('password', TType.STRING, 2)
      oprot.writeString(self.password.encode('utf-8')) if UTF8STRINGS and not isinstance(self.password, bytes) else oprot.writeString(self.password)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.username is not None:
      value = pprint.pformat(self.username, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    username=%s' % (value))
    if self.password is not None:
      value = pprint.pformat(self.password, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    password=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(authenticate_args)
authenticate_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'username', True, None, 2, ), # 1
  (2, TType.STRING, 'password', True, None, 2, ), # 2
)

authenticate_args.thrift_struct_annotations = {
}
authenticate_args.thrift_field_annotations = {
}

def authenticate_args__init__(self, username=None, password=None,):
  self.username = username
  self.password = password

authenticate_args.__init__ = authenticate_args__init__

def authenticate_args__setstate__(self, state):
  state.setdefault('username', None)
  state.setdefault('password', None)
  self.__dict__ = state

authenticate_args.__getstate__ = lambda self: self.__dict__.copy()
authenticate_args.__setstate__ = authenticate_args__setstate__

class authenticate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = AuthResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('authenticate_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(authenticate_result)
authenticate_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [AuthResponse, AuthResponse.thrift_spec, False], None, 2, ), # 0
)

authenticate_result.thrift_struct_annotations = {
}
authenticate_result.thrift_field_annotations = {
}

def authenticate_result__init__(self, success=None,):
  self.success = success

authenticate_result.__init__ = authenticate_result__init__

def authenticate_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

authenticate_result.__getstate__ = lambda self: self.__dict__.copy()
authenticate_result.__setstate__ = authenticate_result__setstate__

class signout_args:
  """
  Attributes:
   - sessionId
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('signout_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(signout_args)
signout_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
)

signout_args.thrift_struct_annotations = {
}
signout_args.thrift_field_annotations = {
}

def signout_args__init__(self, sessionId=None,):
  self.sessionId = sessionId

signout_args.__init__ = signout_args__init__

def signout_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  self.__dict__ = state

signout_args.__getstate__ = lambda self: self.__dict__.copy()
signout_args.__setstate__ = signout_args__setstate__

class execute_args:
  """
  Attributes:
   - sessionId
   - stmt
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.sessionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stmt = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('execute_args')
    if self.sessionId != None:
      oprot.writeFieldBegin('sessionId', TType.I64, 1)
      oprot.writeI64(self.sessionId)
      oprot.writeFieldEnd()
    if self.stmt != None:
      oprot.writeFieldBegin('stmt', TType.STRING, 2)
      oprot.writeString(self.stmt.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stmt, bytes) else oprot.writeString(self.stmt)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.sessionId is not None:
      value = pprint.pformat(self.sessionId, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    sessionId=%s' % (value))
    if self.stmt is not None:
      value = pprint.pformat(self.stmt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stmt=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(execute_args)
execute_args.thrift_spec = (
  None, # 0
  (1, TType.I64, 'sessionId', None, None, 2, ), # 1
  (2, TType.STRING, 'stmt', True, None, 2, ), # 2
)

execute_args.thrift_struct_annotations = {
}
execute_args.thrift_field_annotations = {
}

def execute_args__init__(self, sessionId=None, stmt=None,):
  self.sessionId = sessionId
  self.stmt = stmt

execute_args.__init__ = execute_args__init__

def execute_args__setstate__(self, state):
  state.setdefault('sessionId', None)
  state.setdefault('stmt', None)
  self.__dict__ = state

execute_args.__getstate__ = lambda self: self.__dict__.copy()
execute_args.__setstate__ = execute_args__setstate__

class execute_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ExecutionResponse()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('execute_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.success is not None:
      value = pprint.pformat(self.success, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    success=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(execute_result)
execute_result.thrift_spec = (
  (0, TType.STRUCT, 'success', [ExecutionResponse, ExecutionResponse.thrift_spec, False], None, 2, ), # 0
)

execute_result.thrift_struct_annotations = {
}
execute_result.thrift_field_annotations = {
}

def execute_result__init__(self, success=None,):
  self.success = success

execute_result.__init__ = execute_result__init__

def execute_result__setstate__(self, state):
  state.setdefault('success', None)
  self.__dict__ = state

execute_result.__getstate__ = lambda self: self.__dict__.copy()
execute_result.__setstate__ = execute_result__setstate__

class Client(Iface):
  def __init__(self, oprot, loop=None):
    self._oprot = oprot
    self._loop = loop or asyncio.get_event_loop()
    self._seqid = 0
    self._futures = {}

  def authenticate(self, username=None, password=None):
    """
    Parameters:
     - username
     - password
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_authenticate(username, password)
    return fut

  def send_authenticate(self, username=None, password=None):
    self._oprot.writeMessageBegin('authenticate', TMessageType.CALL, self._seqid)
    args = authenticate_args()
    args.username = username
    args.password = password
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_authenticate(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = authenticate_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "authenticate failed: unknown result"))
    return

  def signout(self, sessionId=None):
    """
    Parameters:
     - sessionId
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_signout(sessionId)
    fut.set_result(None)
    return fut

  def send_signout(self, sessionId=None):
    self._oprot.writeMessageBegin('signout', TMessageType.CALL, self._seqid)
    args = signout_args()
    args.sessionId = sessionId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.onewayFlush()
  def execute(self, sessionId=None, stmt=None):
    """
    Parameters:
     - sessionId
     - stmt
    """
    self._seqid += 1
    fut = self._futures[self._seqid] = asyncio.Future(loop=self._loop)
    self.send_execute(sessionId, stmt)
    return fut

  def send_execute(self, sessionId=None, stmt=None):
    self._oprot.writeMessageBegin('execute', TMessageType.CALL, self._seqid)
    args = execute_args()
    args.sessionId = sessionId
    args.stmt = stmt
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_execute(self, iprot, mtype, rseqid):
    try:
        fut = self._futures.pop(rseqid)
    except KeyError:
        return   # request timed out
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      fut.set_exception(x)
      return
    result = execute_result()
    try:
      result.read(iprot)
    except Exception as e:
      fut.set_exception(e)
      return
    iprot.readMessageEnd()
    if result.success != None:
      fut.set_result(result.success)
      return
    fut.set_exception(TApplicationException(TApplicationException.MISSING_RESULT, "execute failed: unknown result"))
    return


class Processor(Iface, TProcessor):
  _onewayMethods = ("signout",)

  def __init__(self, handler, loop=None):
    TProcessor.__init__(self)
    self._handler = handler
    self._loop = loop or asyncio.get_event_loop()
    self._processMap = {}
    self._priorityMap = {}
    self._processMap["authenticate"] = Processor.process_authenticate
    self._priorityMap["authenticate"] = TPriority.NORMAL
    self._processMap["signout"] = Processor.process_signout
    self._priorityMap["signout"] = TPriority.NORMAL
    self._processMap["execute"] = Processor.process_execute
    self._priorityMap["execute"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main(asyncio=True)
  def process(self,): pass

  @process_method(authenticate_args, oneway=False, asyncio=True)
  def process_authenticate(self, args, handler_ctx, seqid, oprot, fn_name):
    result = authenticate_result()
    if should_run_on_thread(self._handler.authenticate):
      fut = self._loop.run_in_executor(None, self._handler.authenticate, args.username, args.password)
    else:
      fut = call_as_future(self._handler.authenticate, self._loop, args.username, args.password)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(signout_args, oneway=True, asyncio=True)
  def process_signout(self, args, handler_ctx, seqid, oprot, fn_name):
    if should_run_on_thread(self._handler.signout):
      fut = self._loop.run_in_executor(None, self._handler.signout, args.sessionId)
    else:
      fut = call_as_future(self._handler.signout, self._loop, args.sessionId)
    return fut

  @process_method(execute_args, oneway=False, asyncio=True)
  def process_execute(self, args, handler_ctx, seqid, oprot, fn_name):
    result = execute_result()
    if should_run_on_thread(self._handler.execute):
      fut = self._loop.run_in_executor(None, self._handler.execute, args.sessionId, args.stmt)
    else:
      fut = call_as_future(self._handler.execute, self._loop, args.sessionId, args.stmt)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  _onewayMethods = ("signout",)

  def __init__(self, handler, loop=None):
    TProcessor.__init__(self)
    self._handler = handler
    self._loop = loop or asyncio.get_event_loop()
    self._processMap = {}
    self._priorityMap = {}
    self._processMap["authenticate"] = ContextProcessor.process_authenticate
    self._priorityMap["authenticate"] = TPriority.NORMAL
    self._processMap["signout"] = ContextProcessor.process_signout
    self._priorityMap["signout"] = TPriority.NORMAL
    self._processMap["execute"] = ContextProcessor.process_execute
    self._priorityMap["execute"] = TPriority.NORMAL

  def onewayMethods(self):
    l = []
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main(asyncio=True)
  def process(self,): pass

  @process_method(authenticate_args, oneway=False, asyncio=True)
  def process_authenticate(self, args, handler_ctx, seqid, oprot, fn_name):
    result = authenticate_result()
    if should_run_on_thread(self._handler.authenticate):
      fut = self._loop.run_in_executor(None, self._handler.authenticate, handler_ctx, args.username, args.password)
    else:
      fut = call_as_future(self._handler.authenticate, self._loop, handler_ctx, args.username, args.password)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

  @process_method(signout_args, oneway=True, asyncio=True)
  def process_signout(self, args, handler_ctx, seqid, oprot, fn_name):
    if should_run_on_thread(self._handler.signout):
      fut = self._loop.run_in_executor(None, self._handler.signout, handler_ctx, args.sessionId)
    else:
      fut = call_as_future(self._handler.signout, self._loop, handler_ctx, args.sessionId)
    return fut

  @process_method(execute_args, oneway=False, asyncio=True)
  def process_execute(self, args, handler_ctx, seqid, oprot, fn_name):
    result = execute_result()
    if should_run_on_thread(self._handler.execute):
      fut = self._loop.run_in_executor(None, self._handler.execute, handler_ctx, args.sessionId, args.stmt)
    else:
      fut = call_as_future(self._handler.execute, self._loop, handler_ctx, args.sessionId, args.stmt)
    fut.add_done_callback(lambda f: write_results_after_future(result, self._event_handler, handler_ctx, seqid, oprot, fn_name, {}, f))
    return fut

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

